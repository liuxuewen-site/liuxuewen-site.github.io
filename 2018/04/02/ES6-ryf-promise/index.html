<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>《ES6标准入门》之异步编程Promise | LIUXUEWEN&#39;S BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="LIUXUEWEN,LIUXUEWEN's Blog">
  
  <meta name="description" content="一、Promise1、基本概念 ：  Promise 是异步编程的一种解决方案。从语法上说，Promise 是一个对象。promise实现异步编程，是因为每一次promise的时候，都会返回一个promise对象，通过调用该对象的then方法，异步执行then里面的事件。   纠其原理的话：  其实Promise内部有一个 defers 队列存放事件，promise的then方法的作用是用来订阅事">
<meta name="keywords" content="前端-ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="《ES6标准入门》之异步编程Promise">
<meta property="og:url" content="http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/index.html">
<meta property="og:site_name" content="LIUXUEWEN&#39;S BLOG">
<meta property="og:description" content="一、Promise1、基本概念 ：  Promise 是异步编程的一种解决方案。从语法上说，Promise 是一个对象。promise实现异步编程，是因为每一次promise的时候，都会返回一个promise对象，通过调用该对象的then方法，异步执行then里面的事件。   纠其原理的话：  其实Promise内部有一个 defers 队列存放事件，promise的then方法的作用是用来订阅事">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-25T10:04:06.392Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《ES6标准入门》之异步编程Promise">
<meta name="twitter:description" content="一、Promise1、基本概念 ：  Promise 是异步编程的一种解决方案。从语法上说，Promise 是一个对象。promise实现异步编程，是因为每一次promise的时候，都会返回一个promise对象，通过调用该对象的then方法，异步执行then里面的事件。   纠其原理的话：  其实Promise内部有一个 defers 队列存放事件，promise的then方法的作用是用来订阅事">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">I AM LIUXUEWEN</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        I AM LIUXUEWEN
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个 宅不住 的 IT程序员
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Github" target="_blank" href="//github.com/liuxuewen-site">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" "="">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Weixin" "="">
                            <i class="fa fa-weixin fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-ES6-ryf-promise" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      《ES6标准入门》之异步编程Promise
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/前端/">前端</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2018-04-02
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h3 id="一、Promise"><a href="#一、Promise" class="headerlink" title="一、Promise"></a>一、Promise</h3><h4 id="1、基本概念-："><a href="#1、基本概念-：" class="headerlink" title="1、基本概念 ："></a>1、基本概念 ：</h4><p>  Promise 是异步编程的一种解决方案。从语法上说，Promise 是一个对象。promise实现异步编程，是因为每一次promise的时候，都会返回一个promise对象，通过调用该对象的then方法，异步执行then里面的事件。</p>
<p>  纠其原理的话：<br>  其实Promise内部有一个 defers 队列存放事件，promise的then方法的作用是用来订阅事件的，每次调用then方法就会往defers队列中放入一个事件，当异步操作完成时，promise的resolve方法标示前一个异步过程完成并从defers队列中取出第一个事件执行，并返回当前对象保证链式调用，以此类推，就完成了所有异步过程的队列执行。</p>
<p>  Promise 对象的特点：<br>  1）对象的状态不受外界影响。Promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>  2）一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变有两种可能：pending变fulfilled和pending变rejected。只要这两种情况发生，状态就凝固了，会一直保持这个结果，称为 resolved已定型（后面的resolved统一只指fulfilled状态）。如果改变已经发生，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>  Promise也有一些缺点：<br>  1）无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>  2）如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>  3）当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h4 id="2、基本用法："><a href="#2、基本用法：" class="headerlink" title="2、基本用法："></a>2、基本用法：</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ES6 规定，Promise对象是一个构造函数，用来生成Promise实例:</span><br><span class="line"></span><br><span class="line">const promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</span><br><span class="line">它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</span><br><span class="line"></span><br><span class="line">resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），</span><br><span class="line">在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br><span class="line">reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），</span><br><span class="line">在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br></pre></td></tr></table></figure>
<p>  <br \=""></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Promise实例生成以后，可以用<span class="keyword">then</span>方法分别指定resolved状态和rejected状态的回调函数:</span><br><span class="line"></span><br><span class="line">promise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">then</span>方法可以接受两个回调函数作为参数。</span><br><span class="line">第一个回调函数是Promise对象的状态变为resolved时调用，</span><br><span class="line">第二个回调函数是Promise对象的状态变为rejected时调用。</span><br><span class="line">其中，第二个函数是可选的。这两个函数都接受Promise对象传出的值作为参数。</span><br></pre></td></tr></table></figure>
<p>  <br \=""></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1）Promise对象的简单例子:</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。</span><br><span class="line">过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发<span class="keyword">then</span>方法绑定的回调函数。</span><br><span class="line"></span><br><span class="line">2）异步加载图片的例子:</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loadImageAsync(url) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    const image = new Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      reject(new Error(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码中，使用Promise包装了一个图片加载的异步操作。</span><br><span class="line">如果加载成功，就调用resolve方法，否则就调用reject方法。</span><br><span class="line"></span><br><span class="line">3）实现的 Ajax 操作的例子：</span><br><span class="line"></span><br><span class="line">const getJSON = <span class="keyword">function</span>(url) &#123;</span><br><span class="line">  const promise = new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">    const handler = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (this.readyState !== 4) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(json) &#123;</span><br><span class="line">  console.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，getJSON是对 XMLHttpRequest 对象的封装，</span><br><span class="line">用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。</span><br><span class="line">需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</span><br></pre></td></tr></table></figure>
<p>  <br \=""></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。</span><br><span class="line">reject函数的参数通常是Error对象的实例，表示抛出的错误；</span><br><span class="line">resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样:</span><br><span class="line"></span><br><span class="line">const p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">上面代码中，p1和p2都是 Promise 的实例，</span><br><span class="line">但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</span><br><span class="line"></span><br><span class="line">这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。</span><br><span class="line">如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；</span><br><span class="line">如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</span><br><span class="line"></span><br><span class="line">const p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(<span class="string">'fail'</span>)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br><span class="line"></span><br><span class="line">上面代码中，p1是一个 Promise，3 秒之后变为rejected,p2的状态在 1 秒之后改变，resolve方法返回的是p1。</span><br><span class="line">由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。</span><br><span class="line">所以，后面的<span class="keyword">then</span>语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</span><br></pre></td></tr></table></figure>
<p>  <br \=""></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Promise 新建后就会立即执行:</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  console.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line">// Promise</span><br><span class="line">// Hi!</span><br><span class="line">// resolved</span><br><span class="line"></span><br><span class="line">上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。</span><br><span class="line">然后，<span class="keyword">then</span>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</span><br></pre></td></tr></table></figure>
<p>  <br \=""></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">调用resolve或reject并不会终结 Promise 的参数函数的执行:</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;).<span class="keyword">then</span>(r =&gt; &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。</span><br><span class="line">这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</span><br><span class="line"></span><br><span class="line">一般来说，调用resolve或reject以后，Promise 的使命就完成了，</span><br><span class="line">后继操作应该放到<span class="keyword">then</span>方法里面，而不应该直接写在resolve或reject的后面。</span><br><span class="line">所以，最好在它们前面加上<span class="built_in">return</span>语句，这样就不会有意外。</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> resolve(1);</span><br><span class="line">  // 后面的语句不会执行</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3、Promise-prototype-then"><a href="#3、Promise-prototype-then" class="headerlink" title="3、Promise.prototype.then()"></a>3、Promise.prototype.then()</h4><p>  Promise 实例具有then方法，即then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p>  then方法返回的是一个新的Promise实例（注意不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(json) &#123;</span><br><span class="line">  <span class="built_in">return</span> json.post;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面的代码使用<span class="keyword">then</span>方法，依次指定了两个回调函数。</span><br><span class="line">第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</span><br></pre></td></tr></table></figure></p>
<p>  采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> funcA(comments) &#123;</span><br><span class="line">  console.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> funcB(err)&#123;</span><br><span class="line">  console.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，第一个<span class="keyword">then</span>方法指定的回调函数，返回的是另一个Promise对象。</span><br><span class="line">这时，第二个<span class="keyword">then</span>方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。</span><br><span class="line">如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span><br></pre></td></tr></table></figure></p>
<p>  如果采用箭头函数，上面的代码可以写得更简洁。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).<span class="keyword">then</span>(</span><br><span class="line">  comments =&gt; console.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; console.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="4、Promise-prototype-catch"><a href="#4、Promise-prototype-catch" class="headerlink" title="4、Promise.prototype.catch()"></a>4、Promise.prototype.catch()</h4><p>  Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，getJSON方法返回一个 Promise 对象，</span><br><span class="line">如果该对象状态变为resolved，则会调用<span class="keyword">then</span>方法指定的回调函数；</span><br><span class="line">如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。</span><br><span class="line">另外，<span class="keyword">then</span>方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</span><br><span class="line"></span><br><span class="line">p.then((val) =&gt; console.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch((err) =&gt; console.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">p.then((val) =&gt; console.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .<span class="keyword">then</span>(null, (err) =&gt; console.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure></p>
<p>  看个例子：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  throw new Error(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">// Error: <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。</span><br><span class="line">注意，上面的写法与下面两种写法是等价的。</span><br><span class="line"></span><br><span class="line">// 写法一</span><br><span class="line">const promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(<span class="string">'test'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">const promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  reject(new Error(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。</span><br></pre></td></tr></table></figure></p>
<p>  如果 Promise 状态已经变成resolved，再抛出错误是无效的:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  throw new Error(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123; console.log(value) &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(error) &#123; console.log(error) &#125;);</span><br><span class="line">// ok</span><br><span class="line"></span><br><span class="line">上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。</span><br><span class="line">因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</span><br></pre></td></tr></table></figure></p>
<p>  Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。即错误总是会被下一个catch语句捕获。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // 处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，一共有三个 Promise 对象：</span><br><span class="line">一个由getJSON产生，两个由<span class="keyword">then</span>产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</span><br></pre></td></tr></table></figure></p>
<p>  一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">promise</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    // success</span><br><span class="line">  &#125;, <span class="keyword">function</span>(err) &#123;</span><br><span class="line">    // error</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">promise</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(data) &#123; //cb</span><br><span class="line">    // success</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(err) &#123;</span><br><span class="line">    // error</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，第二种写法要好于第一种写法，</span><br><span class="line">理由是第二种写法可以捕获前面<span class="keyword">then</span>方法执行中的错误，也更接近同步的写法（try/catch）。</span><br><span class="line">因此，建议总是使用catch方法，而不使用<span class="keyword">then</span>方法的第二个参数。</span><br></pre></td></tr></table></figure></p>
<p>  跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);</span><br><span class="line">// Uncaught (<span class="keyword">in</span> promise) ReferenceError: x is not defined</span><br><span class="line">// 123</span><br><span class="line"></span><br><span class="line">上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。</span><br><span class="line">浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，</span><br><span class="line">但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。</span><br><span class="line">这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</span><br><span class="line"></span><br><span class="line">这个脚本放在服务器执行，退出码就是0（即表示执行成功）。</span><br><span class="line">不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，</span><br><span class="line">上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="keyword">function</span> (err, p) &#123;</span><br><span class="line">  throw err;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，unhandledRejection事件的监听函数有两个参数，</span><br><span class="line">第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</span><br><span class="line">注意，Node 有计划在未来废除unhandledRejection事件。</span><br><span class="line">如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</span><br></pre></td></tr></table></figure></p>
<p>  再看个例子：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span> () &#123; throw new Error(<span class="string">'test'</span>) &#125;, 0)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="keyword">function</span> (value) &#123; console.log(value) &#125;);</span><br><span class="line">// ok</span><br><span class="line">// Uncaught Error: <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。</span><br><span class="line">到了那个时候，Promise 的运行已经结束了，</span><br><span class="line">所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</span><br></pre></td></tr></table></figure></p>
<p>  一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line">// carry on</span><br><span class="line"></span><br><span class="line">上面代码运行完catch方法指定的回调函数，会接着运行后面那个<span class="keyword">then</span>方法指定的回调函数。</span><br><span class="line">如果没有报错，则会跳过catch方法。</span><br><span class="line"></span><br><span class="line">Promise.resolve()</span><br><span class="line">.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// carry on</span><br><span class="line"></span><br><span class="line">上面的代码因为没有报错，跳过了catch方法，直接执行后面的<span class="keyword">then</span>方法。</span><br><span class="line">此时，要是<span class="keyword">then</span>方法里面报错，就与前面的catch无关了。</span><br></pre></td></tr></table></figure></p>
<p>  catch方法之中，还能再抛出错误。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  // 下面一行会报错，因为 y 没有声明</span><br><span class="line">  y + 2;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line"></span><br><span class="line">上面代码中，catch方法抛出一个错误，</span><br><span class="line">因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。</span><br><span class="line">如果改写一下，结果就不一样了。</span><br><span class="line"></span><br><span class="line">omeAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  // 下面一行会报错，因为y没有声明</span><br><span class="line">  y + 2;</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line">// carry on [ReferenceError: y is not defined]</span><br><span class="line"></span><br><span class="line">上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。</span><br></pre></td></tr></table></figure></p>
<h4 id="5、Promise-prototype-finally"><a href="#5、Promise-prototype-finally" class="headerlink" title="5、Promise.prototype.finally()"></a>5、Promise.prototype.finally()</h4><p>  finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法的回调函数不接受任何参数，意味着没有办法知道前面的Promise状态是fulfilled还是rejected，这表明finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，不管promise最后的状态，在执行完<span class="keyword">then</span>或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br><span class="line"></span><br><span class="line">上面代码中，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</span><br></pre></td></tr></table></figure></p>
<p>  finally本质上是then方法的特例：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.<span class="keyword">then</span>(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。</span><br><span class="line">有了finally方法，则只需要写一次。</span><br></pre></td></tr></table></figure></p>
<p>  它的实现也很简单:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally = <span class="keyword">function</span> (callback) &#123;</span><br><span class="line">  <span class="built_in">let</span> P = this.constructor;</span><br><span class="line">  <span class="built_in">return</span> this.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).<span class="keyword">then</span>(() =&gt; value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).<span class="keyword">then</span>(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</span><br></pre></td></tr></table></figure></p>
<p>  从上面的实现还可以看到，finally方法总是会返回原来的值：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).<span class="keyword">then</span>(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 undefined</span><br><span class="line">Promise.reject(3).<span class="keyword">then</span>(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="6、Promise-all"><a href="#6、Promise-all" class="headerlink" title="6、Promise.all()"></a>6、Promise.all()</h4><p>  Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br><span class="line"></span><br><span class="line">上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，</span><br><span class="line">如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</span><br><span class="line">（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</span><br><span class="line"></span><br><span class="line">p的状态由p1、p2、p3决定，分成两种情况。</span><br><span class="line">1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，</span><br><span class="line">此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</span><br><span class="line">2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，</span><br><span class="line">此时第一个被reject的实例的返回值，会传递给p的回调函数。</span><br></pre></td></tr></table></figure></p>
<p>  具体的例子:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">const promises = [2, 3, 5, 7, 11, 13].map(<span class="keyword">function</span> (id) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).<span class="keyword">then</span>(<span class="keyword">function</span> (posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，promises是包含 6 个 Promise 实例的数组，</span><br><span class="line">只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</span><br><span class="line"></span><br><span class="line">const databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line">const booksPromise = databasePromise</span><br><span class="line">  .<span class="keyword">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line">const userPromise = databasePromise</span><br><span class="line">  .<span class="keyword">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line">Promise.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.<span class="keyword">then</span>(([books, user]) =&gt; pickTopRecommentations(books, user));</span><br><span class="line"></span><br><span class="line">上面代码中，booksPromise和userPromise是两个异步操作，</span><br><span class="line">只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</span><br></pre></td></tr></table></figure></p>
<p>  如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// [<span class="string">"hello"</span>, Error: 报错了]</span><br><span class="line"></span><br><span class="line">上面代码中，p1会resolved，p2首先会rejected，</span><br><span class="line">但是p2有自己的catch方法，该方法返回的是一个新的Promise实例，p2指向的实际上是这个实例。</span><br><span class="line">该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，</span><br><span class="line">因此会调用<span class="keyword">then</span>方法指定的回调函数，而不会调用catch方法指定的回调函数。</span><br><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; result);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; result);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// Error: 报错了</span><br><span class="line"></span><br><span class="line">上面代码中，如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</span><br></pre></td></tr></table></figure></p>
<h4 id="7、Promise-race"><a href="#7、Promise-race" class="headerlink" title="7、Promise.race()"></a>7、Promise.race()</h4><p>  Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([p1, p2, p3]);</span><br><span class="line"></span><br><span class="line">上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。</span><br><span class="line">那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</span><br><span class="line"></span><br><span class="line">Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，</span><br><span class="line">就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</span><br></pre></td></tr></table></figure></p>
<p>  看个例子：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(<span class="string">'request timeout'</span>)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="keyword">then</span>(console.log)</span><br><span class="line">.catch(console.error);</span><br><span class="line"></span><br><span class="line">上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</span><br></pre></td></tr></table></figure></p>
<h4 id="8、Promise-resolve"><a href="#8、Promise-resolve" class="headerlink" title="8、Promise.resolve()"></a>8、Promise.resolve()</h4><p>  Promise.resolve方法可将现有对象转为 Promise 对象:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const jsPromise = Promise.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br><span class="line"></span><br><span class="line">上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。</span><br></pre></td></tr></table></figure></p>
<p>  Promise.resolve等价于下面的写法:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt; resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure></p>
<p>  Promise.resolve方法的参数分成四种情况:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）参数是一个 Promise 实例</span><br><span class="line"></span><br><span class="line">如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（2）参数是一个 thenable 对象</span><br><span class="line"></span><br><span class="line">thenable对象指的是具有<span class="keyword">then</span>方法的对象，比如下面这个对象:</span><br><span class="line"><span class="built_in">let</span> thenable = &#123;</span><br><span class="line">  <span class="keyword">then</span>: <span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    resolve(42);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的<span class="keyword">then</span>方法。</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> thenable = &#123;</span><br><span class="line">  <span class="keyword">then</span>: <span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    resolve(42);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">let</span> p1 = Promise.resolve(thenable);</span><br><span class="line">p1.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">  console.log(value);  // 42</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，thenable对象的<span class="keyword">then</span>方法执行后，对象p1的状态就变为resolved，</span><br><span class="line">从而立即执行最后那个<span class="keyword">then</span>方法指定的回调函数，输出 42。</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（3）参数不是具有<span class="keyword">then</span>方法的对象，或根本就不是对象:</span><br><span class="line"></span><br><span class="line">如果参数是一个原始值或是一个不具有<span class="keyword">then</span>方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</span><br><span class="line"></span><br><span class="line">const p = Promise.resolve(<span class="string">'Hello'</span>);</span><br><span class="line">p.then(<span class="keyword">function</span> (s)&#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// Hello</span><br><span class="line"></span><br><span class="line">上面代码生成一个新的Promise对象的实例p。</span><br><span class="line">由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 <span class="keyword">then</span> 方法），</span><br><span class="line">返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。</span><br><span class="line">Promise.resolve方法的参数，会同时传给回调函数。</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">（4）不带有任何参数:</span><br><span class="line"></span><br><span class="line">Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</span><br><span class="line"></span><br><span class="line">const p = Promise.resolve();</span><br><span class="line">p.then(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面代码中，得到了一个 Promise 对象p。</span><br><span class="line"></span><br><span class="line">需要注意的是，立即resolve的 Promise 对象，</span><br><span class="line">是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line">// one</span><br><span class="line">// two</span><br><span class="line">// three</span><br><span class="line"></span><br><span class="line">上面代码中，</span><br><span class="line">setTimeout(fn, 0)在下一轮“事件循环”开始时执行，</span><br><span class="line">Promise.resolve()在本轮“事件循环”结束时执行，</span><br><span class="line">console.log(<span class="string">'one'</span>)则是立即执行，因此最先输出。</span><br></pre></td></tr></table></figure>
<h4 id="9、Promise-reject"><a href="#9、Promise-reject" class="headerlink" title="9、Promise.reject()"></a>9、Promise.reject()</h4><p>  Promise.reject(reason)方法会返回一个新的 Promise 实例，该实例的状态为rejected。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">// 等同于</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(null, <span class="keyword">function</span> (s) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br><span class="line"></span><br><span class="line">上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行</span><br></pre></td></tr></table></figure></p>
<p>  注意，Promise.reject()方法的参数会原封不动地作为reject的理由，变成后续方法的参数。这与Promise.resolve方法不一致。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const thenable = &#123;</span><br><span class="line">  <span class="keyword">then</span>(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.reject(thenable)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">  console.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">上面代码中，Promise.reject方法的参数是一个thenable对象，</span><br><span class="line">执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span><br></pre></td></tr></table></figure></p>
<h4 id="10、Promise-try"><a href="#10、Promise-try" class="headerlink" title="10、Promise.try()"></a>10、Promise.try()</h4><p>  开发中有时我们不知道或不想区分函数f是同步函数还是异步操作，但想用Promise来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().<span class="keyword">then</span>(f)</span><br><span class="line"></span><br><span class="line">上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。</span><br><span class="line"></span><br><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(f);</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// next</span><br><span class="line">// now</span><br><span class="line"></span><br><span class="line">上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。</span><br></pre></td></tr></table></figure></p>
<p>  那么有没有方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？有两种写法。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">第一种写法是用async函数来写:</span><br><span class="line"></span><br><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">(async () =&gt; f())();</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// now</span><br><span class="line">// next</span><br><span class="line"></span><br><span class="line">上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，</span><br><span class="line">因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用<span class="keyword">then</span>指定下一步，就像下面的写法:</span><br><span class="line"></span><br><span class="line">(async () =&gt; f())()</span><br><span class="line">.<span class="keyword">then</span>(...)</span><br><span class="line"></span><br><span class="line">需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</span><br><span class="line"></span><br><span class="line">(async () =&gt; f())()</span><br><span class="line">.<span class="keyword">then</span>(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第二种写法是使用new Promise():</span><br><span class="line"></span><br><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; new Promise(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// now</span><br><span class="line">// next</span><br><span class="line"></span><br><span class="line">上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。</span><br></pre></td></tr></table></figure>
<p>  后来，Promise.try出现了，为所有操作提供了统一的处理机制，不管是同步还是异步，try后都可以用then方法管理流程，另外也能可以更好地管理异常。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getUsername(userId) &#123;</span><br><span class="line">  <span class="built_in">return</span> database.users.get(&#123;id: userId&#125;)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(user) &#123;</span><br><span class="line">    <span class="built_in">return</span> user.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码中，database.users.get()返回一个 Promise 对象，</span><br><span class="line">如果抛出异步错误，可以用catch方法捕获，就像下面这样写:</span><br><span class="line"></span><br><span class="line">database.users.get(&#123;id: userId&#125;)</span><br><span class="line">.<span class="keyword">then</span>(...)</span><br><span class="line">.catch(...)</span><br><span class="line"></span><br><span class="line">但是database.users.get()可能还会抛出同步错误</span><br><span class="line">比如数据库连接错误，具体要看实现方法，这时你就不得不用try...catch去捕获。</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  database.users.get(&#123;id: userId&#125;)</span><br><span class="line">  .<span class="keyword">then</span>(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。</span><br><span class="line"></span><br><span class="line">Promise.try(database.users.get(&#123;id: userId&#125;))</span><br><span class="line">  .<span class="keyword">then</span>(...)</span><br><span class="line">  .catch(...)</span><br><span class="line"></span><br><span class="line">事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</span><br></pre></td></tr></table></figure></p>
<h4 id="11、应用"><a href="#11、应用" class="headerlink" title="11、应用"></a>11、应用</h4><p>  加载图片：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化:</span><br><span class="line"></span><br><span class="line">const preloadImage = <span class="keyword">function</span> (path) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    const image = new Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  Generator 函数与 Promise 的结合:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象:</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getFoo</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject)&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const foo = yield getFoo();</span><br><span class="line">    console.log(foo);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> run (generator) &#123;</span><br><span class="line">  const it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> go(result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="built_in">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> result.value.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">      <span class="built_in">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="keyword">function</span> (error) &#123;</span><br><span class="line">      <span class="built_in">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br><span class="line"></span><br><span class="line">上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。</span><br><span class="line">函数run用来处理这个Promise对象，并调用下一个next方法。</span><br></pre></td></tr></table></figure></p>
<p>标注：</p>
<ul>
<li>参考资料1：<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></li>
</ul>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年01月25日 18:04</p>
        <p>原始链接： <a class="post-url" href="/2018/04/02/ES6-ryf-promise/" title="《ES6标准入门》之异步编程Promise">http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/</a></p>
        <footer>
            <a href="http://liuxuewen-site.github.io">
                <img src="/images/logo.png" alt="liuxuewen">
                liuxuewen
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/&title=《《ES6标准入门》之异步编程Promise》 — LIUXUEWEN'S BLOG&pic=http://liuxuewen-site.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/&title=《《ES6标准入门》之异步编程Promise》 — LIUXUEWEN'S BLOG&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《ES6标准入门》之异步编程Promise》 — LIUXUEWEN'S BLOG&url=http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/&via=http://liuxuewen-site.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/前端-ES6/" class="color2">前端-ES6</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一、Promise"><span class="post-toc-text">一、Promise</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1、基本概念-："><span class="post-toc-text">1、基本概念 ：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2、基本用法："><span class="post-toc-text">2、基本用法：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3、Promise-prototype-then"><span class="post-toc-text">3、Promise.prototype.then()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4、Promise-prototype-catch"><span class="post-toc-text">4、Promise.prototype.catch()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5、Promise-prototype-finally"><span class="post-toc-text">5、Promise.prototype.finally()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6、Promise-all"><span class="post-toc-text">6、Promise.all()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7、Promise-race"><span class="post-toc-text">7、Promise.race()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8、Promise-resolve"><span class="post-toc-text">8、Promise.resolve()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9、Promise-reject"><span class="post-toc-text">9、Promise.reject()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#10、Promise-try"><span class="post-toc-text">10、Promise.try()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11、应用"><span class="post-toc-text">11、应用</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2018/04/03/ES6-ryf-generator/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          《ES6标准入门》之异步编程Generator
        
      </span>
    </a>
  
  
    <a href="/2018/03/18/secure-bs-attack/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">前端安全攻击</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <!-- <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 liuxuewen<br>
      </p> -->
      <p>
        1320325272@qq.com 
        liuxuewen
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "http://liuxuewen-site.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/hexo/">hexo</a><a class="category-link" href="/categories/前端/">前端</a><a class="category-link" href="/categories/后台/">后台</a><a class="category-link" href="/categories/数据结构/">数据结构</a><a class="category-link" href="/categories/网络协议/">网络协议</a><a class="category-link" href="/categories/项目/">项目</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/hexo/" style="font-size: 12.86px;">hexo</a> <a href="/tags/前端-CSS/" style="font-size: 14.29px;">前端-CSS</a> <a href="/tags/前端-ES6/" style="font-size: 11.43px;">前端-ES6</a> <a href="/tags/前端-HTML5/" style="font-size: 10px;">前端-HTML5</a> <a href="/tags/前端-JS/" style="font-size: 18.57px;">前端-JS</a> <a href="/tags/前端-react/" style="font-size: 20px;">前端-react</a> <a href="/tags/前端-安全性/" style="font-size: 10px;">前端-安全性</a> <a href="/tags/前端-性能优化/" style="font-size: 10px;">前端-性能优化</a> <a href="/tags/前端-服务器/" style="font-size: 11.43px;">前端-服务器</a> <a href="/tags/前端-移动端适配/" style="font-size: 11.43px;">前端-移动端适配</a> <a href="/tags/前端-考题/" style="font-size: 17.14px;">前端-考题</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/网络协议/" style="font-size: 15.71px;">网络协议</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/hexo/" style="font-size: 12.86px;">hexo</a> <a href="/tags/前端-CSS/" style="font-size: 14.29px;">前端-CSS</a> <a href="/tags/前端-ES6/" style="font-size: 11.43px;">前端-ES6</a> <a href="/tags/前端-HTML5/" style="font-size: 10px;">前端-HTML5</a> <a href="/tags/前端-JS/" style="font-size: 18.57px;">前端-JS</a> <a href="/tags/前端-react/" style="font-size: 20px;">前端-react</a> <a href="/tags/前端-安全性/" style="font-size: 10px;">前端-安全性</a> <a href="/tags/前端-性能优化/" style="font-size: 10px;">前端-性能优化</a> <a href="/tags/前端-服务器/" style="font-size: 11.43px;">前端-服务器</a> <a href="/tags/前端-移动端适配/" style="font-size: 11.43px;">前端-移动端适配</a> <a href="/tags/前端-考题/" style="font-size: 17.14px;">前端-考题</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/网络协议/" style="font-size: 15.71px;">网络协议</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>