<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Dva官网之06-dva 源码解析 | LIUXUEWEN&#39;S BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="LIUXUEWEN,LIUXUEWEN's Blog">
  
  <meta name="description" content="一、项目 &amp;gt; package.json  dva 项目只要敲入 npm start 就可以运行启动，在敲下这行命令的时候发生了什么？答案要去 package.json 里去寻找（看源码之前，先去看 package.json，看看项目的入口文件，用了哪些依赖，对项目便有了大致的概念）。   package.json 里写：  123&quot;scripts&quot;: &amp;#123;    &quot;start&quot;: &quot;">
<meta name="keywords" content="前端-react">
<meta property="og:type" content="article">
<meta property="og:title" content="Dva官网之06-dva 源码解析">
<meta property="og:url" content="http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/index.html">
<meta property="og:site_name" content="LIUXUEWEN&#39;S BLOG">
<meta property="og:description" content="一、项目 &amp;gt; package.json  dva 项目只要敲入 npm start 就可以运行启动，在敲下这行命令的时候发生了什么？答案要去 package.json 里去寻找（看源码之前，先去看 package.json，看看项目的入口文件，用了哪些依赖，对项目便有了大致的概念）。   package.json 里写：  123&quot;scripts&quot;: &amp;#123;    &quot;start&quot;: &quot;">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-22T10:18:00.294Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dva官网之06-dva 源码解析">
<meta name="twitter:description" content="一、项目 &amp;gt; package.json  dva 项目只要敲入 npm start 就可以运行启动，在敲下这行命令的时候发生了什么？答案要去 package.json 里去寻找（看源码之前，先去看 package.json，看看项目的入口文件，用了哪些依赖，对项目便有了大致的概念）。   package.json 里写：  123&quot;scripts&quot;: &amp;#123;    &quot;start&quot;: &quot;">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">I AM LIUXUEWEN</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        I AM LIUXUEWEN
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个 宅不住 的 IT程序员
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Github" target="_blank" href="//github.com/liuxuewen-site">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" "="">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Weixin" "="">
                            <i class="fa fa-weixin fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Dva-gw-06" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Dva官网之06-dva 源码解析
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/前端/">前端</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-01-08
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h3 id="一、项目-gt-package-json"><a href="#一、项目-gt-package-json" class="headerlink" title="一、项目 &gt; package.json"></a>一、项目 &gt; package.json</h3><p>  dva 项目只要敲入 npm start 就可以运行启动，在敲下这行命令的时候发生了什么？答案要去 package.json 里去寻找（看源码之前，先去看 package.json，看看项目的入口文件，用了哪些依赖，对项目便有了大致的概念）。</p>
<p>  package.json 里写：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"roadhog server"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>  翻翻依赖:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"roadhog"</span>: <span class="string">"^0.5.2"</span>。</span><br></pre></td></tr></table></figure></p>
<p>  既然能在 devDependencies 找到，那么肯定也能在 npm 上找到，原来是个和 webpack 相似的库，而且作者看着有点眼熟。如果说 dva 是亲女儿，那 roadhog 就是亲哥哥，起的是 webpack 自动打包和热更替的作用。在 roadhog 的默认配置里有这么一条信息：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"entry"</span>: <span class="string">"src/index.js"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  转了一圈，启动的入口回到了 src/index.js。</p>
<h3 id="二、项目-gt-src-index-js"><a href="#二、项目-gt-src-index-js" class="headerlink" title="二、项目 &gt; src/index.js"></a>二、项目 &gt; src/index.js</h3><p>  在 src/index.js 里，dva 一共做了这么几件事：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import dva from <span class="string">'dva'</span>;                             // 从 dva 依赖中引入 dva</span><br><span class="line"></span><br><span class="line">const app = dva();                                 // 通过函数生成一个 app 对象</span><br><span class="line"></span><br><span class="line">app.use(&#123;&#125;);                                       // 加载插件</span><br><span class="line"></span><br><span class="line">app.model(require(<span class="string">'./models/example'</span>));            // 注入 model</span><br><span class="line"></span><br><span class="line">app.router(require(<span class="string">'./routes/indexAnother'</span>));      // 添加路由</span><br><span class="line"></span><br><span class="line">app.start(<span class="string">'#root'</span>);                                // 启动</span><br></pre></td></tr></table></figure></p>
<p>  在这 6 步当中，dva 完成了使用 React 解决 view 层、redux 管理 model、saga 解决异步的主要功能。事实上目前前端框架之所以被称为框架也就是解决了这些事情。前端工程师至今所做的事情都是在分离动态的 data 和静态的 view，只不过侧重点和实现方式也不同。</p>
<p>  至今为止出了这么多框架，但是前端 MVX 的思想一直都没有改变。</p>
<h3 id="三、dva-gt-package-json"><a href="#三、dva-gt-package-json" class="headerlink" title="三、dva &gt; package.json"></a>三、dva &gt; package.json</h3><p>  剧透：dva 是个函数，返回一了个 app 的对象。目前 dva 的源码核心部分包含两部分，dva 和 dva-core。前者用高阶组件 React-redux 实现了 view 层，后者是用 redux-saga 解决了 model 层。</p>
<p>  接下来我们寻找一下 dva 的 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">源码</a>。老规矩，还是先翻 package.json。引用依赖很好的说明了 dva 的功能：统一 view 层。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// dva 使用的依赖如下：</span><br><span class="line"></span><br><span class="line"><span class="string">"babel-runtime"</span>: <span class="string">"^6.26.0"</span>,                 // 一个编译后文件引用的公共库，可以有效减少编译后的文件体积</span><br><span class="line"><span class="string">"dva-core"</span>: <span class="string">"^1.1.0"</span>,                       // dva 另一个核心，用于处理数据层</span><br><span class="line"><span class="string">"global"</span>: <span class="string">"^4.3.2"</span>,                         // 用于提供全局函数的引用</span><br><span class="line"><span class="string">"history"</span>: <span class="string">"^4.6.3"</span>,                        // browserHistory 或者 hashHistory</span><br><span class="line"><span class="string">"invariant"</span>: <span class="string">"^2.2.2"</span>,                      // 一个有趣的断言库</span><br><span class="line"><span class="string">"isomorphic-fetch"</span>: <span class="string">"^2.2.1"</span>,               // 方便请求异步的函数，dva 中的 fetch 来源</span><br><span class="line"><span class="string">"react-async-component"</span>: <span class="string">"^1.0.0-beta.3"</span>,   // 组件懒加载</span><br><span class="line"><span class="string">"react-redux"</span>: <span class="string">"^5.0.5"</span>,                    // 提供了一个高阶组件，方便在各处调用 store</span><br><span class="line"><span class="string">"react-router-dom"</span>: <span class="string">"^4.1.2"</span>,               // router4，终于可以像写组件一样写 router 了</span><br><span class="line"><span class="string">"react-router-redux"</span>: <span class="string">"5.0.0-alpha.6"</span>,      // redux 的中间件，在 provider 里可以嵌套 router</span><br><span class="line"><span class="string">"redux"</span>: <span class="string">"^3.7.2"</span>                           // 提供了 store、dispatch、reducer</span><br></pre></td></tr></table></figure></p>
<p>  不过 script 没有给太多有用的信息，因为 ruban build 中的 ruban 显然是个私人库(虽然在 tnpm 上可以查到但也是私人库)。根据惯例，应该是 dva 包下的 index.js 文件提供了对外调用：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">    value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">exports.default = require(<span class="string">'./lib'</span>);</span><br><span class="line">exports.connect = require(<span class="string">'react-redux'</span>).connect;</span><br></pre></td></tr></table></figure></p>
<p>  显然这个 exports.default 就是我们要找的 dva，但是源码中没有 ./lib 文件夹。当然直接看也应该看不懂，因为一般都是使用 babel 的命令 babel src -d libs 进行编译后生成的，所以直接去看 src/index.js 文件。</p>
<h3 id="四、dva-gt-src-index-js"><a href="#四、dva-gt-src-index-js" class="headerlink" title="四、dva &gt; src/index.js"></a>四、dva &gt; src/index.js</h3><p>  在 <a href="https://github.com/dvajs/dva/blob/master/packages/dva/src/index.js" target="_blank" rel="noopener">src/index.js</a> 中，dva 做了三件比较重要的事情：</p>
<p>  1）使用 call 给 dva-core 实例化的 app(这个时候还只有数据层) 的 start 方法增加了一些新功能（或者说，通过代理模式给 model 层增加了 view 层）。<br>  2）使用 react-redux 完成了 react 到 redux 的连接。<br>  3）添加了 redux 的中间件 react-redux-router，强化了 history 对象的功能。</p>
  <font size="4" face="黑体"><strong>使用 call 方法实现代理模式：</strong></font>

<p>  dva 中实现代理模式的方式如下：<br>  a. 新建 function，函数内实例化一个 app 对象。<br>  b. 新建变量指向该对象希望代理的方法， oldStart = app.start。<br>  c. 新建同名方法 start，在其中使用 call，指定 oldStart 的调用者为 app。<br>  d. 令 app.start = start，完成对 app 对象的 start 方法的代理。</p>
<p>  上代码:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span>(opts = &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    // ...初始化 route ，和添加 route 中间件的方法。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 1. 新建 <span class="keyword">function</span> ，函数内实例化一个 app 对象。</span><br><span class="line">    */</span><br><span class="line">    const app = core.create(opts, createOpts);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 2. 新建变量指向该对象希望代理的方法</span><br><span class="line">    */</span><br><span class="line">    const oldAppStart = app.start;</span><br><span class="line">    app.router = router;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 4. 令 app.start = start，完成对 app 对象的 start 方法的代理。</span><br><span class="line">    * @<span class="built_in">type</span> &#123;[<span class="built_in">type</span>]&#125;</span><br><span class="line">    */</span><br><span class="line">    app.start = start;</span><br><span class="line">    <span class="built_in">return</span> app;</span><br><span class="line"></span><br><span class="line">    // router 赋值</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 3.1 新建同名方法 start，</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">function</span> start(container) &#123;</span><br><span class="line">        // 合法性检测代码</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 3.2 在其中使用 call，指定 oldStart 的调用者为 app。</span><br><span class="line">        */</span><br><span class="line">        oldAppStart.call(app);</span><br><span class="line">        </span><br><span class="line">        // 因为有 3.2 的执行才有现在的 store</span><br><span class="line">        const store = app._store;</span><br><span class="line"></span><br><span class="line">        // 使用高阶组件创建视图</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  问题一：为什么不直接在 start 方式中 oldAppStart？因为 dva-core 的 start 方法里有用到 this，不用 call 指定调用者为 app 的话，oldAppStart() 会找错对象。</p>
<p>  问题二：实现代理模式一定要用到 call 吗？不一定，看有没有 使用 this 或者代理的函数是不是箭头函数。从另一个角度来说，如果使用了 function 关键字又在内部使用了 this，那么一定要用 call/apply/bind 指定 this。</p>
<p>  问题三：前端还有那里会用到 call？就实际开发来讲，因为已经使用了 es6 标准，基本和 this 没什么打交道的机会。使用 class 类型的组件中偶尔还会用到 this.xxx.bind(this)，stateless 组件就洗洗睡吧(因为压根没有 this)。如果实现代理，可以使用继承/反向继承的方法 —— 比如高阶组件。</p>
  <font size="4" face="黑体"><strong>使用 react-redux 的高阶组件传递 store：</strong></font>

<p>  经过 call 代理后的 start 方法的主要作用，便是使用 react-redux 的 provider 组件将数据与视图联系了起来，生成 React 元素呈现给使用者。</p>
<p>  上代码：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 使用 querySelector 获得 dom</span><br><span class="line"><span class="keyword">if</span> (isString(container)) &#123;</span><br><span class="line">    container = document.querySelector(container);</span><br><span class="line">    invariant(</span><br><span class="line">        container,</span><br><span class="line">        `[app.start] container <span class="variable">$&#123;container&#125;</span> not found`,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其他代码</span><br><span class="line"></span><br><span class="line">// 实例化 store</span><br><span class="line">oldAppStart.call(app); </span><br><span class="line">const store = app._store;</span><br><span class="line"></span><br><span class="line">// <span class="built_in">export</span> _getProvider <span class="keyword">for</span> HMR</span><br><span class="line">// ref: https://github.com/dvajs/dva/issues/469</span><br><span class="line">app._getProvider = getProvider.bind(null, store, app);</span><br><span class="line"></span><br><span class="line">// If has container, render; <span class="keyword">else</span>, <span class="built_in">return</span> react component</span><br><span class="line">// 如果有真实的 dom 对象就把 react 拍进去</span><br><span class="line"><span class="keyword">if</span> (container) &#123;</span><br><span class="line">    render(container, store, app, app._router);</span><br><span class="line">    // 热加载在这里</span><br><span class="line">    app._plugin.apply(<span class="string">'onHmr'</span>)(render.bind(null, container, store, app));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 否则就生成一个 react ，供外界调用</span><br><span class="line">    <span class="built_in">return</span> getProvider(store, this, this._router);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用高阶组件包裹组件</span><br><span class="line"><span class="keyword">function</span> getProvider(store, app, router) &#123;</span><br><span class="line">    <span class="built_in">return</span> extraProps =&gt; (</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &#123; router(&#123; app, <span class="built_in">history</span>: app._history, ...extraProps &#125;) &#125;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 真正的 react 在这里</span><br><span class="line"><span class="keyword">function</span> render(container, store, app, router) &#123;</span><br><span class="line">    const ReactDOM = require(<span class="string">'react-dom'</span>);  // eslint-disable-line</span><br><span class="line">    ReactDOM.render(React.createElement(getProvider(store, app, router)), container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  问题一：React.createElement(getProvider(store, app, router)) 怎么理解？getProvider 实际上返回的不单纯是函数，而是一个无状态的 React 组件。从这个角度理解的话，ReactElement.createElement(string/ReactClass type,[object props],[children …]) 是可以这么写的。</p>
<p>  问题二：怎么理解 React 的 stateless 组件和 class 组件？JavaScript 并不存在 class 这个东西，即便是 es6 引入了以后经过 babel 编译也会转换成函数。因此直接使用无状态组件，省去了将 class 实例化再调用 render 函数的过程，有效的加快了渲染速度。即便是 class 组件，React.createElement 最终调用的也是 render 函数。不过这个目前只是推论，没有代码证据的证明。</p>
<p>  问题三：provider 是个什么东西？本质上是个高阶组件，也是代理模式的一种实践方式。接收 redux 生成的 store 做参数后，通过上下文 context 将 store 传递进被代理组件。在保留原组件的功能不变的同时，增加了 store 的 dispatch 等方法。</p>
<p>  问题四：connect 是个什么东西？connect 也是一个代理模式实现的高阶组件，为被代理的组件实现了从 context 中获得 store 的方法。</p>
<p>  问题五：connect()(MyComponent) 时发生了什么？先看结论，对于 connect()(MyComponent)，a、connect 调用时生成 0 号 connect；b、connect() 0 号 connect 调用，返回 1 号 connect 的调用 connectHOC() ，生成 2 号 connect(也是个函数) ；c、connect()(MyComponent) 等价于 connect2(MyComponent)，返回值是一个新的组件。再放关键部分代码:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import connectAdvanced from <span class="string">'../components/connectAdvanced'</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> createConnect(&#123;</span><br><span class="line">    connectHOC = connectAdvanced,</span><br><span class="line">    .... 其他初始值</span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> connect( &#123; // 0 号 connnect</span><br><span class="line">        mapStateToProps,</span><br><span class="line">        mapDispatchToProps,</span><br><span class="line">        ... 其他初始值</span><br><span class="line">        &#125; = &#123;&#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        ....其他逻辑</span><br><span class="line">        <span class="built_in">return</span> connectHOC(selectorFactory, &#123;//  1号 connect</span><br><span class="line">            .... 默认参数</span><br><span class="line">            selectorFactory 也是个默认参数</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default createConnect() // 这是 connect 的本体，导出时即生成 connect 0</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// hoist-non-react-statics，会自动把所有绑定在对象上的非React方法都绑定到新的对象上</span><br><span class="line">import hoistStatics from <span class="string">'hoist-non-react-statics'</span></span><br><span class="line"></span><br><span class="line">// 1号 connect 的本体</span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">connectAdvanced</span></span>() &#123;</span><br><span class="line">    // 逻辑处理</span><br><span class="line"></span><br><span class="line">    // 1 号 connect 调用时生成 2 号 connect</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> wrapWithConnect(WrappedComponent) &#123;</span><br><span class="line">        // ... 逻辑处理</span><br><span class="line"></span><br><span class="line">        // 在函数内定义了一个可以拿到上下文对象中 store 的组件</span><br><span class="line">        class Connect extends Component &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="function"><span class="title">getChildContext</span></span>() &#123;</span><br><span class="line">                // 上下文对象中获得 store</span><br><span class="line">                const subscription = this.propsMode ? null : this.subscription</span><br><span class="line">                <span class="built_in">return</span> &#123; [subscriptionKey]: subscription || this.context[subscriptionKey] &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            // 逻辑处理</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">                // 	最终生成了新的 react 元素，并添加了新属性</span><br><span class="line">                <span class="built_in">return</span> createElement(WrappedComponent, this.addExtraProps(selector.props))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 逻辑处理</span><br><span class="line">        </span><br><span class="line">        // 最后用定义的 class 和 被代理的组件生成新的 react 组件</span><br><span class="line">        <span class="built_in">return</span> hoistStatics(Connect, WrappedComponent)  // 2 号函数调用后生成的对象是组件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <font size="4" face="黑体"><strong>redux 与 router：</strong></font>

<p>  redux 是状态管理的库，router 是唯一控制页面跳转的库。两者都很美好，但是不美好的是两者无法协同工作。换句话说，当路由变化以后，store 无法感知到。</p>
<p>  于是便有了 <a href="https://github.com/reactjs/react-router-redux" target="_blank" rel="noopener">react-router-redux</a>。react-router-redux 是 redux 的一个中间件(中间件：JavaScript 代理模式的另一种实践 针对 dispatch 实现了方法的代理，在 dispatch action 的时候增加或者修改) ，主要作用是加强了 React Router 库中 history 这个实例，以允许将 history 中接受到的变化反应到 state 中去。</p>
<p>  从代码上讲，主要是监听了 history 的变化：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.listen(location =&gt; analyticsService.track(location.pathname))</span><br></pre></td></tr></table></figure></p>
<p>  dva 在此基础上又进行了一层代理，把代理后的对象当作初始值传递给了 dva-core，方便其在 model 的 subscriptions 中监听 router 变化。</p>
<p>  看看 index.js 里 router 的实现：<br>  a、在 createOpts 中初始化了添加 react-router-redux 中间件的方法和其 reducer ，方便 dva-core 在创建 store 的时候直接调用。<br>  b、使用 patchHistory 函数代理 history.linsten，增加了一个回调函数的做参数(也就是订阅)。</p>
<p>  问题一：subscriptions 的东西可以放在 dva-core 里再说：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import createHashHistory from <span class="string">'history/createHashHistory'</span>;</span><br><span class="line">import &#123;</span><br><span class="line">    routerMiddleware,</span><br><span class="line">    routerReducer as routing,</span><br><span class="line">&#125; from <span class="string">'react-router-redux'</span>;</span><br><span class="line">import * as core from <span class="string">'dva-core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> (opts = &#123;&#125;) &#123;</span><br><span class="line">    const <span class="built_in">history</span> = opts.history || createHashHistory();</span><br><span class="line">    const createOpts = &#123;</span><br><span class="line">        // 	初始化 react-router-redux 的 router</span><br><span class="line">        initialReducer: &#123;</span><br><span class="line">            routing,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 初始化 react-router-redux 添加中间件的方法，放在所有中间件最前面</span><br><span class="line">        setupMiddlewares(middlewares) &#123;</span><br><span class="line">            <span class="built_in">return</span> [</span><br><span class="line">                routerMiddleware(<span class="built_in">history</span>),</span><br><span class="line">                ...middlewares,</span><br><span class="line">            ];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 使用代理模式为 <span class="built_in">history</span> 对象增加新功能，并赋给 app</span><br><span class="line">        setupApp(app) &#123;</span><br><span class="line">            app._history = patchHistory(<span class="built_in">history</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const app = core.create(opts, createOpts);</span><br><span class="line">    const oldAppStart = app.start;</span><br><span class="line">    app.router = router;</span><br><span class="line">    app.start = start;</span><br><span class="line">    <span class="built_in">return</span> app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> router(router) &#123;</span><br><span class="line">        invariant(</span><br><span class="line">            isFunction(router),</span><br><span class="line">            `[app.router] router should be <span class="keyword">function</span>, but got <span class="variable">$&#123;typeof router&#125;</span>`,</span><br><span class="line">        );</span><br><span class="line">        app._router = router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用代理模式扩展 <span class="built_in">history</span> 对象的 listen 方法，添加了一个回调函数做参数并在路由变化是主动调用</span><br><span class="line"><span class="keyword">function</span> patchHistory(<span class="built_in">history</span>) &#123;</span><br><span class="line">    const oldListen = history.listen;</span><br><span class="line">    history.listen = (callback) =&gt; &#123;</span><br><span class="line">        callback(history.location);</span><br><span class="line">        <span class="built_in">return</span> oldListen.call(<span class="built_in">history</span>, callback);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">history</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  问题二：redux 中创建 store 的方法为：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// combineReducers 接收的参数是对象</span><br><span class="line">// 所以 initialReducer 的类型是对象</span><br><span class="line">// 作用：将对象中所有的 reducer 组合成一个大的 reducer</span><br><span class="line">const reducers = &#123;&#125;; </span><br><span class="line">// applyMiddleware 接收的参数是可变参数</span><br><span class="line">// 所以 middleware 是数组</span><br><span class="line">// 作用：将所有中间件组成一个数组，依次执行</span><br><span class="line">const middleware = []; </span><br><span class="line">const store = createStore(</span><br><span class="line">    combineReducers(reducers),</span><br><span class="line">    initial_state, // 设置 state 的初始值</span><br><span class="line">    applyMiddleware(...middleware)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="五、视图与数据"><a href="#五、视图与数据" class="headerlink" title="五、视图与数据"></a>五、视图与数据</h3><p>  src/index.js 主要实现了 dva 的 view 层，同时传递了一些初始化数据到 dva-core 所实现的 model 层。当然还提供了如下一些 dva 中常用的方法函数，这么看 dva 真的是很薄的一层封装。<br>  1）dynamic 动态加载(2.0 以后官方提供 1.x 自己手动实现吧)<br>  2）fetch 请求方法(其实 dva 只是做了一把搬运工)<br>  3）saga(数据层处理异步的方法)。</p>
<p>  而 dva-core 主要解决了 model 的问题，包括 state 管理、数据的异步加载、订阅-发布模式的实现，可以作为数据层在别处使用(看 2.0 更新也确实是作者的意图)。使用的状体啊管理库还是 redux，异步加载的解决方案是 saga。当然，一切也都写在 index.js 和 package.json 里。</p>
<p>  处理 React 的 model 层问题有很多种办法，比如状态管理就不一定要用 Redux，也可以使用 Mobx(写法会更有 MVX 框架的感觉)；异步数据流也未必使用 redux-saga，redux-thunk 或者 redux-promise 的解决方式也可以(不过目前看来 saga 是相对更优雅的)。</p>
<p>  放两篇个人感觉比较全面的技术文档：<br>  阮一峰前辈的 <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">redux 三部曲</a>。<br>  redux-saga 的 <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">中文文档</a>。</p>
<p>  以及两者的 github：<br>  <a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">redux</a><br>  <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a></p>
<p>  接下来继续深扒 dva-core，还是先从 package.json 扒起。</p>
<h3 id="六、dva-core-gt-package-json"><a href="#六、dva-core-gt-package-json" class="headerlink" title="六、dva-core &gt; package.json"></a>六、dva-core &gt; package.json</h3><p>  dva-core 的 package.json 中依赖包如下：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"babel-runtime"</span>: <span class="string">"^6.26.0"</span>,  // 一个编译后文件引用的公共库，可以有效减少编译后的文件体积</span><br><span class="line"><span class="string">"flatten"</span>: <span class="string">"^1.0.2"</span>,         // 一个将多个数组值合并成一个数组的库</span><br><span class="line"><span class="string">"global"</span>: <span class="string">"^4.3.2"</span>,          // 用于提供全局函数比如 document 的引用</span><br><span class="line"><span class="string">"invariant"</span>: <span class="string">"^2.2.1"</span>,       // 一个有趣的断言库</span><br><span class="line"><span class="string">"is-plain-object"</span>: <span class="string">"^2.0.3"</span>, // 判断是否是一个对象</span><br><span class="line"><span class="string">"redux"</span>: <span class="string">"^3.7.1"</span>,           // redux ，管理 react 状态的库</span><br><span class="line"><span class="string">"redux-saga"</span>: <span class="string">"^0.15.4"</span>,     // 处理异步数据流</span><br><span class="line"><span class="string">"warning"</span>: <span class="string">"^3.0.0"</span>          // 同样是个断言库，不过输出的是警告</span><br></pre></td></tr></table></figure></p>
<p>  当然因为打包还是用的 ruban，script 里没有什么太多有用的东西。继续依循惯例，去翻 src/index.js。</p>
<h3 id="七、dva-core-gt-src-index-js"><a href="#七、dva-core-gt-src-index-js" class="headerlink" title="七、dva-core &gt; src/index.js"></a>七、dva-core &gt; src/index.js</h3><p>  dva 的 src/index.js 里，通过传递 2 个变量 opts 和 createOpts 并调用 core.create，dva 创建了一个 app 对象。其中 opts 是使用者添加的控制选项，createOpts 则是初始化了 reducer 与 redux 的中间件。</p>
<p>  dva-core 的 <a href="https://github.com/dvajs/dva/blob/master/packages/dva-core/src/index.js" target="_blank" rel="noopener">src/index.js</a> 里便是这个 app 对象的具体创建过程以及包含的方法：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> create(hooksAndOpts = &#123;&#125;, createOpts = &#123;&#125;) &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">        initialReducer,</span><br><span class="line">        setupApp = noop,</span><br><span class="line">    &#125; = createOpts;</span><br><span class="line"></span><br><span class="line">    const plugin = new Plugin();</span><br><span class="line">    plugin.use(filterHooks(hooksAndOpts));</span><br><span class="line"></span><br><span class="line">    const app = &#123;</span><br><span class="line">        _models: [</span><br><span class="line">            prefixNamespace(&#123; ...dvaModel &#125;),</span><br><span class="line">        ],</span><br><span class="line">        _store: null,</span><br><span class="line">        _plugin: plugin,</span><br><span class="line">        use: plugin.use.bind(plugin),</span><br><span class="line">        model,</span><br><span class="line">        start,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> app;</span><br><span class="line"></span><br><span class="line">    // .... 方法的实现</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">model</span></span>()&#123;</span><br><span class="line">        // model 方法</span><br><span class="line">    &#125;</span><br><span class="line">    functoin <span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">        // Start 方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  JavaScript 是一个函数向的编程语言，也就是函数里可以定义函数，返回值也可以是函数，class 最后也是被解释成函数。在 dva-core 里创建了 app 对象，但是把 model 和 start 的定义放在了后面。一开始对这种简写没看懂，后来熟悉了以后发现确实好理解，一眼就可以看到 app 所包含的方法，如果需要研究具体方法的话才需要向后看。</p>
  <font size="4" face="黑体"><strong>Plugin 与 plugin.use：</strong></font>

<p>  <a href="https://github.com/dvajs/dva/blob/master/packages/dva-core/src/Plugin.js" target="_blank" rel="noopener">Plugin</a> 是作者设置的一堆钩子性监听函数，即在符合某些条件的情况下(dva 作者)进行手动调用。这样使用者只要按照作者设定过的关键词传递回调函数，在这些条件下便会自动触发。</p>
<p>  最初理解钩子的概念是在 Angular 里，为了能像 React 一样优雅的控制组件的生命周期，Angular 设置了一堆接口(因为使用的是 ts，所以 Angular 里有类和接口的区分)。只要组件实现(implements)对应的接口，或者称生命周期钩子，在对应的条件下就会运行接口的方法。</p>
<p>  Plugin 与 plugin.use 都有使用数组的 reduce 方法的行为：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">const hooks = [</span><br><span class="line">    <span class="string">'onError'</span>,</span><br><span class="line">    <span class="string">'onStateChange'</span>,</span><br><span class="line">    <span class="string">'onAction'</span>,</span><br><span class="line">    <span class="string">'onHmr'</span>,</span><br><span class="line">    <span class="string">'onReducer'</span>,</span><br><span class="line">    <span class="string">'onEffect'</span>,</span><br><span class="line">    <span class="string">'extraReducers'</span>,</span><br><span class="line">    <span class="string">'extraEnhancers'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> filterHooks(obj) &#123;</span><br><span class="line">    <span class="built_in">return</span> Object.keys(obj).reduce((memo, key) =&gt; &#123;</span><br><span class="line">        // 如果对象的 key 在 hooks 数组中</span><br><span class="line">        // 为 memo 对象添加新的 key，值为 obj 对应 key 的值</span><br><span class="line">        <span class="keyword">if</span> (hooks.indexOf(key) &gt; -1) &#123;</span><br><span class="line">            memo[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> memo;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default class Plugin &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        this.hooks = hooks.reduce((memo, key) =&gt; &#123;</span><br><span class="line">            memo[key] = [];</span><br><span class="line">            <span class="built_in">return</span> memo;</span><br><span class="line">        &#125;, &#123;&#125;);</span><br><span class="line">        /*</span><br><span class="line">        // 等同于</span><br><span class="line">        this.hooks = &#123;</span><br><span class="line">            onError: [],</span><br><span class="line">            onStateChange:[],</span><br><span class="line">            ....</span><br><span class="line">            extraEnhancers: []</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    use(plugin) &#123;</span><br><span class="line">        invariant(isPlainObject(plugin), <span class="string">'plugin.use: plugin should be plain object'</span>);</span><br><span class="line">        const hooks = this.hooks;</span><br><span class="line">        <span class="keyword">for</span> (const key <span class="keyword">in</span> plugin) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(plugin, key)) &#123;</span><br><span class="line">                invariant(hooks[key], `plugin.use: unknown plugin property: <span class="variable">$&#123;key&#125;</span>`);</span><br><span class="line">                <span class="keyword">if</span> (key === <span class="string">'extraEnhancers'</span>) &#123;</span><br><span class="line">                    hooks[key] = plugin[key];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hooks[key].push(plugin[key]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  代码解释：</p>
<p>  1）构造器中的 reduce 初始化了一个以 hooks 数组所有元素为 key，值为空数组的对象，并赋给了 class 的私有变量 this.hooks。</p>
<p>  2）filterHooks 通过 reduce 过滤了 hooks 数组以外的钩子。</p>
<p>  3）use 中使用 hasOwnProperty 判断 key 是 plugin 的自身属性还是继承属性，使用原型链调用而不是 plugin.hasOwnProperty() 是防止使用者故意捣乱在 plugin 自己写一个 hasOwnProperty = () =&gt; false，这样无论如何调用 plugin.hasOwnProperty() 返回值都是 false。</p>
<p>  4）use 中使用 reduce 为 this.hooks 添加了 plugin[key] 。</p>
<h3 id="八、model-方法"><a href="#八、model-方法" class="headerlink" title="八、model 方法"></a>八、model 方法</h3><p>  model 是 app 添加 model 的方法，在dva 项目的 index.js 是这么用的：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.model(require(<span class="string">'./models/example'</span>));</span><br></pre></td></tr></table></figure></p>
<p>  在 dva 中没对 model 做任何处理，所以 dva-core 中的 model 就是 dva 项目里调用的 model:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> model(m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        checkModel(m, app._models);</span><br><span class="line">    &#125;</span><br><span class="line">    app._models.push(prefixNamespace(m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  代码解释：</p>
<p>  1）checkModel 主要是用 invariant 对传入的 model 进行了合法性检查。</p>
<p>  2）prefixNamespace 又使用 reduce 对每一个 model 做处理，为 model 的 reducers 和 effects 中的方法添加了 ${namespace}/ 的前缀。</p>
<p>  3）Ever wonder why we dispatch the action like this in dva ? dispatch({type: ‘example/loadDashboard’</p>
<h3 id="九、start-方法"><a href="#九、start-方法" class="headerlink" title="九、start 方法"></a>九、start 方法</h3><p>  start 方法是 dva-core 的核心，在 start 方法里，dva 完成了 store 初始化以及 redux-saga 的调用。比起 dva 的 start，它引入了更多的调用方式。下面一步一步分析：</p>
<h4 id="1、onError："><a href="#1、onError：" class="headerlink" title="1、onError："></a>1、onError：</h4><p>  这是一个全局错误处理，返回了一个接收错误并处理的函数，并以 err 和 app._store.dispatch 为参数执行调用:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const onError = (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof err === <span class="string">'string'</span>) err = new Error(err);</span><br><span class="line">        err.preventDefault = () =&gt; &#123;</span><br><span class="line">            err._dontReject = <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        plugin.apply(<span class="string">'onError'</span>, (err) =&gt; &#123;</span><br><span class="line">            throw new Error(err.stack || err);</span><br><span class="line">        &#125;)(err, app._store.dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  上面代码中，plugin.apply 的实现：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apply(key, defaultHandler) &#123;</span><br><span class="line">    const hooks = this.hooks;</span><br><span class="line"></span><br><span class="line">    /* 通过 validApplyHooks 进行过滤， apply 方法只能应用在全局报错或者热更替上 */ </span><br><span class="line">    const  validApplyHooks = [<span class="string">'onError'</span>, <span class="string">'onHmr'</span>];</span><br><span class="line">    invariant(validApplyHooks.indexOf(key) &gt; -1, `plugin.apply: hook <span class="variable">$&#123;key&#125;</span> cannot be applied`);</span><br><span class="line"></span><br><span class="line">    /* 从钩子中拿出挂载的回调函数 ，挂载动作见 use 部分*/</span><br><span class="line">    const fns = hooks[key];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> (...args) =&gt; &#123;</span><br><span class="line">        // 如果有回调执行回调</span><br><span class="line">        <span class="keyword">if</span> (fns.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (const fn of fns) &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有回调直接抛出错误</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultHandler) &#123;</span><br><span class="line">        defaultHandler(...args);</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">            这里 defaultHandler 为 (err) =&gt; &#123;</span><br><span class="line">                throw new Error(err.stack || err);</span><br><span class="line">            &#125;</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、sagaMiddleware："><a href="#2、sagaMiddleware：" class="headerlink" title="2、sagaMiddleware："></a>2、sagaMiddleware：</h4><p>  下一行代码是 const sagaMiddleware = createSagaMiddleware() 。和 redux-sagas 的入门教程有点差异，因为正统的教程上添加 sagas 中间件的方法是 createSagaMiddleware(…sagas)，sagas 为含有 saga 方法的 generator 函数数组。但是 api 里确实还提到，还有一种动态调用的方式 const task = sagaMiddleware.run(dynamicSaga)。于是：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const sagaMiddleware = createSagaMiddleware();</span><br><span class="line">// ...</span><br><span class="line">const sagas = [];</span><br><span class="line">const reducers = &#123;...initialReducer&#125;;</span><br><span class="line"><span class="keyword">for</span> (const m of app._models) &#123;</span><br><span class="line">    reducers[m.namespace] = getReducer(m.reducers, m.state);</span><br><span class="line">    <span class="keyword">if</span> (m.effects) sagas.push(app._getSaga(m.effects, m, onError, plugin.get(<span class="string">'onEffect'</span>)));</span><br><span class="line">&#125;</span><br><span class="line">// ....</span><br><span class="line"></span><br><span class="line">store.runSaga = sagaMiddleware.run;</span><br><span class="line">// Run sagas</span><br><span class="line">sagas.forEach(sagaMiddleware.run);</span><br></pre></td></tr></table></figure></p>
<h4 id="3、sagas："><a href="#3、sagas：" class="headerlink" title="3、sagas："></a>3、sagas：</h4><p>  那么 sagas 是什么呢？</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">    middleware: promiseMiddleware,</span><br><span class="line">    resolve,</span><br><span class="line">    reject,</span><br><span class="line">&#125; = createPromiseMiddleware(app);</span><br><span class="line">app._getSaga = getSaga.bind(null, resolve, reject);</span><br><span class="line"></span><br><span class="line">const sagas = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (const m of app._models) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m.effects) sagas.push(app._getSaga(m.effects, m, onError, plugin.get(<span class="string">'onEffect'</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  显然，sagas 是一个数组，里面的元素是用 app._getSaga 处理后的返回结果，而 app._getSaga 又和上面 createPromiseMiddleware 代理 app 后返回的对象有很大关系。</p>
  <font size="4" face="黑体"><strong>createPromiseMiddleware：</strong></font>

<p>  createPromiseMiddleware 的代码在此，如果看着觉得眼熟，那肯定不是因为看过 redux-promise 源码的缘故:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NAMESPACE_SEP &#125; from <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> createPromiseMiddleware(app) &#123;</span><br><span class="line">    <span class="built_in">return</span> () =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">        const &#123; <span class="built_in">type</span> &#125; = action;</span><br><span class="line">        <span class="keyword">if</span> (isEffect(<span class="built_in">type</span>)) &#123;</span><br><span class="line">            <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                next(&#123;</span><br><span class="line">                    __dva_resolve: resolve,</span><br><span class="line">                    __dva_reject: reject,</span><br><span class="line">                    ...action,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> next(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> isEffect(<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">type</span> || typeof <span class="built_in">type</span> !== <span class="string">'string'</span>) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        const [namespace] = type.split(NAMESPACE_SEP);</span><br><span class="line">        const model = app._models.filter(m =&gt; m.namespace === namespace)[0];</span><br><span class="line">        <span class="keyword">if</span> (model) &#123;</span><br><span class="line">            <span class="keyword">if</span> (model.effects &amp;&amp; model.effects[<span class="built_in">type</span>]) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
  <font size="4" face="黑体"><strong>middleware：</strong></font>

<p>  middleware 是一个 redux 的中间件，即在不影响 redux 本身功能的情况下为其添加了新特性的代码。redux 的中间件通过拦截 action 来实现其作用的：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const middleware = () =&gt; next =&gt; (action) =&gt; &#123;</span><br><span class="line">    const &#123; <span class="built_in">type</span> &#125; = action;</span><br><span class="line">    <span class="keyword">if</span> (isEffect(<span class="built_in">type</span>)) &#123;</span><br><span class="line">        <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            // .... resolve ,reject</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> isEffect(<span class="built_in">type</span>) &#123;</span><br><span class="line">    // dva 里 action 的 <span class="built_in">type</span> 有固定格式： model.namespace/model.effects</span><br><span class="line">    // const [namespace] = type.split(NAMESPACE_SEP); 是 es6 解构的写法</span><br><span class="line">    // 等同于 const namespace = type.split(NAMESPACE_SEP)[0];</span><br><span class="line">    // NAMESPACE_SEP 的值是 `/`</span><br><span class="line">    const [namespace] = type.split(NAMESPACE_SEP);</span><br><span class="line">    // 根据 namespace 过滤出对应的 model</span><br><span class="line">    const model = app._models.filter(m =&gt; m.namespace === namespace)[0];</span><br><span class="line">    // 如果 model 存在并且 model.effects[<span class="built_in">type</span>] 也存在，那必然是 effects</span><br><span class="line">    <span class="keyword">if</span> (model) &#123;</span><br><span class="line">        <span class="keyword">if</span> (model.effects &amp;&amp; model.effects[<span class="built_in">type</span>]) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  const middleware = ({dispatch}) =&gt; next =&gt; (action) =&gt; {… return next(action)} 基本上是一个标准的中间件写法。在 return next(action) 之前可以对 action 做各种各样的操作。因为此中间件没用到 dispatch 方法，所以省略了。</p>
<p>  本段代码的意思是，如果 dispatch 的 action 指向的是 model 里的 effects，那么返回一个 Promise 对象。此 Promise 的对象的解决(resolve) 或者驳回方法 (reject) 放在 map 对象中。如果是非 effects (那就是 action 了)，放行。</p>
<p>  换句话说，middleware 拦截了指向 effects 的 action。</p>
  <font size="4" face="黑体"><strong>神奇的 bind：</strong></font>

<p>  bind 的作用是绑定新的对象，生成新函数。bind 也可以提前设定好函数的某些参数生成新函数，等到最后一个参数确定时直接调用。(JavaScript 的参数是怎么被调用的？ <a href="https://juejin.im/post/598d0b7ff265da3e1727c491" target="_blank" rel="noopener">JavaScript 专题之函数柯里化</a> )</p>
<p>  这段代码恰好就是 bind 的一种实践方式:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const map = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const middleware = () =&gt; next =&gt; (action) =&gt; &#123;</span><br><span class="line">    const &#123; <span class="built_in">type</span> &#125; = action;</span><br><span class="line">    // ...</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        map[<span class="built_in">type</span>] = &#123;</span><br><span class="line">            resolve: wrapped.bind(null, <span class="built_in">type</span>, resolve),</span><br><span class="line">            reject: wrapped.bind(null, <span class="built_in">type</span>, reject),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    // ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> wrapped(<span class="built_in">type</span>, fn, args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[<span class="built_in">type</span>]) delete map[<span class="built_in">type</span>];</span><br><span class="line">    fn(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> resolve(<span class="built_in">type</span>, args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[<span class="built_in">type</span>]) &#123;</span><br><span class="line">        map[<span class="built_in">type</span>].resolve(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> reject(<span class="built_in">type</span>, args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[<span class="built_in">type</span>]) &#123;</span><br><span class="line">        map[<span class="built_in">type</span>].reject(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">    middleware,</span><br><span class="line">    resolve,</span><br><span class="line">    reject,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  分析这段代码，dva 是这样做的：</p>
<p>  1、通过 wrapped.bind(null, type, resolve) 产生了一个新函数，并且赋值给匿名对象的 resolve 属性(reject 同理)。 wrap 接收三个参数，通过 bind 已经设定好了两个，wrapped.bind(null, type, resolve) 等同于 wrap(type, resolve, xxx)，此处 resolve 是 Promise 对象中的。通过 bind 赋给匿名对象的 resolve 属性后，匿名对象.resolve(xxxx) 等同于 wrap(type, resolve, xxx)，即 reslove(xxx)。</p>
<p>  2、使用 type 在 map 对象中保存此匿名对象，而 type 是 action 的 type，即 namespace/effects 的形式，方便之后进行调用。</p>
<p>  3、return 出的 resolve 接收 type 和 args 两个参数。type 用来在 map 中寻找 1 里的匿名函数，args 用来像 1.2 里那样执行。这样做的作用是：分离了 promise 与 promise 的执行，在函数的作用域外依然可以访问到函数的内部变量，换言之：闭包。</p>
  <font size="4" face="黑体"><strong>getSaga：</strong></font>

<p>  导出的 resolve 与 reject 方法，通过 bind 先设置进了 getSaga (同时也赋给了 app._getSaga)，sagas 最终也将 getSaga 的返回值放入了数组。<a href="https://github.com/dvajs/dva/blob/master/packages/dva-core/src/getSaga.js" target="_blank" rel="noopener">getSaga源码</a>:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> getSaga(resolve, reject, effects, model, onError, onEffect) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> *() &#123;</span><br><span class="line">        <span class="keyword">for</span> (const key <span class="keyword">in</span> effects) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(effects, key)) &#123;</span><br><span class="line">                const watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect);</span><br><span class="line">                // 将 watcher 分离到另一个线程去执行</span><br><span class="line">                const task = yield sagaEffects.fork(watcher);</span><br><span class="line">                // 同时 fork 了一个线程，用于在 model 卸载后取消正在进行中的 task</span><br><span class="line">                // `<span class="variable">$&#123;model.namespace&#125;</span>/@@CANCEL_EFFECTS` 的发出动作在 index.js 的 start 方法中，unmodel 方法里。</span><br><span class="line">                yield sagaEffects.fork(<span class="keyword">function</span> *() &#123;</span><br><span class="line">                    yield sagaEffects.take(`<span class="variable">$&#123;model.namespace&#125;</span>/@@CANCEL_EFFECTS`);</span><br><span class="line">                    yield sagaEffects.cancel(task);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，getSaga 最终返回了一个 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">generator 函数</a>，在该函数遍历了 model 中 effects 属性的所有方法（注：同样是 generator 函数）。结合 index.js 里的 for (const m of app._models)，该遍历针对所有的 model。</p>
<p>  对于每一个 effect，getSaga 生成了一个 watcher ，并使用 saga 函数的 fork 将该函数切分到另一个单独的线程中去（生成了一个 task 对象）。同时为了方便对该线程进行控制，在此 fork 了一个 generator 函数。在该函数中拦截了取消 effect 的 action（事实上，应该是卸载effect 所在 model 的 action），一旦监听到则立刻取消分出去的 task 线程。</p>
  <font size="4" face="黑体"><strong>getWatcher：</strong></font>

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getWatcher(resolve, reject, key, _effect, model, onError, onEffect) &#123;</span><br><span class="line">    <span class="built_in">let</span> effect = _effect;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">type</span> = <span class="string">'takeEvery'</span>;</span><br><span class="line">    <span class="built_in">let</span> ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Array.isArray(_effect)) &#123;</span><br><span class="line">        // effect 是数组而不是函数的情况下暂不考虑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> *sagaWithCatch(...args) &#123;</span><br><span class="line">            // .... sagaWithCatch 的逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key);</span><br><span class="line"></span><br><span class="line">    switch (<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'watcher'</span>:</span><br><span class="line">            <span class="built_in">return</span> sagaWithCatch;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'takeLatest'</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="keyword">function</span>*() &#123;</span><br><span class="line">                yield takeLatest(key, sagaWithOnEffect);</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'throttle'</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="keyword">function</span>*() &#123;</span><br><span class="line">                yield throttle(ms, key, sagaWithOnEffect);</span><br><span class="line">            &#125;;</span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">return</span> <span class="keyword">function</span>*() &#123;</span><br><span class="line">                yield takeEvery(key, sagaWithOnEffect);</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createEffects(model) &#123;</span><br><span class="line">    // createEffects(model) 的逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> applyOnEffect(fns, effect, model, key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (const fn of fns) &#123;</span><br><span class="line">        effect = fn(effect, sagaEffects, model, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  先不考虑 effect 的属性是数组而不是方法的情况。getWatcher 接收六个参数：<br>  1、resolve/reject: 中间件 middleware 的 res 和 rej 方法。<br>  2、key: 经过 prefixNamespace 转义后的 effect 方法名，namespace/effect（也是调用 action 时的 type）。 -_effect:effects 中 key 属性所指向的 generator 函数。<br>  3、model： model<br>  4、onError： 之前定义过的捕获全局错误的方法<br>  5、onEffect：plugin.use 中传入的在触发 effect 时执行的回调函数（钩子函数）</p>
<p>  getWatcher 中 applyOnEffect 对 effect 进行了动态代理，在保证 effect （即 _effect）正常调用的情况下，为期添加了 fns 的回调函数数组(即 onEffect)。使得在 effect 执行时， onEffect 内的每一个回调函数都可以被触发。</p>
<p>  因为没有经过 effects 的属性是数组的情况，所以代码中 type 的值是 takeEvery，也就是监听每一个发出的 action ，即 getWatcher 的返回值最终走的是 switch 的 default 选项，换句话说，每次发出指向 effects 的函数都会调用 sagaWithOnEffect:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>*() &#123;</span><br><span class="line">    yield takeEvery(key, sagaWithOnEffect);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  根据 const sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key) 的执行情况，如果 onEffect 的插件为空的情况下，sagaWithOnEffect 的值为 sagaWithCatch ：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *sagaWithCatch(...args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        yield sagaEffects.put(&#123; <span class="built_in">type</span>: `<span class="variable">$&#123;key&#125;</span><span class="variable">$&#123;NAMESPACE_SEP&#125;</span>@@start` &#125;);</span><br><span class="line">        const ret = yield effect(...args.concat(createEffects(model)));</span><br><span class="line">        yield sagaEffects.put(&#123; <span class="built_in">type</span>: `<span class="variable">$&#123;key&#125;</span><span class="variable">$&#123;NAMESPACE_SEP&#125;</span>@@end` &#125;);</span><br><span class="line">        resolve(key, ret);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        onError(e);</span><br><span class="line">        <span class="keyword">if</span> (!e._dontReject) &#123;</span><br><span class="line">            reject(key, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在 sagaWithOnEffect 函数中，sagas 使用传入的参数(也就是 action)执行了对应的 model 中 对应的 effect 方法，同时将返回值使用之前保存在 map 里的 resolve 返回了其返回值。同时在执行 effect 方法的时候，将 saga 本身的所有方法(put、call、fork 等)作为第二个参数，使用 concat 拼接在 action 的后面。在执行 effect 方法前，又发出了 start 和 end 两个 action，方便 onEffect 的插件进行拦截和调用。</p>
<p>  因此，对于 if (m.effects) sagas.push(app._getSaga(m.effects, m, onError, plugin.get(‘onEffect’)));。<br>  1、dva 通过 app._getSaga(m.effects, m, onError, plugin.get(‘onEffect’)) 返回了一个 genenrator 函数。<br>  2、在 genenrator 函数中手动 fork 出一个 watcher 函数的监听线程(当然也 fork 了取消线程的功能)。<br>  3、该函数(在普通状态下)是一个 takeEvery 的阻塞是线程，接收 2 个参数。第一个参数为监听的 action，第二个参数为监听到 action 后的回调函数。<br>  4、 (普通状态下)的回调函数，就是手动调用了 model 里 effects 中对应属性的函数。在此之前之后发出了 start 和 end 的 action，同时用之前 promise 中间件保存在 map 中的 resolve 方法返回了值。<br>  5、最后使用 sagas.forEach(sagaMiddleware.run) 启动了 watcher 的监听。</p>
<h4 id="4、store："><a href="#4、store：" class="headerlink" title="4、store："></a>4、store：</h4><p>  现在已经有了针对异步数据流的解决办法，那么该创建 store 了。正常情况的 redux 的 createStore 接收三个参数，reducer，initState，applyMiddleware(middlewares)。不过 dva 提供了自己的 createStore 方法，用来组织一系列自己创建的参数：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Create store</span><br><span class="line">const store = app._store = createStore(&#123; // eslint-disable-line</span><br><span class="line">    reducers: createReducer(),</span><br><span class="line">    initialState: hooksAndOpts.initialState || &#123;&#125;,</span><br><span class="line">    plugin,</span><br><span class="line">    createOpts,</span><br><span class="line">    sagaMiddleware,</span><br><span class="line">    promiseMiddleware,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
  <font size="4" face="黑体"><strong>createReducer：</strong></font>

  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">createReducer</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> reducerEnhancer(combineReducers(&#123;</span><br><span class="line">        ...reducers,</span><br><span class="line">        ...extraReducers,</span><br><span class="line">        ...(app._store ? app._store.asyncReducers : &#123;&#125;),</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  createReducer 实际上是用 plugin 里的 onReducer(如果没有便直接返回 reducer) 扩展了 reducer 功能，对于 const reducerEnhancer = plugin.get(‘onReducer’)，plugin 里的相关代码为：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getOnReducer(hook) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (reducer) &#123;</span><br><span class="line">        <span class="keyword">for</span> (const reducerEnhancer of hook) &#123;</span><br><span class="line">            reducer = reducerEnhancer(reducer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> reducer;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  combineReducers 中：<br>  1、第一个参数 …reducers 是从 dva 里传入的 historyReducer，以及通过 reducers[m.namespace] = getReducer(m.reducers, m.state) 剥离出的 model 中的 reducer<br>  2、第二个参数为手动在 plugin 里添加的 extraReducers<br>  3、第三个参数为异步 reducer，主要是用于在 dva 运行以后动态加载 model 里的 reducer</p>
  <font size="4" face="黑体"><strong>createStore：</strong></font>

<p>  现在我们有了一个 combine 过的 reducer，有了 core 中创建的 sagaMiddleware 和 promiseMiddleware，还有了从 dva 中传入的 createOpts，现在可以正式创建 store 了。</p>
<p>  从 dva 中传入的 createOpts 为：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setupMiddlewares(middlewares) &#123;</span><br><span class="line">    <span class="built_in">return</span> [</span><br><span class="line">        routerMiddleware(<span class="built_in">history</span>),</span><br><span class="line">        ...middlewares,</span><br><span class="line">    ];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>  把 redux-router 的中间件排在中间件的第一个，虽然看起来很长，但是对于大多数普通用户来说，在未开启 redux 的调试插件，未传入额外的 onAction 以及 extraEnhancers 的情况下，上面的代码等价于:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware, compose &#125; from <span class="string">'redux'</span>;</span><br><span class="line">import flatten from <span class="string">'flatten'</span>;</span><br><span class="line">import invariant from <span class="string">'invariant'</span>;</span><br><span class="line">import window from <span class="string">'global/window'</span>;</span><br><span class="line">import &#123; returnSelf, isArray &#125; from <span class="string">'./utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> (&#123;</span><br><span class="line">    reducers,</span><br><span class="line">    initialState,</span><br><span class="line">    plugin,</span><br><span class="line">    sagaMiddleware,</span><br><span class="line">    promiseMiddleware,</span><br><span class="line">    createOpts: &#123;</span><br><span class="line">        setupMiddlewares = returnSelf,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line"></span><br><span class="line">const middlewares = setupMiddlewares([</span><br><span class="line">    sagaMiddleware,</span><br><span class="line">    promiseMiddleware</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">const enhancers = [</span><br><span class="line">    applyMiddleware(...middlewares)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> createStore(reducers, initialState, compose(...enhancers));</span><br><span class="line">// 对于 redux 中 的 compose 函数，在数组长度为 1  的情况下返回第一个元素。</span><br><span class="line">// compose(...enhancers) 等同于 applyMiddleware(...middlewares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5、订阅："><a href="#5、订阅：" class="headerlink" title="5、订阅："></a>5、订阅：</h4><p>  现在 dva 已经创建了 store，有了异步数据流加载方案，并且又做了一些其他的事情，如手动运行 getSaga 里返回的 watcer 函数，判断如果有 onStateChange 的 plugin 也手动运行一下等：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Extend store</span><br><span class="line">store.runSaga = sagaMiddleware.run;</span><br><span class="line">store.asyncReducers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// Execute listeners when state is changed</span><br><span class="line">const listeners = plugin.get(<span class="string">'onStateChange'</span>);</span><br><span class="line"><span class="keyword">for</span> (const listener of listeners) &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">        listener(store.getState());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Run sagas</span><br><span class="line">sagas.forEach(sagaMiddleware.run);</span><br></pre></td></tr></table></figure></p>
<p>  model 里的 state、effect、reducer 已经实现了，就缺最后的订阅 subscription 部分：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Setup app</span><br><span class="line">setupApp(app);</span><br><span class="line"></span><br><span class="line">// Run subscriptions</span><br><span class="line">const unlisteners = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (const model of this._models) &#123;</span><br><span class="line">    <span class="keyword">if</span> (model.subscriptions) &#123;</span><br><span class="line">        unlisteners[model.namespace] = runSubscription(model.subscriptions, model, app, onError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  setupApp(app) 是从 dva 里传过来的，主要是使用 patchHistory 函数代理 history.linsten，即强化了 redux 和 router 的联系，是的路径变化可以引起 state 的变化，进而听过监听 state 的变化来触发回调。这也是 core 中唯一使用 this 的地方，逼得 dva 中必须使用 oldStart.call(app) 来进行调用。</p>
  <font size="4" face="黑体"><strong>runSubscription：</strong></font>

<p>  这是 runSubscription 的代码:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> run(subs, model, app, onError) &#123;</span><br><span class="line">    const funcs = [];</span><br><span class="line">    const nonFuncs = [];</span><br><span class="line">    <span class="keyword">for</span> (const key <span class="keyword">in</span> subs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(subs, key)) &#123;</span><br><span class="line">            const sub = subs[key];</span><br><span class="line">            const unlistener = sub(&#123;</span><br><span class="line">                dispatch: prefixedDispatch(app._store.dispatch, model),</span><br><span class="line">                <span class="built_in">history</span>: app._history,</span><br><span class="line">            &#125;, onError);</span><br><span class="line">            <span class="keyword">if</span> (isFunction(unlistener)) &#123;</span><br><span class="line">                funcs.push(unlistener);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonFuncs.push(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> &#123; funcs, nonFuncs &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  1、第一个参数为 model 中的 subscription 对象<br>  2、第二个参数为对应的 model<br>  3、第三个参数为 core 里创建的 app<br>  4、第四个参数为全局异常捕获的 onError</p>
<p>  a、Object.prototype.hasOwnProperty.call(subs, key) 还是使用原型方法判断 key 是不是 subs 的自有属性。<br>  b、如果是自由属性，那么拿到属性对应的值(是一个 function)<br>  c、调用该 function，传入 dispatch 和 history 属性。history 就是经过 redux-router 强化过的 history，而 dispatch，也就是 prefixedDispatch(app._store.dispatch, model)<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> prefixedDispatch(dispatch, model) &#123;</span><br><span class="line">    <span class="built_in">return</span> (action) =&gt; &#123;</span><br><span class="line">        // 断言检测</span><br><span class="line">        <span class="built_in">return</span> dispatch(&#123; ...action, <span class="built_in">type</span>: prefixType(<span class="built_in">type</span>, model) &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  实际上是用将 action 里的 type 添加了 ${model.namespance}/ 的前缀。自此，model 中的四大组件全部完毕，完成了 dva 的数据层处理。</p>
<p>标注：</p>
<ul>
<li>参考资料1：<a href="https://dvajs.com" target="_blank" rel="noopener">https://dvajs.com</a></li>
</ul>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年01月22日 18:18</p>
        <p>原始链接： <a class="post-url" href="/2019/01/08/Dva-gw-06/" title="Dva官网之06-dva 源码解析">http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/</a></p>
        <footer>
            <a href="http://liuxuewen-site.github.io">
                <img src="/images/logo.png" alt="liuxuewen">
                liuxuewen
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/&title=《Dva官网之06-dva 源码解析》 — LIUXUEWEN'S BLOG&pic=http://liuxuewen-site.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/&title=《Dva官网之06-dva 源码解析》 — LIUXUEWEN'S BLOG&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Dva官网之06-dva 源码解析》 — LIUXUEWEN'S BLOG&url=http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/&via=http://liuxuewen-site.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/前端-react/" class="color4">前端-react</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一、项目-gt-package-json"><span class="post-toc-text">一、项目 &gt; package.json</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二、项目-gt-src-index-js"><span class="post-toc-text">二、项目 &gt; src/index.js</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三、dva-gt-package-json"><span class="post-toc-text">三、dva &gt; package.json</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四、dva-gt-src-index-js"><span class="post-toc-text">四、dva &gt; src/index.js</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五、视图与数据"><span class="post-toc-text">五、视图与数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#六、dva-core-gt-package-json"><span class="post-toc-text">六、dva-core &gt; package.json</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#七、dva-core-gt-src-index-js"><span class="post-toc-text">七、dva-core &gt; src/index.js</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#八、model-方法"><span class="post-toc-text">八、model 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#九、start-方法"><span class="post-toc-text">九、start 方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1、onError："><span class="post-toc-text">1、onError：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2、sagaMiddleware："><span class="post-toc-text">2、sagaMiddleware：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3、sagas："><span class="post-toc-text">3、sagas：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4、store："><span class="post-toc-text">4、store：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5、订阅："><span class="post-toc-text">5、订阅：</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2019/01/25/JS-deep-01/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          深入理解JavaScript系列01-内存空间
        
      </span>
    </a>
  
  
    <a href="/2019/01/07/Dva-gw-05/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Dva官网之05-dva 开发复杂 SPA</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <!-- <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 liuxuewen<br>
      </p> -->
      <p>
        1320325272@qq.com 
        liuxuewen
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "http://liuxuewen-site.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/hexo/">hexo</a><a class="category-link" href="/categories/前端/">前端</a><a class="category-link" href="/categories/后台/">后台</a><a class="category-link" href="/categories/数据结构/">数据结构</a><a class="category-link" href="/categories/网络协议/">网络协议</a><a class="category-link" href="/categories/项目/">项目</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/hexo/" style="font-size: 12.86px;">hexo</a> <a href="/tags/前端-CSS/" style="font-size: 14.29px;">前端-CSS</a> <a href="/tags/前端-ES6/" style="font-size: 11.43px;">前端-ES6</a> <a href="/tags/前端-HTML5/" style="font-size: 10px;">前端-HTML5</a> <a href="/tags/前端-JS/" style="font-size: 18.57px;">前端-JS</a> <a href="/tags/前端-react/" style="font-size: 20px;">前端-react</a> <a href="/tags/前端-安全性/" style="font-size: 10px;">前端-安全性</a> <a href="/tags/前端-性能优化/" style="font-size: 10px;">前端-性能优化</a> <a href="/tags/前端-服务器/" style="font-size: 11.43px;">前端-服务器</a> <a href="/tags/前端-移动端适配/" style="font-size: 11.43px;">前端-移动端适配</a> <a href="/tags/前端-考题/" style="font-size: 17.14px;">前端-考题</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/网络协议/" style="font-size: 15.71px;">网络协议</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/hexo/" style="font-size: 12.86px;">hexo</a> <a href="/tags/前端-CSS/" style="font-size: 14.29px;">前端-CSS</a> <a href="/tags/前端-ES6/" style="font-size: 11.43px;">前端-ES6</a> <a href="/tags/前端-HTML5/" style="font-size: 10px;">前端-HTML5</a> <a href="/tags/前端-JS/" style="font-size: 18.57px;">前端-JS</a> <a href="/tags/前端-react/" style="font-size: 20px;">前端-react</a> <a href="/tags/前端-安全性/" style="font-size: 10px;">前端-安全性</a> <a href="/tags/前端-性能优化/" style="font-size: 10px;">前端-性能优化</a> <a href="/tags/前端-服务器/" style="font-size: 11.43px;">前端-服务器</a> <a href="/tags/前端-移动端适配/" style="font-size: 11.43px;">前端-移动端适配</a> <a href="/tags/前端-考题/" style="font-size: 17.14px;">前端-考题</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/网络协议/" style="font-size: 15.71px;">网络协议</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>